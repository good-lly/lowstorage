'use strict';

import { randomUUID } from 'node:crypto';

const matchesQuery = (document, query) => {
	return Object.keys(query).every((key) => document[key] === query[key]);
};

const generateUUID = async () => {
	if (typeof randomUUID !== 'undefined' && typeof randomUUID === 'function') {
		return randomUUID();
	}
	if (typeof crypto !== 'undefined' && typeof crypto === 'object' && typeof crypto.randomUUID === 'function') {
		return crypto.randomUUID();
	}
	return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
		var r = (Math.random() * 16) | 0,
			v = c === 'x' ? r : (r & 0x3) | 0x8;
		return v.toString(16);
	});
};

const _getAvroType = (value, name = 'SubAutoGenerated') => {
	switch (typeof value) {
		case 'string':
			if (_isUUID(value)) {
				return {
					type: 'string',
					name: '_id',
					size: 16,
					logicalType: 'UUID',
				};
			}
			return 'string';
		case 'number':
			return Number.isInteger(value) ? 'int' : 'float';
		case 'boolean':
			return 'boolean';
		case 'object':
			if (value === null) return 'null';
			if (Array.isArray(value)) return { type: 'array', items: _getAvroType(value[0]) };
			return inferAvroType(value, name);
		default:
			return 'string'; // Default to string for unknown types
	}
};

const inferAvroType = (data, typeName = 'AutoGenerated') => {
	if (Array.isArray(data)) {
		data = data[0];
	}
	const fields = Object.entries(data).map(([name, value]) => {
		return { name, type: _getAvroType(value, `${typeName}.${name}`) };
	});
	return {
		type: 'record',
		name: typeName,
		fields: fields,
	};
};

const _isUUID = (str) => {
	const uuidV4Regex = /^[0-9A-F]{8}-[0-9A-F]{4}-4[0-9A-F]{3}-[89AB][0-9A-F]{3}-[0-9A-F]{12}$/i;
	return uuidV4Regex.test(str);
};

export { matchesQuery, generateUUID, inferAvroType };
