"use strict";var l=Object.defineProperty;var $=Object.getOwnPropertyDescriptor;var m=Object.getOwnPropertyNames;var p=Object.prototype.hasOwnProperty;var y=(o,t)=>{for(var s in t)l(o,s,{get:t[s],enumerable:!0})},w=(o,t,s,e)=>{if(t&&typeof t=="object"||typeof t=="function")for(let r of m(t))!p.call(o,r)&&r!==s&&l(o,r,{get:()=>t[r],enumerable:!(e=$(t,r))||e.enumerable});return o};var N=o=>w(l({},"__esModule",{value:!0}),o);var D={};y(D,{default:()=>a});module.exports=N(D);var c="____";function g(...o){for(let t of o)if(typeof t!="object")throw new Error("lowstorage: missing args or args not an object")}function j(o,t){return Object.keys(t).every(s=>o[s]===t[s])}function _(){return crypto.randomUUID()}function b(o,t=null){let s=null;if(t){if(s=o[t],s.get&&s.put&&s.delete&&s.list)return s;throw new Error(`lowstorage: store ${t} not found`)}for(let e of Object.values(o))if(e.get&&e.put&&e.delete&&e.list)return e;throw new Error("lowstorage: no valid store found")}var u=class{constructor(t,s){this.colName=t,this.__store=s}async insert(t){if(Array.isArray(t)){let s=t.map(async e=>{e._id=e._id||_();let r=`${this.colName}/${this.colName}${c}${e._id}`;return this.__store.put(r,JSON.stringify(e))});return Promise.all(s)}if(typeof t=="object"&&t!==null){t._id=t._id||_();let s=`${this.colName}/${this.colName}${c}${t._id}`;return this.__store.put(s,JSON.stringify(t))}throw new Error("Invalid input: input must be an object or an array of objects")}async find(t={}){if(t._id){let n=await this.__store.get(`${this.colName}/${this.colName}${c}${t._id}`);return n?[await n.json()]:[]}let s=await this.__store.list({prefix:`${this.colName}/${this.colName}${c}`}),e=s.truncated,r=e?s.cursor:void 0;for(;e;){let n=await this.__store.list({prefix:`${this.colName}/${this.colName}${c}`,cursor:r});s.objects.push(...n.objects),e=n.truncated,r=n.cursor}let i=s.objects.map(async n=>(await this.__store.get(`${n.key}`)).json());return(await Promise.all(i)).filter(n=>j(n,t))}async findOne(t={}){return(await this.find(t))[0]}async update(t={},s={}){let r=(await this.find(t)).map(async i=>{let d={...i,...s},h=`${this.colName}/${this.colName}${c}${i._id}`;return this.__store.put(h,JSON.stringify(d))});return Promise.all(r)}async updateOne(t={},s={}){let e=await this.findOne(t),r={...e,...s},i=`${this.colName}/${this.colName}${c}${e._id}`;return this.__store.put(i,JSON.stringify(r))}async delete(t={}){let e=(await this.find(t)).map(async r=>{let i=`${this.colName}/${this.colName}${c}${r._id}`;return this.__store.delete(i)});return Promise.all(e)}},a=class{constructor(t,s){g(t),this.__store=b(t,s)}collection(t){return new u(t,this.__store)}};
