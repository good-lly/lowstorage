'use strict';

export const matchesQuery = (document, query) => {
	return Object.keys(query).every((key) => document[key] === query[key]);
};

export const generateUUID = () => {
	if (typeof crypto !== 'undefined' && crypto.randomUUID) {
		return crypto.randomUUID();
	} else {
		// Fallback for environments without crypto.randomUUID
		return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
			var r = (Math.random() * 16) | 0,
				v = c === 'x' ? r : (r & 0x3) | 0x8;
			return v.toString(16);
		});
	}
};

const _getAvroType = (value, name = 'SubAutoGenerated') => {
	switch (typeof value) {
		case 'string':
			if (_isUUID(value)) {
				return {
					type: 'fixed',
					name: 'UUID',
					size: 16,
					logicalType: 'uuid',
				};
			}
			return 'string';
		case 'number':
			return Number.isInteger(value) ? 'int' : 'float';
		case 'boolean':
			return 'boolean';
		case 'object':
			if (value === null) return 'null';
			if (Array.isArray(value)) return { type: 'array', items: _getAvroType(value[0]) };
			return inferAvroType(value, name);
		default:
			return 'string'; // Default to string for unknown types
	}
};

export const inferAvroType = (data, typeName = 'AutoGenerated') => {
	if (Array.isArray(data)) {
		data = data[0];
	}
	const fields = Object.entries(data).map(([name, value]) => {
		return { name, type: _getAvroType(value, `${typeName}.${name}`) };
	});
	return {
		type: 'record',
		name: typeName,
		fields: fields,
	};
};

const _isUUID = (str) => {
	const uuidV4Regex = /^[0-9A-F]{8}-[0-9A-F]{4}-4[0-9A-F]{3}-[89AB][0-9A-F]{3}-[0-9A-F]{12}$/i;
	return uuidV4Regex.test(str);
};
