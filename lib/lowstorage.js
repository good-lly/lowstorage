var Q="AWS4-HMAC-SHA256",j="aws4_request",H="s3",_e="2",R="UNSIGNED-PAYLOAD",fe="application/octet-stream",X="application/xml",b="application/json",ge=["accessKeyId","secretAccessKey","sessionToken","password"],w="x-amz-content-sha256",pe="x-amz-date",Ee="host",Re="Authorization",T="Content-Type",N="Content-Length",Y="etag",J="last-modified",_="ultralight-s3 Module: ",we=`${_}accessKeyId must be a non-empty string`,ye=`${_}secretAccessKey must be a non-empty string`,me=`${_}endpoint must be a non-empty string`,Oe=`${_}bucketName must be a non-empty string`,Z=`${_}key must be a non-empty string`,x=`${_}uploadId must be a non-empty string`,ee=`${_}parts must be a non-empty array`,te=`${_}Each part must have a partNumber (number) and ETag (string)`,k=`${_}data must be a Buffer or string`,re=`${_}prefix must be a string`,se=`${_}maxKeys must be a positive integer`,ie=`${_}delimiter must be a string`,ae=crypto.createHmac||(await import("node:crypto")).createHmac,oe=crypto.createHash||(await import("node:crypto")).createHash;typeof ae>"u"&&typeof oe>"u"&&console.error("ultralight-S3 Module: Crypto functions are not available, please report the issue with necessary description: https://github.com/sentienhq/ultralight-s3/issues");var $e={contents:!0},Te=t=>`%${t.charCodeAt(0).toString(16).toUpperCase()}`,K=t=>encodeURIComponent(t).replace(/[!'()*]/g,Te),y=t=>K(t).replace(/%2F/g,"/"),ne=class{constructor({accessKeyId:t,secretAccessKey:e,endpoint:r,bucketName:s,region:i="auto",maxRequestSizeInBytes:o=5242880,requestAbortTimeout:n=void 0,logger:c=void 0}){this.getBucketName=()=>this.bucketName,this.setBucketName=a=>{this.bucketName=a},this.getRegion=()=>this.region,this.setRegion=a=>{this.region=a},this.getEndpoint=()=>this.endpoint,this.setEndpoint=a=>{this.endpoint=a},this.getMaxRequestSizeInBytes=()=>this.maxRequestSizeInBytes,this.setMaxRequestSizeInBytes=a=>{this.maxRequestSizeInBytes=a},this.sanitizeETag=a=>L(a),this.getProps=()=>({accessKeyId:this.accessKeyId,secretAccessKey:this.secretAccessKey,region:this.region,bucket:this.bucketName,endpoint:this.endpoint,maxRequestSizeInBytes:this.maxRequestSizeInBytes,requestAbortTimeout:this.requestAbortTimeout,logger:this.logger}),this.setProps=a=>{this._validateConstructorParams(a.accessKeyId,a.secretAccessKey,a.bucketName,a.endpoint),this.accessKeyId=a.accessKeyId,this.secretAccessKey=a.secretAccessKey,this.region=a.region||"auto",this.bucketName=a.bucketName,this.endpoint=a.endpoint,this.maxRequestSizeInBytes=a.maxRequestSizeInBytes||5242880,this.requestAbortTimeout=a.requestAbortTimeout,this.logger=a.logger},this._validateConstructorParams(t,e,r,s),this.accessKeyId=t,this.secretAccessKey=e,this.endpoint=r,this.bucketName=s,this.region=i,this.maxRequestSizeInBytes=o,this.requestAbortTimeout=n,this.logger=c}_validateConstructorParams(t,e,r,s){if(typeof t!="string"||t.trim().length===0)throw new TypeError(we);if(typeof e!="string"||e.trim().length===0)throw new TypeError(ye);if(typeof r!="string"||r.trim().length===0)throw new TypeError(me);if(typeof s!="string"||s.trim().length===0)throw new TypeError(Oe)}_checkMethodHeadnGet(t){if(t!=="GET"&&t!=="HEAD")throw this._log("error",`${_}method must be either GET or HEAD`),new Error("method must be either GET or HEAD")}_checkKey(t){if(typeof t!="string"||t.trim().length===0)throw this._log("error",Z),new TypeError(Z)}_checkDelimiter(t){if(typeof t!="string"||t.trim().length===0)throw this._log("error",ie),new TypeError(ie)}_checkPrefix(t){if(typeof t!="string")throw this._log("error",re),new TypeError(re)}_checkMaxKeys(t){if(typeof t!="number"||t<=0)throw this._log("error",se),new TypeError(se)}_checkOpts(t){if(typeof t!="object")throw this._log("error",`${_}opts must be an object`),new TypeError(`${_}opts must be an object`)}_log(t,e,r={}){if(this.logger&&typeof this.logger[t]=="function"){let s=n=>typeof n!="object"||n===null?n:Object.keys(n).reduce((c,a)=>(ge.includes(a.toLowerCase())?c[a]="[REDACTED]":typeof n[a]=="object"&&n[a]!==null?c[a]=s(n[a]):c[a]=n[a],c),Array.isArray(n)?[]:{}),i=s(r),o={timestamp:new Date().toISOString(),level:t,message:e,...i,context:s({bucketName:this.bucketName,region:this.region,endpoint:this.endpoint,accessKeyId:this.accessKeyId?`${this.accessKeyId.substring(0,4)}...`:void 0})};this.logger[t](o)}}async getContentLength(t){this._checkKey(t);let e={[w]:R},r=y(t),{url:s,headers:i}=await this._sign("HEAD",r,{},e,""),o=(await this._sendRequest(s,"HEAD",i)).headers.get(N);return o?parseInt(o,10):0}async bucketExists(){let t={[w]:R},{url:e,headers:r}=await this._sign("HEAD","",{},t,""),s=await this._sendRequest(e,"HEAD",r);return!!(s.ok&&s.status===200)}async fileExists(t,e={}){this._checkKey(t);let{filteredOpts:r,conditionalHeaders:s}=this._filterIfHeaders(e),i={[w]:R,...s},o=y(t),{url:n,headers:c}=await this._sign("HEAD",o,r,i,"");try{let a=await this._sendRequest(n,"HEAD",c,"",[200,404,412,304]);return a.status===404?!1:a.status===412||a.status===304?null:a.ok&&a.status===200?!0:(this._handleErrorResponse(a),!1)}catch(a){let u=a instanceof Error?a.message:String(a);throw this._log("error",`${_}Failed to check if file exists: ${u}`),new Error(`${_}Failed to check if file exists: ${u}`)}}async _sign(t,e,r,s,i){let o=new Date().toISOString().replace(/[:-]|\.\d{3}/g,""),n=typeof e=="string"&&e.length>0?new URL(e,this.endpoint):new URL(this.endpoint);n.pathname=`/${encodeURI(this.bucketName)}${n.pathname}`,s[w]=i?await F(i):R,s[pe]=o,s[Ee]=n.host;let c=this._buildCanonicalHeaders(s),a=Object.keys(s).map($=>$.toLowerCase()).sort().join(";"),u=await this._buildCanonicalRequest(t,n,r,c,a,i),f=await this._buildStringToSign(o,u),g=await this._calculateSignature(o,f),E=this._buildAuthorizationHeader(o,a,g);return s[Re]=E,{url:n.toString(),headers:s}}_buildCanonicalHeaders(t){return Object.entries(t).map(([e,r])=>`${e.toLowerCase()}:${String(r).trim()}`).sort().join(`
`)}async _buildCanonicalRequest(t,e,r,s,i,o){return[t,e.pathname,this._buildCanonicalQueryString(r),`${s}
`,i,o?await F(o):R].join(`
`)}async _buildStringToSign(t,e){let r=[t.slice(0,8),this.region,H,j].join("/");return[Q,t,r,await F(e)].join(`
`)}async _calculateSignature(t,e){let r=await this._getSignatureKey(t.slice(0,8));return U(r,e,"hex")}_buildAuthorizationHeader(t,e,r){let s=[t.slice(0,8),this.region,H,j].join("/");return[`${Q} Credential=${this.accessKeyId}/${s}`,`SignedHeaders=${e}`,`Signature=${r}`].join(", ")}_filterIfHeaders(t){let e={},r={},s=["if-match","if-none-match","if-modified-since","if-unmodified-since"];for(let[i,o]of Object.entries(t))s.includes(i)?r[i]=o:e[i]=o;return{filteredOpts:e,conditionalHeaders:r}}async list(t="/",e="",r=1e3,s="GET",i={}){this._checkDelimiter(t),this._checkPrefix(e),this._checkMaxKeys(r),this._checkMethodHeadnGet(s),this._checkOpts(i),this._log("info",`Listing objects in ${e}`);let o={"list-type":_e,"max-keys":String(r),...i};e.length>0&&(o.prefix=e);let n={[T]:b,[w]:R},c=t==="/"?t:K(t),{url:a,headers:u}=await this._sign("GET",c,o,n,""),f=`${a}?${new URLSearchParams(o)}`,g=await this._sendRequest(f,"GET",u),E=await g.text();if(s==="HEAD"){let S=g.headers.get(N),D=g.headers.get(J),de=g.headers.get(Y);return{size:S?+S:void 0,mtime:D?new Date(D):void 0,ETag:de||void 0}}let $=C(E),M=$.listBucketResult||$.error||$;return M.contents||M}async listMultiPartUploads(t="/",e="",r="GET",s={}){var i,o,n;this._checkDelimiter(t),this._checkPrefix(e),this._checkMethodHeadnGet(r),this._checkOpts(s),this._log("info",`Listing multipart uploads in ${e}`);let c={uploads:"",...s},a={[T]:b,[w]:R},u=t==="/"?t:K(t),{url:f,headers:g}=await this._sign("GET",u,c,a,""),E=`${f}?${new URLSearchParams(c)}`,$=await this._sendRequest(E,"GET",g),M=await $.text();if(r==="HEAD")return{size:+((i=$.headers.get(N))!==null&&i!==void 0?i:"0"),mtime:new Date((o=$.headers.get(J))!==null&&o!==void 0?o:""),ETag:(n=$.headers.get(Y))!==null&&n!==void 0?n:""};let S=C(M),D=S.listMultipartUploadsResult||S.error||S;return D.uploads||D}async get(t,e={}){this._checkKey(t),this._log("info",`Getting object ${t}`);let{filteredOpts:r,conditionalHeaders:s}=this._filterIfHeaders(e),i={[T]:b,[w]:R,...s},o=y(t),{url:n,headers:c}=await this._sign("GET",o,r,i,""),a=await this._sendRequest(n,"GET",c,"",[200,404,412,304]);if(a.status===404||a.status===412||a.status===304)return this._log("error",`Failed to get object. Status: ${a.status}`),null;if(!a.ok)throw this._log("error",`Failed to get object. Status: ${a.status}`),new Error(`Failed to get object. Status: ${a.status}`);return a.text()}async getObjectWithETag(t,e={}){this._checkKey(t),this._log("info",`Getting object ${t}`);let{filteredOpts:r,conditionalHeaders:s}=this._filterIfHeaders(e),i={[T]:b,[w]:R,...s},o=y(t),{url:n,headers:c}=await this._sign("GET",o,r,i,"");try{let a=await this._sendRequest(n,"GET",c,"",[200,404,412,304]);if(a.status===404||a.status===412||a.status===304)return this._log("error",`Failed to get object. Status: ${a.status}`),{etag:null,data:null};if(!a.ok)throw this._log("error",`Failed to get object. Status: ${a.status}`),new Error(`Failed to get object. Status: ${a.status}`);let u=a.headers.get("etag");if(!u)throw new Error("ETag not found in response headers");let f=await a.text();return{etag:L(u),data:f}}catch(a){throw this._log("error",`Error getting object ${t} with ETag: ${a}`),a}}async getEtag(t,e={}){this._checkKey(t),this._log("info",`Getting etag object ${t}`);let{filteredOpts:r,conditionalHeaders:s}=this._filterIfHeaders(e),i={[T]:b,[w]:R,...s},o=y(t),{url:n,headers:c}=await this._sign("HEAD",o,r,i,""),a=await this._sendRequest(n,"HEAD",c,"",[200,412,304]);if(this._log("info",`Response status: ${a.status,a.statusText}`),a.status===412||a.status===304)return null;let u=a.headers.get("etag");if(!u)throw this._log("error","ETag not found in response headers"),new Error("ETag not found in response headers");return L(u)}async getResponse(t,e=!0,r=0,s=this.maxRequestSizeInBytes,i={}){this._checkKey(t);let{filteredOpts:o,conditionalHeaders:n}=this._filterIfHeaders({...i}),c={[T]:b,[w]:R,...e?{}:{range:`bytes=${r}-${s-1}`},...n},a=y(t),{url:u,headers:f}=await this._sign("GET",a,o,c,""),g=`${u}?${new URLSearchParams(o)}`;return this._sendRequest(g,"GET",f)}async put(t,e){if(this._checkKey(t),!(e instanceof Buffer||typeof e=="string"))throw this._log("error",k),new TypeError(k);this._log("info",`Uploading object ${t}`);let r=typeof e=="string"?Buffer.byteLength(e):e.length,s={[N]:r},i=y(t),{url:o,headers:n}=await this._sign("PUT",i,{},s,e);return await this._sendRequest(o,"PUT",n,e)}async getMultipartUploadId(t,e=fe){if(this._checkKey(t),typeof e!="string")throw this._log("error",`${_}fileType must be a string`),new TypeError(`${_}fileType must be a string`);this._log("info",`Initiating multipart upload for object ${t}`);let r={uploads:""},s={[T]:e,[w]:R},i=y(t),{url:o,headers:n}=await this._sign("POST",i,r,s,""),c=`${o}?${new URLSearchParams(r)}`,a=await(await this._sendRequest(c,"POST",n)).text(),u=C(a);if(typeof u=="object"&&u!==null&&"error"in u&&typeof u.error=="object"&&u.error!==null&&"message"in u.error){let f=String(u.error.message);throw this._log("error",`${_}Failed to abort multipart upload: ${f}`),new Error(`${_}Failed to abort multipart upload: ${f}`)}if(typeof u=="object"&&u!==null){if(!u.initiateMultipartUploadResult||!u.initiateMultipartUploadResult.uploadId)throw this._log("error",`${_}Failed to create multipart upload: no uploadId in response`),new Error(`${_}Failed to create multipart upload: Missing upload ID in response`);return u.initiateMultipartUploadResult.uploadId}else throw this._log("error",`${_}Failed to create multipart upload: unexpected response format`),new Error(`${_}Failed to create multipart upload: Unexpected response format`)}async uploadPart(t,e,r,s,i={}){this._validateUploadPartParams(t,e,r,s,i);let o={uploadId:r,partNumber:s,...i},n={[N]:e.length},c=y(t),{url:a,headers:u}=await this._sign("PUT",c,o,n,e),f=`${a}?${new URLSearchParams(o)}`,g=await this._sendRequest(f,"PUT",u,e),E=L(g.headers.get("etag")||"");return{partNumber:s,ETag:E}}_validateUploadPartParams(t,e,r,s,i){if(this._checkKey(t),!(e instanceof Buffer||typeof e=="string"))throw this._log("error",k),new TypeError(k);if(typeof r!="string"||r.trim().length===0)throw this._log("error",x),new TypeError(x);if(!Number.isInteger(s)||s<=0)throw this._log("error",`${_}partNumber must be a positive integer`),new TypeError(`${_}partNumber must be a positive integer`);this._checkOpts(i)}async completeMultipartUpload(t,e,r){if(this._checkKey(t),typeof e!="string"||e.trim().length===0)throw this._log("error",x),new TypeError(x);if(!Array.isArray(r)||r.length===0)throw this._log("error",ee),new TypeError(ee);if(!r.every(E=>typeof E.partNumber=="number"&&typeof E.ETag=="string"))throw this._log("error",te),new TypeError(te);this._log("info",`Complete multipart upload ${e} for object ${t}`);let s={uploadId:e},i=this._buildCompleteMultipartUploadXml(r),o={[T]:X,[N]:Buffer.byteLength(i).toString(),[w]:await F(i)},n=y(t),{url:c,headers:a}=await this._sign("POST",n,s,o,i),u=`${c}?${new URLSearchParams(s)}`,f=await(await this._sendRequest(u,"POST",a,i)).text(),g=C(f);if(typeof g=="object"&&g!==null&&"error"in g&&typeof g.error=="object"&&g.error!==null&&"message"in g.error){let E=String(g.error.message);throw this._log("error",`${_}Failed to abort multipart upload: ${E}`),new Error(`${_}Failed to abort multipart upload: ${E}`)}return g.completeMultipartUploadResult}async abortMultipartUpload(t,e){if(this._checkKey(t),typeof e!="string"||e.trim().length===0)throw this._log("error",x),new TypeError(x);this._log("info",`Aborting multipart upload ${e} for object ${t}`);let r={uploadId:e},s={[T]:X,[w]:R};try{let i=y(t),{url:o,headers:n}=await this._sign("DELETE",i,r,s,""),c=`${o}?${new URLSearchParams(r)}`,a=await this._sendRequest(c,"DELETE",n);if(a.ok){let u=await a.text(),f=C(u);if(typeof f=="object"&&f!==null&&"error"in f&&typeof f.error=="object"&&f.error!==null&&"message"in f.error){let g=String(f.error.message);throw this._log("error",`${_}Failed to abort multipart upload: ${g}`),new Error(`${_}Failed to abort multipart upload: ${g}`)}return{status:"Aborted",key:t,uploadId:e,response:f}}else throw this._log("error",`${_}Abort request failed with status ${a.status}`),new Error(`${_}Abort request failed with status ${a.status}`)}catch(i){let o=i instanceof Error?i.message:String(i);throw this._log("error",`${_}Failed to abort multipart upload for key ${t}: ${o}`),new Error(`${_}Failed to abort multipart upload for key ${t}: ${o}`)}}_buildCompleteMultipartUploadXml(t){return`
      <CompleteMultipartUpload>
        ${t.map(e=>`
          <Part>
            <PartNumber>${e.partNumber}</PartNumber>
            <ETag>${e.ETag}</ETag>
          </Part>
        `).join("")}
      </CompleteMultipartUpload>
    `}async delete(t){this._checkKey(t),this._log("info",`Deleting object ${t}`);let e={[T]:b,[w]:R},r=y(t),{url:s,headers:i}=await this._sign("DELETE",r,{},e,""),o=await this._sendRequest(s,"DELETE",i);return o.status===204||o.status===200}async _sendRequest(t,e,r,s,i=[]){this._log("info",`Sending ${e} request to ${t}, headers: ${JSON.stringify(r)}`);let o=await fetch(t,{method:e,headers:r,body:["GET","HEAD"].includes(e)?void 0:s,signal:this.requestAbortTimeout!==void 0?AbortSignal.timeout(this.requestAbortTimeout):void 0});return!o.ok&&!i.includes(o.status)&&await this._handleErrorResponse(o),o}async _handleErrorResponse(t){let e=await t.text(),r=t.headers.get("x-amz-error-code")||"Unknown",s=t.headers.get("x-amz-error-message")||t.statusText;throw this._log("error",`${_}Request failed with status ${t.status}: ${r} - ${s},err body: ${e}`),new Error(`${_}Request failed with status ${t.status}: ${r} - ${s}, err body: ${e}`)}_buildCanonicalQueryString(t){return Object.keys(t).length<1?"":Object.keys(t).sort().map(e=>`${encodeURIComponent(e)}=${encodeURIComponent(t[e])}`).join("&")}async _getSignatureKey(t){let e=await U(`AWS4${this.secretAccessKey}`,t),r=await U(e,this.region),s=await U(r,H);return U(s,j)}},F=async t=>{let e=oe("sha256");return e.update(t),e.digest("hex")},U=async(t,e,r)=>{let s=ae("sha256",t);return s.update(e),s.digest(r)},L=t=>{let e={'"':"","&quot;":"","&#34;":"","&QUOT;":"","&#x00022":""};return t.replace(/^("|&quot;|&#34;)|("|&quot;|&#34;)$/g,r=>e[r])},C=t=>{let e=o=>o.replace(/&quot;/g,'"').replace(/&apos;/g,"'").replace(/&lt;/g,"<").replace(/&gt;/g,">").replace(/&amp;/g,"&"),r={},s=/<(\w)([-\w]+)(?:\/|[^>]*>((?:(?!<\1)[\s\S])*)<\/\1\2)>/gm,i;for(;i=s.exec(t);){let[,o,n,c]=i,a=o.toLowerCase()+n,u=c!=null?C(c):!0;typeof u=="string"?r[a]=L(e(u)):Array.isArray(r[a])?r[a].push(u):r[a]=r[a]!=null?[r[a],u]:$e[a]?[u]:u}return Object.keys(r).length?r:e(t)};import ue from"avro-js";var l={MISSING_ARGUMENT:"MISSING_ARGUMENT",COLLECTION_EXISTS:"COLLECTION_EXISTS",CREATE_COLLECTION_ERROR:"CREATE_COLLECTION_ERROR",RENAME_COLLECTION_ERROR:"RENAME_COLLECTION_ERROR",REMOVE_COLLECTION_ERROR:"REMOVE_COLLECTION_ERROR",UPDATE_COLLECTION_SCHEMA_ERROR:"UPDATE_COLLECTION_SCHEMA_ERROR",COLLECTION_NOT_FOUND:"COLLECTION_NOT_FOUND",SCHEMA_VALIDATION_ERROR:"SCHEMA_VALIDATION_ERROR",DOCUMENT_VALIDATION_ERROR:"DOCUMENT_VALIDATION_ERROR",S3_OPERATION_ERROR:"S3_OPERATION_ERROR",FIND_ERROR:"FIND_ERROR",FIND_ONE_ERROR:"FIND_ONE_ERROR",SAVE_DATA_ERROR:"SAVE_DATA_ERROR",INSERT_ERROR:"INSERT_ERROR",UPDATE_ERROR:"UPDATE_ERROR",UPDATE_ONE_ERROR:"UPDATE_ONE_ERROR",DELETE_ERROR:"DELETE_ERROR",COUNT_ERROR:"COUNT_ERROR",UNKNOWN_ERROR:"UNKNOWN_ERROR"},d=class extends Error{constructor(e,r=l.UNKNOWN_ERROR){super(`lowstorageError: ${e} :: code: ${r}`),this.name=this.constructor.name,this.code=r,Error.captureStackTrace(this,this.constructor)}};var A=class extends d{constructor(e){super(e,l.SCHEMA_VALIDATION_ERROR)}},I=class extends d{constructor(e){super(e,l.DOCUMENT_VALIDATION_ERROR)}},p=class extends d{constructor(e,r){super(`S3 ${r} operation failed: ${e}`,l.S3_OPERATION_ERROR)}};import{randomUUID as q}from"node:crypto";var v=(t,e)=>Object.keys(e).every(r=>t[r]===e[r]),le=async()=>typeof q<"u"&&typeof q=="function"?q():typeof crypto<"u"&&typeof crypto=="object"&&typeof crypto.randomUUID=="function"?crypto.randomUUID():"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g,function(t){var e=Math.random()*16|0,r=t==="x"?e:e&3|8;return r.toString(16)}),he=(t,e="SubAutoGenerated")=>{switch(typeof t){case"string":return Ae(t)?{type:"string",name:"_id",size:16,logicalType:"UUID"}:"string";case"number":return Number.isInteger(t)?"int":"float";case"boolean":return"boolean";case"object":return t===null?"null":Array.isArray(t)?{type:"array",items:he(t[0])}:G(t,e);default:return"string"}},Ie=t=>{let e={name:"_id",type:"string",size:16,logicalType:"UUID"};return t.type==="record"?t.fields.some(s=>s.name==="_id")||t.fields.unshift(e):t.type==="array"&&t.items.type==="record"&&(t.items.fields.some(s=>s.name==="_id")||t.items.fields.unshift(e)),t},G=(t,e="AutoGenerated")=>{Array.isArray(t)&&(t=t[0]);let r=Object.entries(t).map(([i,o])=>({name:i,type:he(o,`${e}.${i}`)}));return Ie({type:"record",name:e,fields:r})},Ae=t=>/^[0-9A-F]{8}-[0-9A-F]{4}-4[0-9A-F]{3}-[89AB][0-9A-F]{3}-[0-9A-F]{12}$/i.test(t);var h="lowstorage",m="/",B="lowstorage",O=".avro",be=1024*1024,Se=5*be,z=Buffer.from("","utf8"),V=(t=l.DOCUMENT_VALIDATION_ERROR)=>{throw new I(`${h}: Invalid document or schema`,t)},P=t=>{if(t.trim()===""||t===null||typeof t>"u"||t.length>255||t===null)throw new d(`${h}: Collection name is required, null or too long`,l.MISSING_ARGUMENT)},ce=class{constructor(e={accessKeyId:void 0,secretAccessKey:void 0,endpoint:void 0,bucketName:void 0,region:"auto",logger:null,dirPrefix:B}){this._checkArgs(e),this._schemas=new Map,this._s3=new ne(e),this._dirPrefix=e.dirPrefix||B,this._avro=ue}_checkArgs=e=>{let r=["accessKeyId","secretAccessKey","endpoint","bucketName"];for(let s of r)if(!e[s])throw new d(`${h}: ${s} is required`,l.MISSING_ARGUMENT)};async listCollections(){try{let e=await this._s3.list(m,this._dirPrefix);return typeof e=="object"&&e!==null&&e.keyCount==="0"?[]:e.map(r=>r.key.slice(this._dirPrefix.length+1,-O.length))}catch(e){throw new p(`${h}: ${e.message}`,l.S3_OPERATION_ERROR)}}async collectionExists(e){try{P(e);let r=await this._s3.fileExists(`${this._dirPrefix}${m}${e}${O}`);return console.log("collectionExists::2 ",`${this._dirPrefix}${m}${e}${O}`,r),!!r}catch(r){if(r.message.includes("Not Found"))return!1;throw console.log("collectionExists::3 ",e,r),new d(`${h}: ${r.message}`,l.COLLECTION_NOT_FOUND)}}async createCollection(e,r,s=[]){try{if(P(e),!await this.collectionExists(e)){if(s.length>0&&r){let o=this._avro.parse({type:"array",items:r});await this._s3.put(`${this._dirPrefix}${m}${e}${O}`,o.toBuffer(s))}else await this._s3.put(`${this._dirPrefix}${m}${e}${O}`,z);return this.collection(e,r,!1)}throw new d(`${h}: Collection ${e} already exists`,l.COLLECTION_EXISTS)}catch(i){throw i instanceof d?i:new d(`${h}: ${i.message}`,l.CREATE_COLLECTION_ERROR)}}async removeCollection(e){try{P(e);let r=`${this._dirPrefix}${m}${e}${O}`;if(await this.collectionExists(e)){await this._s3.delete(r);let i=await this.collectionExists(e);if(typeof i=="boolean"){if(!i)return this._schemas.delete(e),!0;throw new d(`${h}: Failed to delete collection ${e}`,l.S3_OPERATION_ERROR)}throw new p(`${h}: Failed to delete collection ${e}`,l.S3_OPERATION_ERROR)}throw new d(`${h}: Collection ${e} does not exist`,l.REMOVE_COLLECTION_ERROR)}catch(r){throw r instanceof p?r:new d(`${h}: Failed to remove collection: ${r.message}`,l.REMOVE_COLLECTION_ERROR)}}async collection(e,r,s=!0){try{P(e);let i=`${this._dirPrefix}${m}${e}${O}`;if(!await this._s3.fileExists(i)){if(!s)throw new d(`${h}: Collection ${e} does not exist`,l.COLLECTION_NOT_FOUND);await this._s3.put(i,z)}let n=r||this._schemas.get(e)||void 0;return new W(e,n,this._s3,this._dirPrefix)}catch(i){throw i.message.includes("unknown type")?new A(`${h}: Schema input is invalid: ${i.message}`,l.SCHEMA_VALIDATION_ERROR):new d(`${h}: ${i.message}`,l.COLLECTION_NOT_FOUND)}}s3=()=>this._s3},W=class t{constructor(e,r,s,i=B,o=!1){this._colName=e,this._s3=s,this._avro=ue,this._lastETag="",this._dataCache=[],this._schema=r,this._avroType=typeof r>"u"?null:this._avro.parse(r),this._dirPrefix=i,this._safeWrite=o}getProps=()=>({colName:this._colName,s3:this._s3,avro:this._avro,avroType:this._avroType,dirPrefix:this._dirPrefix,safeWrite:this._safeWrite});setProps=e=>{this._colName=e.colName,this._s3=e.s3,this._avro=e.avro,this._schema=e.schema,this._avroType=e.avroType,this._dirPrefix=e.dirPrefix,this._safeWrite=e.safeWrite};setSafeWrite=e=>{this._safeWrite=e};getSafeWrite=()=>this._safeWrite;getAvroSchema=()=>this._avroType;setAvroSchema=e=>{this._schema=e,this._avroType=typeof e>"u"?null:this._avro.parse(e)};async _loadData(){try{let e=`${this._dirPrefix}${m}${this._colName}${O}`,r=this._s3.getMaxRequestSizeInBytes()||Se;if(this._avroType===null||typeof this._avroType>"u")throw new d(`${h}: Missing type definition. Configure before operations `,l.SCHEMA_VALIDATION_ERROR);console.log("Getting object:",e,this._lastETag);let{etag:s,data:i}=await this._s3.getObjectWithETag(e,{"if-none-match":this._lastETag});if(console.log("data :::::::::::::::::::::::::",i,s,this._dataCache),i===null)return this._dataCache;this._lastETag=s===null?this._lastETag:s;let o=this._avro.parse({type:"array",items:this._avroType});if(i.length<r)return this._dataCache=i.length>0?o.fromBuffer(i):[],this._dataCache;let n=r,c=[Buffer.from(i,"utf8")],a=!0;for(;a;){let f=await this._s3.getResponse(e,!1,n,n+r),g=await f.text();c.push(Buffer.from(g,"utf8")),n+=r,(f.headers.get("content-length")||g.length)<r&&(a=!1)}let u=Buffer.concat(c);return this._dataCache=o.fromBuffer(u),this._dataCache}catch(e){if(e.toString().indexOf("status 404: Unknown - Not Found")>-1)return this._dataCache=[],this._dataCache;throw new p(`${h}: Failed to load data: ${e.message}`,l.S3_OPERATION_ERROR)}}async _saveData(e){try{if(this._avroType===null||typeof this._avroType>"u")throw new d(`${h}: Missing type definition. Configure before operations `,l.SCHEMA_VALIDATION_ERROR);let r=this._avro.parse({type:"array",items:this._avroType}),s=e.length>0?r.toBuffer(e):z,i=`${this._dirPrefix}${m}${this._colName}${O}`;if(this._safeWrite&&this._lastETag!==""){let c=await this._s3.getEtag(i);if(c!==null&&c!==this._lastETag)return!1}let o=await this._s3.put(i,s);if(o.status!==200)throw new p(`${h}: Failed to save data`,l.S3_OPERATION_ERROR);let n=o.headers.get("etag");return n&&(this._lastETag=this._s3.sanitizeETag(n),this._dataCache=e),!0}catch(r){throw r instanceof p?r:new d(`${h}: ${r.message}`,l.SAVE_DATA_ERROR)}}async insert(e,r=void 0){try{if(e==null)throw new d(`${h}: Document is required for insert`,l.INSERT_ERROR);if(typeof e!="object"&&!Array.isArray(e))throw new I(`${h}: Document must be an object or an array`,l.DOCUMENT_VALIDATION_ERROR);let s=Array.isArray(e)?e:[e],i=r||this._avroType||G(s[0]),o=this._avro.parse(i);if(!o)throw new A(`${h}: Schema is required - Pass a schema to the insert method`,l.SCHEMA_VALIDATION_ERROR);this._avroType=o;let n=await this._loadData();for(let a of s){if(typeof a!="object"||a===null)throw new I(`${h}: Invalid input: input must be an object or an array of objects`,l.DOCUMENT_VALIDATION_ERROR);if(a._id=a._id||await le(),this._avroType.isValid(a,{errorHook:V,noUndeclaredFields:!0})===!0)n.push(a);else throw new I(`${h}: Invalid document or schema`,l.DOCUMENT_VALIDATION_ERROR)}if(!await this._saveData(n))throw new p(`${h}: Failed to insert document`,l.S3_OPERATION_ERROR);return s}catch(s){throw s.message.includes("unknown type")?new A(`${h}: Schema input is invalid: ${s.message}`,l.SCHEMA_VALIDATION_ERROR):s instanceof d?s:new d(`${h} Insert operation failed: ${s.message}`,l.INSERT_ERROR)}}async find(e={},r={}){try{if(e==null)throw new d(`${h}: Query is required for update`,l.MISSING_ARGUMENT);let s=await this._loadData(),i=parseInt(r.skip,10)||0,o=parseInt(r.limit,10)?i+parseInt(r.limit,10):void 0;return s.filter(c=>v(c,e)).slice(i,o)}catch(s){throw new d(`${h}: Find operation failed: ${s.message}`,l.FIND_ERROR)}}async findOne(e={}){try{if(e===null)throw new d(`${h}: Query cannot be null`,l.INVALID_ARGUMENT);return(await this.find(e,{limit:1}))[0]||null}catch(r){throw r instanceof d?r:new d(`${h}: FindOne operation failed: ${r.message}`,l.FIND_ONE_ERROR)}}async update(e={},r={},s={}){try{if(e==null||r===void 0||r===null)throw new d(`${h}: Query and update values are required for update`,l.MISSING_ARGUMENT);if(!this._avroType)throw new A(`${h}: Schema is not defined for this collection`,l.SCHEMA_VALIDATION_ERROR);let i=await this._loadData();if(i.length===0)return 0;let o=0;for(let n=0;n<i.length;n++)if(v(i[n],e)){let c={...i[n],...r};if(this._avroType.isValid(c,{errorHook:V,noUndeclaredFields:!0})===!0)i[n]=c,o++;else throw new I(`${h}: Invalid document or schema`,l.DOCUMENT_VALIDATION_ERROR)}if(o>0){if(!await this._saveData(i))throw new p(`${h}: Failed to update document`,l.S3_OPERATION_ERROR)}else if(s.upsert){if(!await this.insert(r))throw new p(`${h}: Failed to update document`,l.S3_OPERATION_ERROR);o=1}return o}catch(i){throw i instanceof p?i:new d(`${h}: Update operation failed: ${i.message}`,l.UPDATE_ERROR)}}async updateOne(e={},r={},s={}){try{if(e==null||r===void 0||r===null)throw new d(`${h}: Query is required`,l.MISSING_ARGUMENT);if(!this._avroType)throw new A(`${h}: Schema is not defined for this collection`,l.SCHEMA_VALIDATION_ERROR);let i=await this._loadData();if(i.length===0)return 0;let o=i.findIndex(n=>v(n,e));if(o!==-1){let n={...i[o],...r};if(this._avroType.isValid(n,{errorHook:V,noUndeclaredFields:!0})===!0){if(i[o]=n,!await this._saveData(i))throw new p(`${h}: Failed to update document`,l.S3_OPERATION_ERROR);return 1}else throw new I(`${h}: Invalid document or schema`,l.DOCUMENT_VALIDATION_ERROR)}if(s.upsert){if(!await this.insert(r))throw new p(`${h}: Failed to update document`,l.S3_OPERATION_ERROR);return 1}return 0}catch(i){throw i instanceof d?i:new d(`${h}: UpdateOne operation failed: ${i.message}`,l.UPDATE_ONE_ERROR)}}async delete(e={}){try{if(e==null)throw new d(`${h}: Query is required`,l.MISSING_ARGUMENT);let r=await this._loadData();if(r.length===0)return 0;let s=r.length,i=r.filter(n=>!v(n,e));if(!await this._saveData(i))throw new p(`${h}: Failed to delete document`,l.S3_OPERATION_ERROR);return s-i.length}catch(r){throw r instanceof p?r:new d(`${h}: Delete operation failed: ${r.message}`,l.DELETE_ERROR)}}async deleteAll(){try{let r=(await this._loadData()).length;if(!await this._saveData([]))throw new p(`${h}: Failed to delete document`,l.S3_OPERATION_ERROR);return r}catch(e){throw e instanceof p?e:new d(`${h}: Delete operation failed: ${e.message}`,l.DELETE_ERROR)}}async count(e={}){try{return(await this.find(e)).length}catch(r){throw new d(`${h}: Count operation failed: ${r.message}`,l.COUNT_ERROR)}}async renameCollection(e,r=this._schema){try{if(P(e),await this._s3.fileExists(`${this._dirPrefix}${m}${e}${O}`))throw new d(`${h}: Collection ${e} already exists`,l.COLLECTION_EXISTS);let i=r||this.getAvroSchema(),o=await this._loadData(),n=new t(e,i,this._s3,this._dirPrefix);return await n._saveData(o),await this._s3.delete(`${this._dirPrefix}${m}${this._colName}${O}`),n}catch(s){throw s instanceof d?s:new d(`${h}: Rename collection failed: ${s.message}`,l.RENAME_COLLECTION_ERROR)}}};export{ce as lowstorage,d as lowstorageError,l as lowstorage_ERROR_CODES};
//# sourceMappingURL=lowstorage.js.map
