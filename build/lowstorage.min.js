// <stdin>
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var require_index_no_eval = __commonJS({
  "node_modules/msgpackr/dist/index-no-eval.cjs"(exports, module) {
    (function(global, factory) {
      typeof exports === "object" && typeof module !== "undefined" ? factory(exports) : typeof define === "function" && define.amd ? define(["exports"], factory) : (global = typeof globalThis !== "undefined" ? globalThis : global || self, factory(global.msgpackr = {}));
    })(exports, function(exports2) {
      "use strict";
      var decoder;
      try {
        decoder = new TextDecoder();
      } catch (error) {
      }
      var src;
      var srcEnd;
      var position$1 = 0;
      var currentUnpackr = {};
      var currentStructures;
      var srcString;
      var srcStringStart = 0;
      var srcStringEnd = 0;
      var bundledStrings$1;
      var referenceMap;
      var currentExtensions = [];
      var dataView;
      var defaultOptions = {
        useRecords: false,
        mapsAsObjects: true
      };
      class C1Type {
      }
      const C1 = new C1Type();
      C1.name = "MessagePack 0xC1";
      var sequentialMode = false;
      var inlineObjectReadThreshold = 2;
      var readStruct;
      var BlockedFunction;
      try {
        new BlockedFunction("");
      } catch (error) {
        inlineObjectReadThreshold = Infinity;
      }
      class Unpackr {
        constructor(options) {
          if (options) {
            if (options.useRecords === false && options.mapsAsObjects === void 0)
              options.mapsAsObjects = true;
            if (options.sequential && options.trusted !== false) {
              options.trusted = true;
              if (!options.structures && options.useRecords != false) {
                options.structures = [];
                if (!options.maxSharedStructures)
                  options.maxSharedStructures = 0;
              }
            }
            if (options.structures)
              options.structures.sharedLength = options.structures.length;
            else if (options.getStructures) {
              (options.structures = []).uninitialized = true;
              options.structures.sharedLength = 0;
            }
            if (options.int64AsNumber) {
              options.int64AsType = "number";
            }
          }
          Object.assign(this, options);
        }
        unpack(source, options) {
          if (src) {
            return saveState(() => {
              clearSource();
              return this ? this.unpack(source, options) : Unpackr.prototype.unpack.call(defaultOptions, source, options);
            });
          }
          if (!source.buffer && source.constructor === ArrayBuffer)
            source = typeof Buffer !== "undefined" ? Buffer.from(source) : new Uint8Array(source);
          if (typeof options === "object") {
            srcEnd = options.end || source.length;
            position$1 = options.start || 0;
          } else {
            position$1 = 0;
            srcEnd = options > -1 ? options : source.length;
          }
          srcStringEnd = 0;
          srcString = null;
          bundledStrings$1 = null;
          src = source;
          try {
            dataView = source.dataView || (source.dataView = new DataView(source.buffer, source.byteOffset, source.byteLength));
          } catch (error) {
            src = null;
            if (source instanceof Uint8Array)
              throw error;
            throw new Error("Source must be a Uint8Array or Buffer but was a " + (source && typeof source == "object" ? source.constructor.name : typeof source));
          }
          if (this instanceof Unpackr) {
            currentUnpackr = this;
            if (this.structures) {
              currentStructures = this.structures;
              return checkedRead(options);
            } else if (!currentStructures || currentStructures.length > 0) {
              currentStructures = [];
            }
          } else {
            currentUnpackr = defaultOptions;
            if (!currentStructures || currentStructures.length > 0)
              currentStructures = [];
          }
          return checkedRead(options);
        }
        unpackMultiple(source, forEach) {
          let values, lastPosition = 0;
          try {
            sequentialMode = true;
            let size = source.length;
            let value = this ? this.unpack(source, size) : defaultUnpackr.unpack(source, size);
            if (forEach) {
              if (forEach(value, lastPosition, position$1) === false) return;
              while (position$1 < size) {
                lastPosition = position$1;
                if (forEach(checkedRead(), lastPosition, position$1) === false) {
                  return;
                }
              }
            } else {
              values = [value];
              while (position$1 < size) {
                lastPosition = position$1;
                values.push(checkedRead());
              }
              return values;
            }
          } catch (error) {
            error.lastPosition = lastPosition;
            error.values = values;
            throw error;
          } finally {
            sequentialMode = false;
            clearSource();
          }
        }
        _mergeStructures(loadedStructures, existingStructures) {
          loadedStructures = loadedStructures || [];
          if (Object.isFrozen(loadedStructures))
            loadedStructures = loadedStructures.map((structure) => structure.slice(0));
          for (let i = 0, l = loadedStructures.length; i < l; i++) {
            let structure = loadedStructures[i];
            if (structure) {
              structure.isShared = true;
              if (i >= 32)
                structure.highByte = i - 32 >> 5;
            }
          }
          loadedStructures.sharedLength = loadedStructures.length;
          for (let id in existingStructures || []) {
            if (id >= 0) {
              let structure = loadedStructures[id];
              let existing = existingStructures[id];
              if (existing) {
                if (structure)
                  (loadedStructures.restoreStructures || (loadedStructures.restoreStructures = []))[id] = structure;
                loadedStructures[id] = existing;
              }
            }
          }
          return this.structures = loadedStructures;
        }
        decode(source, options) {
          return this.unpack(source, options);
        }
      }
      function checkedRead(options) {
        try {
          if (!currentUnpackr.trusted && !sequentialMode) {
            let sharedLength = currentStructures.sharedLength || 0;
            if (sharedLength < currentStructures.length)
              currentStructures.length = sharedLength;
          }
          let result;
          if (currentUnpackr.randomAccessStructure && src[position$1] < 64 && src[position$1] >= 32 && readStruct) {
            result = readStruct(src, position$1, srcEnd, currentUnpackr);
            src = null;
            if (!(options && options.lazy) && result)
              result = result.toJSON();
            position$1 = srcEnd;
          } else
            result = read();
          if (bundledStrings$1) {
            position$1 = bundledStrings$1.postBundlePosition;
            bundledStrings$1 = null;
          }
          if (sequentialMode)
            currentStructures.restoreStructures = null;
          if (position$1 == srcEnd) {
            if (currentStructures && currentStructures.restoreStructures)
              restoreStructures();
            currentStructures = null;
            src = null;
            if (referenceMap)
              referenceMap = null;
          } else if (position$1 > srcEnd) {
            throw new Error("Unexpected end of MessagePack data");
          } else if (!sequentialMode) {
            let jsonView;
            try {
              jsonView = JSON.stringify(result, (_2, value) => typeof value === "bigint" ? `${value}n` : value).slice(0, 100);
            } catch (error) {
              jsonView = "(JSON view not available " + error + ")";
            }
            throw new Error("Data read, but end of buffer not reached " + jsonView);
          }
          return result;
        } catch (error) {
          if (currentStructures && currentStructures.restoreStructures)
            restoreStructures();
          clearSource();
          if (error instanceof RangeError || error.message.startsWith("Unexpected end of buffer") || position$1 > srcEnd) {
            error.incomplete = true;
          }
          throw error;
        }
      }
      function restoreStructures() {
        for (let id in currentStructures.restoreStructures) {
          currentStructures[id] = currentStructures.restoreStructures[id];
        }
        currentStructures.restoreStructures = null;
      }
      function read() {
        let token = src[position$1++];
        if (token < 160) {
          if (token < 128) {
            if (token < 64)
              return token;
            else {
              let structure = currentStructures[token & 63] || currentUnpackr.getStructures && loadStructures()[token & 63];
              if (structure) {
                if (!structure.read) {
                  structure.read = createStructureReader(structure, token & 63);
                }
                return structure.read();
              } else
                return token;
            }
          } else if (token < 144) {
            token -= 128;
            if (currentUnpackr.mapsAsObjects) {
              let object = {};
              for (let i = 0; i < token; i++) {
                let key = readKey();
                if (key === "__proto__")
                  key = "__proto_";
                object[key] = read();
              }
              return object;
            } else {
              let map = /* @__PURE__ */ new Map();
              for (let i = 0; i < token; i++) {
                map.set(read(), read());
              }
              return map;
            }
          } else {
            token -= 144;
            let array = new Array(token);
            for (let i = 0; i < token; i++) {
              array[i] = read();
            }
            if (currentUnpackr.freezeData)
              return Object.freeze(array);
            return array;
          }
        } else if (token < 192) {
          let length = token - 160;
          if (srcStringEnd >= position$1) {
            return srcString.slice(position$1 - srcStringStart, (position$1 += length) - srcStringStart);
          }
          if (srcStringEnd == 0 && srcEnd < 140) {
            let string = length < 16 ? shortStringInJS(length) : longStringInJS(length);
            if (string != null)
              return string;
          }
          return readFixedString(length);
        } else {
          let value;
          switch (token) {
            case 192:
              return null;
            case 193:
              if (bundledStrings$1) {
                value = read();
                if (value > 0)
                  return bundledStrings$1[1].slice(bundledStrings$1.position1, bundledStrings$1.position1 += value);
                else
                  return bundledStrings$1[0].slice(bundledStrings$1.position0, bundledStrings$1.position0 -= value);
              }
              return C1;
            // "never-used", return special object to denote that
            case 194:
              return false;
            case 195:
              return true;
            case 196:
              value = src[position$1++];
              if (value === void 0)
                throw new Error("Unexpected end of buffer");
              return readBin(value);
            case 197:
              value = dataView.getUint16(position$1);
              position$1 += 2;
              return readBin(value);
            case 198:
              value = dataView.getUint32(position$1);
              position$1 += 4;
              return readBin(value);
            case 199:
              return readExt(src[position$1++]);
            case 200:
              value = dataView.getUint16(position$1);
              position$1 += 2;
              return readExt(value);
            case 201:
              value = dataView.getUint32(position$1);
              position$1 += 4;
              return readExt(value);
            case 202:
              value = dataView.getFloat32(position$1);
              if (currentUnpackr.useFloat32 > 2) {
                let multiplier = mult10[(src[position$1] & 127) << 1 | src[position$1 + 1] >> 7];
                position$1 += 4;
                return (multiplier * value + (value > 0 ? 0.5 : -0.5) >> 0) / multiplier;
              }
              position$1 += 4;
              return value;
            case 203:
              value = dataView.getFloat64(position$1);
              position$1 += 8;
              return value;
            // uint handlers
            case 204:
              return src[position$1++];
            case 205:
              value = dataView.getUint16(position$1);
              position$1 += 2;
              return value;
            case 206:
              value = dataView.getUint32(position$1);
              position$1 += 4;
              return value;
            case 207:
              if (currentUnpackr.int64AsType === "number") {
                value = dataView.getUint32(position$1) * 4294967296;
                value += dataView.getUint32(position$1 + 4);
              } else if (currentUnpackr.int64AsType === "string") {
                value = dataView.getBigUint64(position$1).toString();
              } else if (currentUnpackr.int64AsType === "auto") {
                value = dataView.getBigUint64(position$1);
                if (value <= BigInt(2) << BigInt(52)) value = Number(value);
              } else
                value = dataView.getBigUint64(position$1);
              position$1 += 8;
              return value;
            // int handlers
            case 208:
              return dataView.getInt8(position$1++);
            case 209:
              value = dataView.getInt16(position$1);
              position$1 += 2;
              return value;
            case 210:
              value = dataView.getInt32(position$1);
              position$1 += 4;
              return value;
            case 211:
              if (currentUnpackr.int64AsType === "number") {
                value = dataView.getInt32(position$1) * 4294967296;
                value += dataView.getUint32(position$1 + 4);
              } else if (currentUnpackr.int64AsType === "string") {
                value = dataView.getBigInt64(position$1).toString();
              } else if (currentUnpackr.int64AsType === "auto") {
                value = dataView.getBigInt64(position$1);
                if (value >= BigInt(-2) << BigInt(52) && value <= BigInt(2) << BigInt(52)) value = Number(value);
              } else
                value = dataView.getBigInt64(position$1);
              position$1 += 8;
              return value;
            case 212:
              value = src[position$1++];
              if (value == 114) {
                return recordDefinition(src[position$1++] & 63);
              } else {
                let extension = currentExtensions[value];
                if (extension) {
                  if (extension.read) {
                    position$1++;
                    return extension.read(read());
                  } else if (extension.noBuffer) {
                    position$1++;
                    return extension();
                  } else
                    return extension(src.subarray(position$1, ++position$1));
                } else
                  throw new Error("Unknown extension " + value);
              }
            case 213:
              value = src[position$1];
              if (value == 114) {
                position$1++;
                return recordDefinition(src[position$1++] & 63, src[position$1++]);
              } else
                return readExt(2);
            case 214:
              return readExt(4);
            case 215:
              return readExt(8);
            case 216:
              return readExt(16);
            case 217:
              value = src[position$1++];
              if (srcStringEnd >= position$1) {
                return srcString.slice(position$1 - srcStringStart, (position$1 += value) - srcStringStart);
              }
              return readString8(value);
            case 218:
              value = dataView.getUint16(position$1);
              position$1 += 2;
              if (srcStringEnd >= position$1) {
                return srcString.slice(position$1 - srcStringStart, (position$1 += value) - srcStringStart);
              }
              return readString16(value);
            case 219:
              value = dataView.getUint32(position$1);
              position$1 += 4;
              if (srcStringEnd >= position$1) {
                return srcString.slice(position$1 - srcStringStart, (position$1 += value) - srcStringStart);
              }
              return readString32(value);
            case 220:
              value = dataView.getUint16(position$1);
              position$1 += 2;
              return readArray(value);
            case 221:
              value = dataView.getUint32(position$1);
              position$1 += 4;
              return readArray(value);
            case 222:
              value = dataView.getUint16(position$1);
              position$1 += 2;
              return readMap(value);
            case 223:
              value = dataView.getUint32(position$1);
              position$1 += 4;
              return readMap(value);
            default:
              if (token >= 224)
                return token - 256;
              if (token === void 0) {
                let error = new Error("Unexpected end of MessagePack data");
                error.incomplete = true;
                throw error;
              }
              throw new Error("Unknown MessagePack token " + token);
          }
        }
      }
      const validName = /^[a-zA-Z_$][a-zA-Z\d_$]*$/;
      function createStructureReader(structure, firstId) {
        function readObject() {
          if (readObject.count++ > inlineObjectReadThreshold) {
            let readObject2 = structure.read = new BlockedFunction("r", "return function(){return " + (currentUnpackr.freezeData ? "Object.freeze" : "") + "({" + structure.map((key) => key === "__proto__" ? "__proto_:r()" : validName.test(key) ? key + ":r()" : "[" + JSON.stringify(key) + "]:r()").join(",") + "})}")(read);
            if (structure.highByte === 0)
              structure.read = createSecondByteReader(firstId, structure.read);
            return readObject2();
          }
          let object = {};
          for (let i = 0, l = structure.length; i < l; i++) {
            let key = structure[i];
            if (key === "__proto__")
              key = "__proto_";
            object[key] = read();
          }
          if (currentUnpackr.freezeData)
            return Object.freeze(object);
          return object;
        }
        readObject.count = 0;
        if (structure.highByte === 0) {
          return createSecondByteReader(firstId, readObject);
        }
        return readObject;
      }
      const createSecondByteReader = (firstId, read0) => {
        return function() {
          let highByte = src[position$1++];
          if (highByte === 0)
            return read0();
          let id = firstId < 32 ? -(firstId + (highByte << 5)) : firstId + (highByte << 5);
          let structure = currentStructures[id] || loadStructures()[id];
          if (!structure) {
            throw new Error("Record id is not defined for " + id);
          }
          if (!structure.read)
            structure.read = createStructureReader(structure, firstId);
          return structure.read();
        };
      };
      function loadStructures() {
        let loadedStructures = saveState(() => {
          src = null;
          return currentUnpackr.getStructures();
        });
        return currentStructures = currentUnpackr._mergeStructures(loadedStructures, currentStructures);
      }
      var readFixedString = readStringJS;
      var readString8 = readStringJS;
      var readString16 = readStringJS;
      var readString32 = readStringJS;
      let isNativeAccelerationEnabled = false;
      function readStringJS(length) {
        let result;
        if (length < 16) {
          if (result = shortStringInJS(length))
            return result;
        }
        if (length > 64 && decoder)
          return decoder.decode(src.subarray(position$1, position$1 += length));
        const end = position$1 + length;
        const units = [];
        result = "";
        while (position$1 < end) {
          const byte1 = src[position$1++];
          if ((byte1 & 128) === 0) {
            units.push(byte1);
          } else if ((byte1 & 224) === 192) {
            const byte2 = src[position$1++] & 63;
            units.push((byte1 & 31) << 6 | byte2);
          } else if ((byte1 & 240) === 224) {
            const byte2 = src[position$1++] & 63;
            const byte3 = src[position$1++] & 63;
            units.push((byte1 & 31) << 12 | byte2 << 6 | byte3);
          } else if ((byte1 & 248) === 240) {
            const byte2 = src[position$1++] & 63;
            const byte3 = src[position$1++] & 63;
            const byte4 = src[position$1++] & 63;
            let unit = (byte1 & 7) << 18 | byte2 << 12 | byte3 << 6 | byte4;
            if (unit > 65535) {
              unit -= 65536;
              units.push(unit >>> 10 & 1023 | 55296);
              unit = 56320 | unit & 1023;
            }
            units.push(unit);
          } else {
            units.push(byte1);
          }
          if (units.length >= 4096) {
            result += fromCharCode.apply(String, units);
            units.length = 0;
          }
        }
        if (units.length > 0) {
          result += fromCharCode.apply(String, units);
        }
        return result;
      }
      function readArray(length) {
        let array = new Array(length);
        for (let i = 0; i < length; i++) {
          array[i] = read();
        }
        if (currentUnpackr.freezeData)
          return Object.freeze(array);
        return array;
      }
      function readMap(length) {
        if (currentUnpackr.mapsAsObjects) {
          let object = {};
          for (let i = 0; i < length; i++) {
            let key = readKey();
            if (key === "__proto__")
              key = "__proto_";
            object[key] = read();
          }
          return object;
        } else {
          let map = /* @__PURE__ */ new Map();
          for (let i = 0; i < length; i++) {
            map.set(read(), read());
          }
          return map;
        }
      }
      var fromCharCode = String.fromCharCode;
      function longStringInJS(length) {
        let start = position$1;
        let bytes = new Array(length);
        for (let i = 0; i < length; i++) {
          const byte = src[position$1++];
          if ((byte & 128) > 0) {
            position$1 = start;
            return;
          }
          bytes[i] = byte;
        }
        return fromCharCode.apply(String, bytes);
      }
      function shortStringInJS(length) {
        if (length < 4) {
          if (length < 2) {
            if (length === 0)
              return "";
            else {
              let a = src[position$1++];
              if ((a & 128) > 1) {
                position$1 -= 1;
                return;
              }
              return fromCharCode(a);
            }
          } else {
            let a = src[position$1++];
            let b2 = src[position$1++];
            if ((a & 128) > 0 || (b2 & 128) > 0) {
              position$1 -= 2;
              return;
            }
            if (length < 3)
              return fromCharCode(a, b2);
            let c = src[position$1++];
            if ((c & 128) > 0) {
              position$1 -= 3;
              return;
            }
            return fromCharCode(a, b2, c);
          }
        } else {
          let a = src[position$1++];
          let b2 = src[position$1++];
          let c = src[position$1++];
          let d = src[position$1++];
          if ((a & 128) > 0 || (b2 & 128) > 0 || (c & 128) > 0 || (d & 128) > 0) {
            position$1 -= 4;
            return;
          }
          if (length < 6) {
            if (length === 4)
              return fromCharCode(a, b2, c, d);
            else {
              let e = src[position$1++];
              if ((e & 128) > 0) {
                position$1 -= 5;
                return;
              }
              return fromCharCode(a, b2, c, d, e);
            }
          } else if (length < 8) {
            let e = src[position$1++];
            let f2 = src[position$1++];
            if ((e & 128) > 0 || (f2 & 128) > 0) {
              position$1 -= 6;
              return;
            }
            if (length < 7)
              return fromCharCode(a, b2, c, d, e, f2);
            let g = src[position$1++];
            if ((g & 128) > 0) {
              position$1 -= 7;
              return;
            }
            return fromCharCode(a, b2, c, d, e, f2, g);
          } else {
            let e = src[position$1++];
            let f2 = src[position$1++];
            let g = src[position$1++];
            let h2 = src[position$1++];
            if ((e & 128) > 0 || (f2 & 128) > 0 || (g & 128) > 0 || (h2 & 128) > 0) {
              position$1 -= 8;
              return;
            }
            if (length < 10) {
              if (length === 8)
                return fromCharCode(a, b2, c, d, e, f2, g, h2);
              else {
                let i = src[position$1++];
                if ((i & 128) > 0) {
                  position$1 -= 9;
                  return;
                }
                return fromCharCode(a, b2, c, d, e, f2, g, h2, i);
              }
            } else if (length < 12) {
              let i = src[position$1++];
              let j2 = src[position$1++];
              if ((i & 128) > 0 || (j2 & 128) > 0) {
                position$1 -= 10;
                return;
              }
              if (length < 11)
                return fromCharCode(a, b2, c, d, e, f2, g, h2, i, j2);
              let k2 = src[position$1++];
              if ((k2 & 128) > 0) {
                position$1 -= 11;
                return;
              }
              return fromCharCode(a, b2, c, d, e, f2, g, h2, i, j2, k2);
            } else {
              let i = src[position$1++];
              let j2 = src[position$1++];
              let k2 = src[position$1++];
              let l = src[position$1++];
              if ((i & 128) > 0 || (j2 & 128) > 0 || (k2 & 128) > 0 || (l & 128) > 0) {
                position$1 -= 12;
                return;
              }
              if (length < 14) {
                if (length === 12)
                  return fromCharCode(a, b2, c, d, e, f2, g, h2, i, j2, k2, l);
                else {
                  let m2 = src[position$1++];
                  if ((m2 & 128) > 0) {
                    position$1 -= 13;
                    return;
                  }
                  return fromCharCode(a, b2, c, d, e, f2, g, h2, i, j2, k2, l, m2);
                }
              } else {
                let m2 = src[position$1++];
                let n = src[position$1++];
                if ((m2 & 128) > 0 || (n & 128) > 0) {
                  position$1 -= 14;
                  return;
                }
                if (length < 15)
                  return fromCharCode(a, b2, c, d, e, f2, g, h2, i, j2, k2, l, m2, n);
                let o = src[position$1++];
                if ((o & 128) > 0) {
                  position$1 -= 15;
                  return;
                }
                return fromCharCode(a, b2, c, d, e, f2, g, h2, i, j2, k2, l, m2, n, o);
              }
            }
          }
        }
      }
      function readOnlyJSString() {
        let token = src[position$1++];
        let length;
        if (token < 192) {
          length = token - 160;
        } else {
          switch (token) {
            case 217:
              length = src[position$1++];
              break;
            case 218:
              length = dataView.getUint16(position$1);
              position$1 += 2;
              break;
            case 219:
              length = dataView.getUint32(position$1);
              position$1 += 4;
              break;
            default:
              throw new Error("Expected string");
          }
        }
        return readStringJS(length);
      }
      function readBin(length) {
        return currentUnpackr.copyBuffers ? (
          // specifically use the copying slice (not the node one)
          Uint8Array.prototype.slice.call(src, position$1, position$1 += length)
        ) : src.subarray(position$1, position$1 += length);
      }
      function readExt(length) {
        let type = src[position$1++];
        if (currentExtensions[type]) {
          let end;
          return currentExtensions[type](src.subarray(position$1, end = position$1 += length), (readPosition) => {
            position$1 = readPosition;
            try {
              return read();
            } finally {
              position$1 = end;
            }
          });
        } else
          throw new Error("Unknown extension type " + type);
      }
      var keyCache = new Array(4096);
      function readKey() {
        let length = src[position$1++];
        if (length >= 160 && length < 192) {
          length = length - 160;
          if (srcStringEnd >= position$1)
            return srcString.slice(position$1 - srcStringStart, (position$1 += length) - srcStringStart);
          else if (!(srcStringEnd == 0 && srcEnd < 180))
            return readFixedString(length);
        } else {
          position$1--;
          return asSafeString(read());
        }
        let key = (length << 5 ^ (length > 1 ? dataView.getUint16(position$1) : length > 0 ? src[position$1] : 0)) & 4095;
        let entry = keyCache[key];
        let checkPosition = position$1;
        let end = position$1 + length - 3;
        let chunk;
        let i = 0;
        if (entry && entry.bytes == length) {
          while (checkPosition < end) {
            chunk = dataView.getUint32(checkPosition);
            if (chunk != entry[i++]) {
              checkPosition = 1879048192;
              break;
            }
            checkPosition += 4;
          }
          end += 3;
          while (checkPosition < end) {
            chunk = src[checkPosition++];
            if (chunk != entry[i++]) {
              checkPosition = 1879048192;
              break;
            }
          }
          if (checkPosition === end) {
            position$1 = checkPosition;
            return entry.string;
          }
          end -= 3;
          checkPosition = position$1;
        }
        entry = [];
        keyCache[key] = entry;
        entry.bytes = length;
        while (checkPosition < end) {
          chunk = dataView.getUint32(checkPosition);
          entry.push(chunk);
          checkPosition += 4;
        }
        end += 3;
        while (checkPosition < end) {
          chunk = src[checkPosition++];
          entry.push(chunk);
        }
        let string = length < 16 ? shortStringInJS(length) : longStringInJS(length);
        if (string != null)
          return entry.string = string;
        return entry.string = readFixedString(length);
      }
      function asSafeString(property) {
        if (typeof property === "string") return property;
        if (typeof property === "number" || typeof property === "boolean" || typeof property === "bigint") return property.toString();
        if (property == null) return property + "";
        throw new Error("Invalid property type for record", typeof property);
      }
      const recordDefinition = (id, highByte) => {
        let structure = read().map(asSafeString);
        let firstByte = id;
        if (highByte !== void 0) {
          id = id < 32 ? -((highByte << 5) + id) : (highByte << 5) + id;
          structure.highByte = highByte;
        }
        let existingStructure = currentStructures[id];
        if (existingStructure && (existingStructure.isShared || sequentialMode)) {
          (currentStructures.restoreStructures || (currentStructures.restoreStructures = []))[id] = existingStructure;
        }
        currentStructures[id] = structure;
        structure.read = createStructureReader(structure, firstByte);
        return structure.read();
      };
      currentExtensions[0] = () => {
      };
      currentExtensions[0].noBuffer = true;
      currentExtensions[66] = (data) => {
        let length = data.length;
        let value = BigInt(data[0] & 128 ? data[0] - 256 : data[0]);
        for (let i = 1; i < length; i++) {
          value <<= BigInt(8);
          value += BigInt(data[i]);
        }
        return value;
      };
      let errors = { Error, TypeError, ReferenceError };
      currentExtensions[101] = () => {
        let data = read();
        return (errors[data[0]] || Error)(data[1], { cause: data[2] });
      };
      currentExtensions[105] = (data) => {
        if (currentUnpackr.structuredClone === false) throw new Error("Structured clone extension is disabled");
        let id = dataView.getUint32(position$1 - 4);
        if (!referenceMap)
          referenceMap = /* @__PURE__ */ new Map();
        let token = src[position$1];
        let target2;
        if (token >= 144 && token < 160 || token == 220 || token == 221)
          target2 = [];
        else
          target2 = {};
        let refEntry = { target: target2 };
        referenceMap.set(id, refEntry);
        let targetProperties = read();
        if (refEntry.used)
          return Object.assign(target2, targetProperties);
        refEntry.target = targetProperties;
        return targetProperties;
      };
      currentExtensions[112] = (data) => {
        if (currentUnpackr.structuredClone === false) throw new Error("Structured clone extension is disabled");
        let id = dataView.getUint32(position$1 - 4);
        let refEntry = referenceMap.get(id);
        refEntry.used = true;
        return refEntry.target;
      };
      currentExtensions[115] = () => new Set(read());
      const typedArrays = ["Int8", "Uint8", "Uint8Clamped", "Int16", "Uint16", "Int32", "Uint32", "Float32", "Float64", "BigInt64", "BigUint64"].map((type) => type + "Array");
      let glbl = typeof globalThis === "object" ? globalThis : window;
      currentExtensions[116] = (data) => {
        let typeCode = data[0];
        let typedArrayName = typedArrays[typeCode];
        if (!typedArrayName) {
          if (typeCode === 16) {
            let ab = new ArrayBuffer(data.length - 1);
            let u8 = new Uint8Array(ab);
            u8.set(data.subarray(1));
            return ab;
          }
          throw new Error("Could not find typed array for code " + typeCode);
        }
        return new glbl[typedArrayName](Uint8Array.prototype.slice.call(data, 1).buffer);
      };
      currentExtensions[120] = () => {
        let data = read();
        return new RegExp(data[0], data[1]);
      };
      const TEMP_BUNDLE = [];
      currentExtensions[98] = (data) => {
        let dataSize = (data[0] << 24) + (data[1] << 16) + (data[2] << 8) + data[3];
        let dataPosition = position$1;
        position$1 += dataSize - data.length;
        bundledStrings$1 = TEMP_BUNDLE;
        bundledStrings$1 = [readOnlyJSString(), readOnlyJSString()];
        bundledStrings$1.position0 = 0;
        bundledStrings$1.position1 = 0;
        bundledStrings$1.postBundlePosition = position$1;
        position$1 = dataPosition;
        return read();
      };
      currentExtensions[255] = (data) => {
        if (data.length == 4)
          return new Date((data[0] * 16777216 + (data[1] << 16) + (data[2] << 8) + data[3]) * 1e3);
        else if (data.length == 8)
          return new Date(
            ((data[0] << 22) + (data[1] << 14) + (data[2] << 6) + (data[3] >> 2)) / 1e6 + ((data[3] & 3) * 4294967296 + data[4] * 16777216 + (data[5] << 16) + (data[6] << 8) + data[7]) * 1e3
          );
        else if (data.length == 12)
          return new Date(
            ((data[0] << 24) + (data[1] << 16) + (data[2] << 8) + data[3]) / 1e6 + ((data[4] & 128 ? -281474976710656 : 0) + data[6] * 1099511627776 + data[7] * 4294967296 + data[8] * 16777216 + (data[9] << 16) + (data[10] << 8) + data[11]) * 1e3
          );
        else
          return /* @__PURE__ */ new Date("invalid");
      };
      function saveState(callback) {
        let savedSrcEnd = srcEnd;
        let savedPosition = position$1;
        let savedSrcStringStart = srcStringStart;
        let savedSrcStringEnd = srcStringEnd;
        let savedSrcString = srcString;
        let savedReferenceMap = referenceMap;
        let savedBundledStrings = bundledStrings$1;
        let savedSrc = new Uint8Array(src.slice(0, srcEnd));
        let savedStructures = currentStructures;
        let savedStructuresContents = currentStructures.slice(0, currentStructures.length);
        let savedPackr = currentUnpackr;
        let savedSequentialMode = sequentialMode;
        let value = callback();
        srcEnd = savedSrcEnd;
        position$1 = savedPosition;
        srcStringStart = savedSrcStringStart;
        srcStringEnd = savedSrcStringEnd;
        srcString = savedSrcString;
        referenceMap = savedReferenceMap;
        bundledStrings$1 = savedBundledStrings;
        src = savedSrc;
        sequentialMode = savedSequentialMode;
        currentStructures = savedStructures;
        currentStructures.splice(0, currentStructures.length, ...savedStructuresContents);
        currentUnpackr = savedPackr;
        dataView = new DataView(src.buffer, src.byteOffset, src.byteLength);
        return value;
      }
      function clearSource() {
        src = null;
        referenceMap = null;
        currentStructures = null;
      }
      function addExtension$1(extension) {
        if (extension.unpack)
          currentExtensions[extension.type] = extension.unpack;
        else
          currentExtensions[extension.type] = extension;
      }
      const mult10 = new Array(147);
      for (let i = 0; i < 256; i++) {
        mult10[i] = +("1e" + Math.floor(45.15 - i * 0.30103));
      }
      const Decoder = Unpackr;
      var defaultUnpackr = new Unpackr({ useRecords: false });
      const unpack = defaultUnpackr.unpack;
      const unpackMultiple = defaultUnpackr.unpackMultiple;
      const decode = defaultUnpackr.unpack;
      const FLOAT32_OPTIONS = {
        NEVER: 0,
        ALWAYS: 1,
        DECIMAL_ROUND: 3,
        DECIMAL_FIT: 4
      };
      let f32Array = new Float32Array(1);
      let u8Array = new Uint8Array(f32Array.buffer, 0, 4);
      function roundFloat32(float32Number) {
        f32Array[0] = float32Number;
        let multiplier = mult10[(u8Array[3] & 127) << 1 | u8Array[2] >> 7];
        return (multiplier * float32Number + (float32Number > 0 ? 0.5 : -0.5) >> 0) / multiplier;
      }
      let textEncoder;
      try {
        textEncoder = new TextEncoder();
      } catch (error) {
      }
      let extensions, extensionClasses;
      const hasNodeBuffer = typeof Buffer !== "undefined";
      const ByteArrayAllocate = hasNodeBuffer ? function(length) {
        return Buffer.allocUnsafeSlow(length);
      } : Uint8Array;
      const ByteArray = hasNodeBuffer ? Buffer : Uint8Array;
      const MAX_BUFFER_SIZE = hasNodeBuffer ? 4294967296 : 2144337920;
      let target, keysTarget;
      let targetView;
      let position = 0;
      let safeEnd;
      let bundledStrings = null;
      let writeStructSlots;
      const MAX_BUNDLE_SIZE = 21760;
      const hasNonLatin = /[\u0080-\uFFFF]/;
      const RECORD_SYMBOL = Symbol("record-id");
      class Packr2 extends Unpackr {
        constructor(options) {
          super(options);
          this.offset = 0;
          let start;
          let hasSharedUpdate;
          let structures;
          let referenceMap2;
          let encodeUtf8 = ByteArray.prototype.utf8Write ? function(string, position2) {
            return target.utf8Write(string, position2, target.byteLength - position2);
          } : textEncoder && textEncoder.encodeInto ? function(string, position2) {
            return textEncoder.encodeInto(string, target.subarray(position2)).written;
          } : false;
          let packr = this;
          if (!options)
            options = {};
          let isSequential = options && options.sequential;
          let hasSharedStructures = options.structures || options.saveStructures;
          let maxSharedStructures = options.maxSharedStructures;
          if (maxSharedStructures == null)
            maxSharedStructures = hasSharedStructures ? 32 : 0;
          if (maxSharedStructures > 8160)
            throw new Error("Maximum maxSharedStructure is 8160");
          if (options.structuredClone && options.moreTypes == void 0) {
            this.moreTypes = true;
          }
          let maxOwnStructures = options.maxOwnStructures;
          if (maxOwnStructures == null)
            maxOwnStructures = hasSharedStructures ? 32 : 64;
          if (!this.structures && options.useRecords != false)
            this.structures = [];
          let useTwoByteRecords = maxSharedStructures > 32 || maxOwnStructures + maxSharedStructures > 64;
          let sharedLimitId = maxSharedStructures + 64;
          let maxStructureId = maxSharedStructures + maxOwnStructures + 64;
          if (maxStructureId > 8256) {
            throw new Error("Maximum maxSharedStructure + maxOwnStructure is 8192");
          }
          let recordIdsToRemove = [];
          let transitionsCount = 0;
          let serializationsSinceTransitionRebuild = 0;
          this.pack = this.encode = function(value, encodeOptions) {
            if (!target) {
              target = new ByteArrayAllocate(8192);
              targetView = target.dataView || (target.dataView = new DataView(target.buffer, 0, 8192));
              position = 0;
            }
            safeEnd = target.length - 10;
            if (safeEnd - position < 2048) {
              target = new ByteArrayAllocate(target.length);
              targetView = target.dataView || (target.dataView = new DataView(target.buffer, 0, target.length));
              safeEnd = target.length - 10;
              position = 0;
            } else
              position = position + 7 & 2147483640;
            start = position;
            if (encodeOptions & RESERVE_START_SPACE) position += encodeOptions & 255;
            referenceMap2 = packr.structuredClone ? /* @__PURE__ */ new Map() : null;
            if (packr.bundleStrings && typeof value !== "string") {
              bundledStrings = [];
              bundledStrings.size = Infinity;
            } else
              bundledStrings = null;
            structures = packr.structures;
            if (structures) {
              if (structures.uninitialized)
                structures = packr._mergeStructures(packr.getStructures());
              let sharedLength = structures.sharedLength || 0;
              if (sharedLength > maxSharedStructures) {
                throw new Error("Shared structures is larger than maximum shared structures, try increasing maxSharedStructures to " + structures.sharedLength);
              }
              if (!structures.transitions) {
                structures.transitions = /* @__PURE__ */ Object.create(null);
                for (let i = 0; i < sharedLength; i++) {
                  let keys = structures[i];
                  if (!keys)
                    continue;
                  let nextTransition, transition = structures.transitions;
                  for (let j2 = 0, l = keys.length; j2 < l; j2++) {
                    let key = keys[j2];
                    nextTransition = transition[key];
                    if (!nextTransition) {
                      nextTransition = transition[key] = /* @__PURE__ */ Object.create(null);
                    }
                    transition = nextTransition;
                  }
                  transition[RECORD_SYMBOL] = i + 64;
                }
                this.lastNamedStructuresLength = sharedLength;
              }
              if (!isSequential) {
                structures.nextId = sharedLength + 64;
              }
            }
            if (hasSharedUpdate)
              hasSharedUpdate = false;
            let encodingError;
            try {
              if (packr.randomAccessStructure && value && value.constructor && value.constructor === Object)
                writeStruct(value);
              else
                pack2(value);
              let lastBundle = bundledStrings;
              if (bundledStrings)
                writeBundles(start, pack2, 0);
              if (referenceMap2 && referenceMap2.idsToInsert) {
                let idsToInsert = referenceMap2.idsToInsert.sort((a, b2) => a.offset > b2.offset ? 1 : -1);
                let i = idsToInsert.length;
                let incrementPosition = -1;
                while (lastBundle && i > 0) {
                  let insertionPoint = idsToInsert[--i].offset + start;
                  if (insertionPoint < lastBundle.stringsPosition + start && incrementPosition === -1)
                    incrementPosition = 0;
                  if (insertionPoint > lastBundle.position + start) {
                    if (incrementPosition >= 0)
                      incrementPosition += 6;
                  } else {
                    if (incrementPosition >= 0) {
                      targetView.setUint32(
                        lastBundle.position + start,
                        targetView.getUint32(lastBundle.position + start) + incrementPosition
                      );
                      incrementPosition = -1;
                    }
                    lastBundle = lastBundle.previous;
                    i++;
                  }
                }
                if (incrementPosition >= 0 && lastBundle) {
                  targetView.setUint32(
                    lastBundle.position + start,
                    targetView.getUint32(lastBundle.position + start) + incrementPosition
                  );
                }
                position += idsToInsert.length * 6;
                if (position > safeEnd)
                  makeRoom(position);
                packr.offset = position;
                let serialized = insertIds(target.subarray(start, position), idsToInsert);
                referenceMap2 = null;
                return serialized;
              }
              packr.offset = position;
              if (encodeOptions & REUSE_BUFFER_MODE) {
                target.start = start;
                target.end = position;
                return target;
              }
              return target.subarray(start, position);
            } catch (error) {
              encodingError = error;
              throw error;
            } finally {
              if (structures) {
                resetStructures();
                if (hasSharedUpdate && packr.saveStructures) {
                  let sharedLength = structures.sharedLength || 0;
                  let returnBuffer = target.subarray(start, position);
                  let newSharedData = prepareStructures(structures, packr);
                  if (!encodingError) {
                    if (packr.saveStructures(newSharedData, newSharedData.isCompatible) === false) {
                      return packr.pack(value, encodeOptions);
                    }
                    packr.lastNamedStructuresLength = sharedLength;
                    if (target.length > 1073741824) target = null;
                    return returnBuffer;
                  }
                }
              }
              if (target.length > 1073741824) target = null;
              if (encodeOptions & RESET_BUFFER_MODE)
                position = start;
            }
          };
          const resetStructures = () => {
            if (serializationsSinceTransitionRebuild < 10)
              serializationsSinceTransitionRebuild++;
            let sharedLength = structures.sharedLength || 0;
            if (structures.length > sharedLength && !isSequential)
              structures.length = sharedLength;
            if (transitionsCount > 1e4) {
              structures.transitions = null;
              serializationsSinceTransitionRebuild = 0;
              transitionsCount = 0;
              if (recordIdsToRemove.length > 0)
                recordIdsToRemove = [];
            } else if (recordIdsToRemove.length > 0 && !isSequential) {
              for (let i = 0, l = recordIdsToRemove.length; i < l; i++) {
                recordIdsToRemove[i][RECORD_SYMBOL] = 0;
              }
              recordIdsToRemove = [];
            }
          };
          const packArray = (value) => {
            var length = value.length;
            if (length < 16) {
              target[position++] = 144 | length;
            } else if (length < 65536) {
              target[position++] = 220;
              target[position++] = length >> 8;
              target[position++] = length & 255;
            } else {
              target[position++] = 221;
              targetView.setUint32(position, length);
              position += 4;
            }
            for (let i = 0; i < length; i++) {
              pack2(value[i]);
            }
          };
          const pack2 = (value) => {
            if (position > safeEnd)
              target = makeRoom(position);
            var type = typeof value;
            var length;
            if (type === "string") {
              let strLength = value.length;
              if (bundledStrings && strLength >= 4 && strLength < 4096) {
                if ((bundledStrings.size += strLength) > MAX_BUNDLE_SIZE) {
                  let extStart;
                  let maxBytes2 = (bundledStrings[0] ? bundledStrings[0].length * 3 + bundledStrings[1].length : 0) + 10;
                  if (position + maxBytes2 > safeEnd)
                    target = makeRoom(position + maxBytes2);
                  let lastBundle;
                  if (bundledStrings.position) {
                    lastBundle = bundledStrings;
                    target[position] = 200;
                    position += 3;
                    target[position++] = 98;
                    extStart = position - start;
                    position += 4;
                    writeBundles(start, pack2, 0);
                    targetView.setUint16(extStart + start - 3, position - start - extStart);
                  } else {
                    target[position++] = 214;
                    target[position++] = 98;
                    extStart = position - start;
                    position += 4;
                  }
                  bundledStrings = ["", ""];
                  bundledStrings.previous = lastBundle;
                  bundledStrings.size = 0;
                  bundledStrings.position = extStart;
                }
                let twoByte = hasNonLatin.test(value);
                bundledStrings[twoByte ? 0 : 1] += value;
                target[position++] = 193;
                pack2(twoByte ? -strLength : strLength);
                return;
              }
              let headerSize;
              if (strLength < 32) {
                headerSize = 1;
              } else if (strLength < 256) {
                headerSize = 2;
              } else if (strLength < 65536) {
                headerSize = 3;
              } else {
                headerSize = 5;
              }
              let maxBytes = strLength * 3;
              if (position + maxBytes > safeEnd)
                target = makeRoom(position + maxBytes);
              if (strLength < 64 || !encodeUtf8) {
                let i, c1, c2, strPosition = position + headerSize;
                for (i = 0; i < strLength; i++) {
                  c1 = value.charCodeAt(i);
                  if (c1 < 128) {
                    target[strPosition++] = c1;
                  } else if (c1 < 2048) {
                    target[strPosition++] = c1 >> 6 | 192;
                    target[strPosition++] = c1 & 63 | 128;
                  } else if ((c1 & 64512) === 55296 && ((c2 = value.charCodeAt(i + 1)) & 64512) === 56320) {
                    c1 = 65536 + ((c1 & 1023) << 10) + (c2 & 1023);
                    i++;
                    target[strPosition++] = c1 >> 18 | 240;
                    target[strPosition++] = c1 >> 12 & 63 | 128;
                    target[strPosition++] = c1 >> 6 & 63 | 128;
                    target[strPosition++] = c1 & 63 | 128;
                  } else {
                    target[strPosition++] = c1 >> 12 | 224;
                    target[strPosition++] = c1 >> 6 & 63 | 128;
                    target[strPosition++] = c1 & 63 | 128;
                  }
                }
                length = strPosition - position - headerSize;
              } else {
                length = encodeUtf8(value, position + headerSize);
              }
              if (length < 32) {
                target[position++] = 160 | length;
              } else if (length < 256) {
                if (headerSize < 2) {
                  target.copyWithin(position + 2, position + 1, position + 1 + length);
                }
                target[position++] = 217;
                target[position++] = length;
              } else if (length < 65536) {
                if (headerSize < 3) {
                  target.copyWithin(position + 3, position + 2, position + 2 + length);
                }
                target[position++] = 218;
                target[position++] = length >> 8;
                target[position++] = length & 255;
              } else {
                if (headerSize < 5) {
                  target.copyWithin(position + 5, position + 3, position + 3 + length);
                }
                target[position++] = 219;
                targetView.setUint32(position, length);
                position += 4;
              }
              position += length;
            } else if (type === "number") {
              if (value >>> 0 === value) {
                if (value < 32 || value < 128 && this.useRecords === false || value < 64 && !this.randomAccessStructure) {
                  target[position++] = value;
                } else if (value < 256) {
                  target[position++] = 204;
                  target[position++] = value;
                } else if (value < 65536) {
                  target[position++] = 205;
                  target[position++] = value >> 8;
                  target[position++] = value & 255;
                } else {
                  target[position++] = 206;
                  targetView.setUint32(position, value);
                  position += 4;
                }
              } else if (value >> 0 === value) {
                if (value >= -32) {
                  target[position++] = 256 + value;
                } else if (value >= -128) {
                  target[position++] = 208;
                  target[position++] = value + 256;
                } else if (value >= -32768) {
                  target[position++] = 209;
                  targetView.setInt16(position, value);
                  position += 2;
                } else {
                  target[position++] = 210;
                  targetView.setInt32(position, value);
                  position += 4;
                }
              } else {
                let useFloat32;
                if ((useFloat32 = this.useFloat32) > 0 && value < 4294967296 && value >= -2147483648) {
                  target[position++] = 202;
                  targetView.setFloat32(position, value);
                  let xShifted;
                  if (useFloat32 < 4 || // this checks for rounding of numbers that were encoded in 32-bit float to nearest significant decimal digit that could be preserved
                  (xShifted = value * mult10[(target[position] & 127) << 1 | target[position + 1] >> 7]) >> 0 === xShifted) {
                    position += 4;
                    return;
                  } else
                    position--;
                }
                target[position++] = 203;
                targetView.setFloat64(position, value);
                position += 8;
              }
            } else if (type === "object" || type === "function") {
              if (!value)
                target[position++] = 192;
              else {
                if (referenceMap2) {
                  let referee = referenceMap2.get(value);
                  if (referee) {
                    if (!referee.id) {
                      let idsToInsert = referenceMap2.idsToInsert || (referenceMap2.idsToInsert = []);
                      referee.id = idsToInsert.push(referee);
                    }
                    target[position++] = 214;
                    target[position++] = 112;
                    targetView.setUint32(position, referee.id);
                    position += 4;
                    return;
                  } else
                    referenceMap2.set(value, { offset: position - start });
                }
                let constructor = value.constructor;
                if (constructor === Object) {
                  writeObject(value);
                } else if (constructor === Array) {
                  packArray(value);
                } else if (constructor === Map) {
                  if (this.mapAsEmptyObject) target[position++] = 128;
                  else {
                    length = value.size;
                    if (length < 16) {
                      target[position++] = 128 | length;
                    } else if (length < 65536) {
                      target[position++] = 222;
                      target[position++] = length >> 8;
                      target[position++] = length & 255;
                    } else {
                      target[position++] = 223;
                      targetView.setUint32(position, length);
                      position += 4;
                    }
                    for (let [key, entryValue] of value) {
                      pack2(key);
                      pack2(entryValue);
                    }
                  }
                } else {
                  for (let i = 0, l = extensions.length; i < l; i++) {
                    let extensionClass = extensionClasses[i];
                    if (value instanceof extensionClass) {
                      let extension = extensions[i];
                      if (extension.write) {
                        if (extension.type) {
                          target[position++] = 212;
                          target[position++] = extension.type;
                          target[position++] = 0;
                        }
                        let writeResult = extension.write.call(this, value);
                        if (writeResult === value) {
                          if (Array.isArray(value)) {
                            packArray(value);
                          } else {
                            writeObject(value);
                          }
                        } else {
                          pack2(writeResult);
                        }
                        return;
                      }
                      let currentTarget = target;
                      let currentTargetView = targetView;
                      let currentPosition = position;
                      target = null;
                      let result;
                      try {
                        result = extension.pack.call(this, value, (size) => {
                          target = currentTarget;
                          currentTarget = null;
                          position += size;
                          if (position > safeEnd)
                            makeRoom(position);
                          return {
                            target,
                            targetView,
                            position: position - size
                          };
                        }, pack2);
                      } finally {
                        if (currentTarget) {
                          target = currentTarget;
                          targetView = currentTargetView;
                          position = currentPosition;
                          safeEnd = target.length - 10;
                        }
                      }
                      if (result) {
                        if (result.length + position > safeEnd)
                          makeRoom(result.length + position);
                        position = writeExtensionData(result, target, position, extension.type);
                      }
                      return;
                    }
                  }
                  if (Array.isArray(value)) {
                    packArray(value);
                  } else {
                    if (value.toJSON) {
                      const json = value.toJSON();
                      if (json !== value)
                        return pack2(json);
                    }
                    if (type === "function")
                      return pack2(this.writeFunction && this.writeFunction(value));
                    writeObject(value);
                  }
                }
              }
            } else if (type === "boolean") {
              target[position++] = value ? 195 : 194;
            } else if (type === "bigint") {
              if (value < BigInt(1) << BigInt(63) && value >= -(BigInt(1) << BigInt(63))) {
                target[position++] = 211;
                targetView.setBigInt64(position, value);
              } else if (value < BigInt(1) << BigInt(64) && value > 0) {
                target[position++] = 207;
                targetView.setBigUint64(position, value);
              } else {
                if (this.largeBigIntToFloat) {
                  target[position++] = 203;
                  targetView.setFloat64(position, Number(value));
                } else if (this.largeBigIntToString) {
                  return pack2(value.toString());
                } else if (this.useBigIntExtension && value < BigInt(2) ** BigInt(1023) && value > -(BigInt(2) ** BigInt(1023))) {
                  target[position++] = 199;
                  position++;
                  target[position++] = 66;
                  let bytes = [];
                  let alignedSign;
                  do {
                    let byte = value & BigInt(255);
                    alignedSign = (byte & BigInt(128)) === (value < BigInt(0) ? BigInt(128) : BigInt(0));
                    bytes.push(byte);
                    value >>= BigInt(8);
                  } while (!((value === BigInt(0) || value === BigInt(-1)) && alignedSign));
                  target[position - 2] = bytes.length;
                  for (let i = bytes.length; i > 0; ) {
                    target[position++] = Number(bytes[--i]);
                  }
                  return;
                } else {
                  throw new RangeError(value + " was too large to fit in MessagePack 64-bit integer format, use useBigIntExtension, or set largeBigIntToFloat to convert to float-64, or set largeBigIntToString to convert to string");
                }
              }
              position += 8;
            } else if (type === "undefined") {
              if (this.encodeUndefinedAsNil)
                target[position++] = 192;
              else {
                target[position++] = 212;
                target[position++] = 0;
                target[position++] = 0;
              }
            } else {
              throw new Error("Unknown type: " + type);
            }
          };
          const writePlainObject = this.variableMapSize || this.coercibleKeyAsNumber || this.skipValues ? (object) => {
            let keys;
            if (this.skipValues) {
              keys = [];
              for (let key2 in object) {
                if ((typeof object.hasOwnProperty !== "function" || object.hasOwnProperty(key2)) && !this.skipValues.includes(object[key2]))
                  keys.push(key2);
              }
            } else {
              keys = Object.keys(object);
            }
            let length = keys.length;
            if (length < 16) {
              target[position++] = 128 | length;
            } else if (length < 65536) {
              target[position++] = 222;
              target[position++] = length >> 8;
              target[position++] = length & 255;
            } else {
              target[position++] = 223;
              targetView.setUint32(position, length);
              position += 4;
            }
            let key;
            if (this.coercibleKeyAsNumber) {
              for (let i = 0; i < length; i++) {
                key = keys[i];
                let num = Number(key);
                pack2(isNaN(num) ? key : num);
                pack2(object[key]);
              }
            } else {
              for (let i = 0; i < length; i++) {
                pack2(key = keys[i]);
                pack2(object[key]);
              }
            }
          } : (object) => {
            target[position++] = 222;
            let objectOffset = position - start;
            position += 2;
            let size = 0;
            for (let key in object) {
              if (typeof object.hasOwnProperty !== "function" || object.hasOwnProperty(key)) {
                pack2(key);
                pack2(object[key]);
                size++;
              }
            }
            if (size > 65535) {
              throw new Error('Object is too large to serialize with fast 16-bit map size, use the "variableMapSize" option to serialize this object');
            }
            target[objectOffset++ + start] = size >> 8;
            target[objectOffset + start] = size & 255;
          };
          const writeRecord = this.useRecords === false ? writePlainObject : options.progressiveRecords && !useTwoByteRecords ? (
            // this is about 2% faster for highly stable structures, since it only requires one for-in loop (but much more expensive when new structure needs to be written)
            (object) => {
              let nextTransition, transition = structures.transitions || (structures.transitions = /* @__PURE__ */ Object.create(null));
              let objectOffset = position++ - start;
              let wroteKeys;
              for (let key in object) {
                if (typeof object.hasOwnProperty !== "function" || object.hasOwnProperty(key)) {
                  nextTransition = transition[key];
                  if (nextTransition)
                    transition = nextTransition;
                  else {
                    let keys = Object.keys(object);
                    let lastTransition = transition;
                    transition = structures.transitions;
                    let newTransitions = 0;
                    for (let i = 0, l = keys.length; i < l; i++) {
                      let key2 = keys[i];
                      nextTransition = transition[key2];
                      if (!nextTransition) {
                        nextTransition = transition[key2] = /* @__PURE__ */ Object.create(null);
                        newTransitions++;
                      }
                      transition = nextTransition;
                    }
                    if (objectOffset + start + 1 == position) {
                      position--;
                      newRecord(transition, keys, newTransitions);
                    } else
                      insertNewRecord(transition, keys, objectOffset, newTransitions);
                    wroteKeys = true;
                    transition = lastTransition[key];
                  }
                  pack2(object[key]);
                }
              }
              if (!wroteKeys) {
                let recordId = transition[RECORD_SYMBOL];
                if (recordId)
                  target[objectOffset + start] = recordId;
                else
                  insertNewRecord(transition, Object.keys(object), objectOffset, 0);
              }
            }
          ) : (object) => {
            let nextTransition, transition = structures.transitions || (structures.transitions = /* @__PURE__ */ Object.create(null));
            let newTransitions = 0;
            for (let key in object) if (typeof object.hasOwnProperty !== "function" || object.hasOwnProperty(key)) {
              nextTransition = transition[key];
              if (!nextTransition) {
                nextTransition = transition[key] = /* @__PURE__ */ Object.create(null);
                newTransitions++;
              }
              transition = nextTransition;
            }
            let recordId = transition[RECORD_SYMBOL];
            if (recordId) {
              if (recordId >= 96 && useTwoByteRecords) {
                target[position++] = ((recordId -= 96) & 31) + 96;
                target[position++] = recordId >> 5;
              } else
                target[position++] = recordId;
            } else {
              newRecord(transition, transition.__keys__ || Object.keys(object), newTransitions);
            }
            for (let key in object)
              if (typeof object.hasOwnProperty !== "function" || object.hasOwnProperty(key)) {
                pack2(object[key]);
              }
          };
          const checkUseRecords = typeof this.useRecords == "function" && this.useRecords;
          const writeObject = checkUseRecords ? (object) => {
            checkUseRecords(object) ? writeRecord(object) : writePlainObject(object);
          } : writeRecord;
          const makeRoom = (end) => {
            let newSize;
            if (end > 16777216) {
              if (end - start > MAX_BUFFER_SIZE)
                throw new Error("Packed buffer would be larger than maximum buffer size");
              newSize = Math.min(
                MAX_BUFFER_SIZE,
                Math.round(Math.max((end - start) * (end > 67108864 ? 1.25 : 2), 4194304) / 4096) * 4096
              );
            } else
              newSize = (Math.max(end - start << 2, target.length - 1) >> 12) + 1 << 12;
            let newBuffer = new ByteArrayAllocate(newSize);
            targetView = newBuffer.dataView || (newBuffer.dataView = new DataView(newBuffer.buffer, 0, newSize));
            end = Math.min(end, target.length);
            if (target.copy)
              target.copy(newBuffer, 0, start, end);
            else
              newBuffer.set(target.slice(start, end));
            position -= start;
            start = 0;
            safeEnd = newBuffer.length - 10;
            return target = newBuffer;
          };
          const newRecord = (transition, keys, newTransitions) => {
            let recordId = structures.nextId;
            if (!recordId)
              recordId = 64;
            if (recordId < sharedLimitId && this.shouldShareStructure && !this.shouldShareStructure(keys)) {
              recordId = structures.nextOwnId;
              if (!(recordId < maxStructureId))
                recordId = sharedLimitId;
              structures.nextOwnId = recordId + 1;
            } else {
              if (recordId >= maxStructureId)
                recordId = sharedLimitId;
              structures.nextId = recordId + 1;
            }
            let highByte = keys.highByte = recordId >= 96 && useTwoByteRecords ? recordId - 96 >> 5 : -1;
            transition[RECORD_SYMBOL] = recordId;
            transition.__keys__ = keys;
            structures[recordId - 64] = keys;
            if (recordId < sharedLimitId) {
              keys.isShared = true;
              structures.sharedLength = recordId - 63;
              hasSharedUpdate = true;
              if (highByte >= 0) {
                target[position++] = (recordId & 31) + 96;
                target[position++] = highByte;
              } else {
                target[position++] = recordId;
              }
            } else {
              if (highByte >= 0) {
                target[position++] = 213;
                target[position++] = 114;
                target[position++] = (recordId & 31) + 96;
                target[position++] = highByte;
              } else {
                target[position++] = 212;
                target[position++] = 114;
                target[position++] = recordId;
              }
              if (newTransitions)
                transitionsCount += serializationsSinceTransitionRebuild * newTransitions;
              if (recordIdsToRemove.length >= maxOwnStructures)
                recordIdsToRemove.shift()[RECORD_SYMBOL] = 0;
              recordIdsToRemove.push(transition);
              pack2(keys);
            }
          };
          const insertNewRecord = (transition, keys, insertionOffset, newTransitions) => {
            let mainTarget = target;
            let mainPosition = position;
            let mainSafeEnd = safeEnd;
            let mainStart = start;
            target = keysTarget;
            position = 0;
            start = 0;
            if (!target)
              keysTarget = target = new ByteArrayAllocate(8192);
            safeEnd = target.length - 10;
            newRecord(transition, keys, newTransitions);
            keysTarget = target;
            let keysPosition = position;
            target = mainTarget;
            position = mainPosition;
            safeEnd = mainSafeEnd;
            start = mainStart;
            if (keysPosition > 1) {
              let newEnd = position + keysPosition - 1;
              if (newEnd > safeEnd)
                makeRoom(newEnd);
              let insertionPosition = insertionOffset + start;
              target.copyWithin(insertionPosition + keysPosition, insertionPosition + 1, position);
              target.set(keysTarget.slice(0, keysPosition), insertionPosition);
              position = newEnd;
            } else {
              target[insertionOffset + start] = keysTarget[0];
            }
          };
          const writeStruct = (object) => {
            let newPosition = writeStructSlots(object, target, start, position, structures, makeRoom, (value, newPosition2, notifySharedUpdate) => {
              if (notifySharedUpdate)
                return hasSharedUpdate = true;
              position = newPosition2;
              let startTarget = target;
              pack2(value);
              resetStructures();
              if (startTarget !== target) {
                return { position, targetView, target };
              }
              return position;
            }, this);
            if (newPosition === 0)
              return writeObject(object);
            position = newPosition;
          };
        }
        useBuffer(buffer) {
          target = buffer;
          target.dataView || (target.dataView = new DataView(target.buffer, target.byteOffset, target.byteLength));
          position = 0;
        }
        set position(value) {
          position = value;
        }
        get position() {
          return position;
        }
        clearSharedData() {
          if (this.structures)
            this.structures = [];
          if (this.typedStructs)
            this.typedStructs = [];
        }
      }
      extensionClasses = [Date, Set, Error, RegExp, ArrayBuffer, Object.getPrototypeOf(Uint8Array.prototype).constructor, C1Type];
      extensions = [{
        pack(date, allocateForWrite, pack2) {
          let seconds = date.getTime() / 1e3;
          if ((this.useTimestamp32 || date.getMilliseconds() === 0) && seconds >= 0 && seconds < 4294967296) {
            let { target: target2, targetView: targetView2, position: position2 } = allocateForWrite(6);
            target2[position2++] = 214;
            target2[position2++] = 255;
            targetView2.setUint32(position2, seconds);
          } else if (seconds > 0 && seconds < 4294967296) {
            let { target: target2, targetView: targetView2, position: position2 } = allocateForWrite(10);
            target2[position2++] = 215;
            target2[position2++] = 255;
            targetView2.setUint32(position2, date.getMilliseconds() * 4e6 + (seconds / 1e3 / 4294967296 >> 0));
            targetView2.setUint32(position2 + 4, seconds);
          } else if (isNaN(seconds)) {
            if (this.onInvalidDate) {
              allocateForWrite(0);
              return pack2(this.onInvalidDate());
            }
            let { target: target2, targetView: targetView2, position: position2 } = allocateForWrite(3);
            target2[position2++] = 212;
            target2[position2++] = 255;
            target2[position2++] = 255;
          } else {
            let { target: target2, targetView: targetView2, position: position2 } = allocateForWrite(15);
            target2[position2++] = 199;
            target2[position2++] = 12;
            target2[position2++] = 255;
            targetView2.setUint32(position2, date.getMilliseconds() * 1e6);
            targetView2.setBigInt64(position2 + 4, BigInt(Math.floor(seconds)));
          }
        }
      }, {
        pack(set, allocateForWrite, pack2) {
          if (this.setAsEmptyObject) {
            allocateForWrite(0);
            return pack2({});
          }
          let array = Array.from(set);
          let { target: target2, position: position2 } = allocateForWrite(this.moreTypes ? 3 : 0);
          if (this.moreTypes) {
            target2[position2++] = 212;
            target2[position2++] = 115;
            target2[position2++] = 0;
          }
          pack2(array);
        }
      }, {
        pack(error, allocateForWrite, pack2) {
          let { target: target2, position: position2 } = allocateForWrite(this.moreTypes ? 3 : 0);
          if (this.moreTypes) {
            target2[position2++] = 212;
            target2[position2++] = 101;
            target2[position2++] = 0;
          }
          pack2([error.name, error.message, error.cause]);
        }
      }, {
        pack(regex, allocateForWrite, pack2) {
          let { target: target2, position: position2 } = allocateForWrite(this.moreTypes ? 3 : 0);
          if (this.moreTypes) {
            target2[position2++] = 212;
            target2[position2++] = 120;
            target2[position2++] = 0;
          }
          pack2([regex.source, regex.flags]);
        }
      }, {
        pack(arrayBuffer, allocateForWrite) {
          if (this.moreTypes)
            writeExtBuffer(arrayBuffer, 16, allocateForWrite);
          else
            writeBuffer(hasNodeBuffer ? Buffer.from(arrayBuffer) : new Uint8Array(arrayBuffer), allocateForWrite);
        }
      }, {
        pack(typedArray, allocateForWrite) {
          let constructor = typedArray.constructor;
          if (constructor !== ByteArray && this.moreTypes)
            writeExtBuffer(typedArray, typedArrays.indexOf(constructor.name), allocateForWrite);
          else
            writeBuffer(typedArray, allocateForWrite);
        }
      }, {
        pack(c1, allocateForWrite) {
          let { target: target2, position: position2 } = allocateForWrite(1);
          target2[position2] = 193;
        }
      }];
      function writeExtBuffer(typedArray, type, allocateForWrite, encode2) {
        let length = typedArray.byteLength;
        if (length + 1 < 256) {
          var { target: target2, position: position2 } = allocateForWrite(4 + length);
          target2[position2++] = 199;
          target2[position2++] = length + 1;
        } else if (length + 1 < 65536) {
          var { target: target2, position: position2 } = allocateForWrite(5 + length);
          target2[position2++] = 200;
          target2[position2++] = length + 1 >> 8;
          target2[position2++] = length + 1 & 255;
        } else {
          var { target: target2, position: position2, targetView: targetView2 } = allocateForWrite(7 + length);
          target2[position2++] = 201;
          targetView2.setUint32(position2, length + 1);
          position2 += 4;
        }
        target2[position2++] = 116;
        target2[position2++] = type;
        if (!typedArray.buffer) typedArray = new Uint8Array(typedArray);
        target2.set(new Uint8Array(typedArray.buffer, typedArray.byteOffset, typedArray.byteLength), position2);
      }
      function writeBuffer(buffer, allocateForWrite) {
        let length = buffer.byteLength;
        var target2, position2;
        if (length < 256) {
          var { target: target2, position: position2 } = allocateForWrite(length + 2);
          target2[position2++] = 196;
          target2[position2++] = length;
        } else if (length < 65536) {
          var { target: target2, position: position2 } = allocateForWrite(length + 3);
          target2[position2++] = 197;
          target2[position2++] = length >> 8;
          target2[position2++] = length & 255;
        } else {
          var { target: target2, position: position2, targetView: targetView2 } = allocateForWrite(length + 5);
          target2[position2++] = 198;
          targetView2.setUint32(position2, length);
          position2 += 4;
        }
        target2.set(buffer, position2);
      }
      function writeExtensionData(result, target2, position2, type) {
        let length = result.length;
        switch (length) {
          case 1:
            target2[position2++] = 212;
            break;
          case 2:
            target2[position2++] = 213;
            break;
          case 4:
            target2[position2++] = 214;
            break;
          case 8:
            target2[position2++] = 215;
            break;
          case 16:
            target2[position2++] = 216;
            break;
          default:
            if (length < 256) {
              target2[position2++] = 199;
              target2[position2++] = length;
            } else if (length < 65536) {
              target2[position2++] = 200;
              target2[position2++] = length >> 8;
              target2[position2++] = length & 255;
            } else {
              target2[position2++] = 201;
              target2[position2++] = length >> 24;
              target2[position2++] = length >> 16 & 255;
              target2[position2++] = length >> 8 & 255;
              target2[position2++] = length & 255;
            }
        }
        target2[position2++] = type;
        target2.set(result, position2);
        position2 += length;
        return position2;
      }
      function insertIds(serialized, idsToInsert) {
        let nextId;
        let distanceToMove = idsToInsert.length * 6;
        let lastEnd = serialized.length - distanceToMove;
        while (nextId = idsToInsert.pop()) {
          let offset = nextId.offset;
          let id = nextId.id;
          serialized.copyWithin(offset + distanceToMove, offset, lastEnd);
          distanceToMove -= 6;
          let position2 = offset + distanceToMove;
          serialized[position2++] = 214;
          serialized[position2++] = 105;
          serialized[position2++] = id >> 24;
          serialized[position2++] = id >> 16 & 255;
          serialized[position2++] = id >> 8 & 255;
          serialized[position2++] = id & 255;
          lastEnd = offset;
        }
        return serialized;
      }
      function writeBundles(start, pack2, incrementPosition) {
        if (bundledStrings.length > 0) {
          targetView.setUint32(bundledStrings.position + start, position + incrementPosition - bundledStrings.position - start);
          bundledStrings.stringsPosition = position - start;
          let writeStrings = bundledStrings;
          bundledStrings = null;
          pack2(writeStrings[0]);
          pack2(writeStrings[1]);
        }
      }
      function addExtension(extension) {
        if (extension.Class) {
          if (!extension.pack && !extension.write)
            throw new Error("Extension has no pack or write function");
          if (extension.pack && !extension.type)
            throw new Error("Extension has no type (numeric code to identify the extension)");
          extensionClasses.unshift(extension.Class);
          extensions.unshift(extension);
        }
        addExtension$1(extension);
      }
      function prepareStructures(structures, packr) {
        structures.isCompatible = (existingStructures) => {
          let compatible = !existingStructures || (packr.lastNamedStructuresLength || 0) === existingStructures.length;
          if (!compatible)
            packr._mergeStructures(existingStructures);
          return compatible;
        };
        return structures;
      }
      let defaultPackr = new Packr2({ useRecords: false });
      const pack = defaultPackr.pack;
      const encode = defaultPackr.pack;
      const Encoder = Packr2;
      const { NEVER, ALWAYS, DECIMAL_ROUND, DECIMAL_FIT } = FLOAT32_OPTIONS;
      const REUSE_BUFFER_MODE = 512;
      const RESET_BUFFER_MODE = 1024;
      const RESERVE_START_SPACE = 2048;
      function packIter(objectIterator, options = {}) {
        if (!objectIterator || typeof objectIterator !== "object") {
          throw new Error("first argument must be an Iterable, Async Iterable, or a Promise for an Async Iterable");
        } else if (typeof objectIterator[Symbol.iterator] === "function") {
          return packIterSync(objectIterator, options);
        } else if (typeof objectIterator.then === "function" || typeof objectIterator[Symbol.asyncIterator] === "function") {
          return packIterAsync(objectIterator, options);
        } else {
          throw new Error("first argument must be an Iterable, Async Iterable, Iterator, Async Iterator, or a Promise");
        }
      }
      function* packIterSync(objectIterator, options) {
        const packr = new Packr2(options);
        for (const value of objectIterator) {
          yield packr.pack(value);
        }
      }
      async function* packIterAsync(objectIterator, options) {
        const packr = new Packr2(options);
        for await (const value of objectIterator) {
          yield packr.pack(value);
        }
      }
      function unpackIter(bufferIterator, options = {}) {
        if (!bufferIterator || typeof bufferIterator !== "object") {
          throw new Error("first argument must be an Iterable, Async Iterable, Iterator, Async Iterator, or a promise");
        }
        const unpackr = new Unpackr(options);
        let incomplete;
        const parser = (chunk) => {
          let yields;
          if (incomplete) {
            chunk = Buffer.concat([incomplete, chunk]);
            incomplete = void 0;
          }
          try {
            yields = unpackr.unpackMultiple(chunk);
          } catch (err) {
            if (err.incomplete) {
              incomplete = chunk.slice(err.lastPosition);
              yields = err.values;
            } else {
              throw err;
            }
          }
          return yields;
        };
        if (typeof bufferIterator[Symbol.iterator] === "function") {
          return function* iter() {
            for (const value of bufferIterator) {
              yield* parser(value);
            }
          }();
        } else if (typeof bufferIterator[Symbol.asyncIterator] === "function") {
          return async function* iter() {
            for await (const value of bufferIterator) {
              yield* parser(value);
            }
          }();
        }
      }
      const decodeIter = unpackIter;
      const encodeIter = packIter;
      const useRecords = false;
      const mapsAsObjects = true;
      exports2.ALWAYS = ALWAYS;
      exports2.C1 = C1;
      exports2.DECIMAL_FIT = DECIMAL_FIT;
      exports2.DECIMAL_ROUND = DECIMAL_ROUND;
      exports2.Decoder = Decoder;
      exports2.Encoder = Encoder;
      exports2.FLOAT32_OPTIONS = FLOAT32_OPTIONS;
      exports2.NEVER = NEVER;
      exports2.Packr = Packr2;
      exports2.RESERVE_START_SPACE = RESERVE_START_SPACE;
      exports2.RESET_BUFFER_MODE = RESET_BUFFER_MODE;
      exports2.REUSE_BUFFER_MODE = REUSE_BUFFER_MODE;
      exports2.Unpackr = Unpackr;
      exports2.addExtension = addExtension;
      exports2.clearSource = clearSource;
      exports2.decode = decode;
      exports2.decodeIter = decodeIter;
      exports2.encode = encode;
      exports2.encodeIter = encodeIter;
      exports2.isNativeAccelerationEnabled = isNativeAccelerationEnabled;
      exports2.mapsAsObjects = mapsAsObjects;
      exports2.pack = pack;
      exports2.roundFloat32 = roundFloat32;
      exports2.unpack = unpack;
      exports2.unpackMultiple = unpackMultiple;
      exports2.useRecords = useRecords;
    });
  }
});
var N = "AWS4-HMAC-SHA256";
var I = "aws4_request";
var D = "s3";
var v = "2";
var f = "UNSIGNED-PAYLOAD";
var W = "application/octet-stream";
var U = "application/xml";
var w = "application/json";
var X = ["accessKeyId", "secretAccessKey", "sessionToken", "password"];
var _ = "x-amz-content-sha256";
var Z = "x-amz-date";
var V = "host";
var J = "Authorization";
var m = "Content-Type";
var R = "Content-Length";
var P = "etag";
var M = "last-modified";
var h = "ultralight-s3 Module: ";
var ee = `${h}accessKeyId must be a non-empty string`;
var te = `${h}secretAccessKey must be a non-empty string`;
var se = `${h}endpoint must be a non-empty string`;
var re = `${h}bucketName must be a non-empty string`;
var L = `${h}key must be a non-empty string`;
var T = `${h}uploadId must be a non-empty string`;
var j = `${h}parts must be a non-empty array`;
var k = `${h}Each part must have a partNumber (number) and ETag (string)`;
var H = `${h}data must be a Buffer or string`;
var B = `${h}prefix must be a string`;
var F = `${h}maxKeys must be a positive integer`;
var G = `${h}delimiter must be a string`;
var z = crypto.createHmac || (await import("node:crypto")).createHmac;
var Q = crypto.createHash || (await import("node:crypto")).createHash;
typeof z > "u" && typeof Q > "u" && console.error("ultralight-S3 Module: Crypto functions are not available, please report the issue with necessary description: https://github.com/sentienhq/ultralight-s3/issues");
var ne = { contents: true };
var oe = (p) => `%${p.charCodeAt(0).toString(16).toUpperCase()}`;
var K = (p) => encodeURIComponent(p).replace(/[!'()*]/g, oe);
var y = (p) => K(p).replace(/%2F/g, "/");
var O = class {
  constructor({ accessKeyId: e, secretAccessKey: t, endpoint: r, bucketName: n, region: o = "auto", maxRequestSizeInBytes: i = 5242880, requestAbortTimeout: a = void 0, logger: c = void 0 }) {
    this.getBucketName = () => this.bucketName, this.setBucketName = (s) => {
      this.bucketName = s;
    }, this.getRegion = () => this.region, this.setRegion = (s) => {
      this.region = s;
    }, this.getEndpoint = () => this.endpoint, this.setEndpoint = (s) => {
      this.endpoint = s;
    }, this.getMaxRequestSizeInBytes = () => this.maxRequestSizeInBytes, this.setMaxRequestSizeInBytes = (s) => {
      this.maxRequestSizeInBytes = s;
    }, this.sanitizeETag = (s) => A(s), this.getProps = () => ({ accessKeyId: this.accessKeyId, secretAccessKey: this.secretAccessKey, region: this.region, bucket: this.bucketName, endpoint: this.endpoint, maxRequestSizeInBytes: this.maxRequestSizeInBytes, requestAbortTimeout: this.requestAbortTimeout, logger: this.logger }), this.setProps = (s) => {
      this._validateConstructorParams(s.accessKeyId, s.secretAccessKey, s.bucketName, s.endpoint), this.accessKeyId = s.accessKeyId, this.secretAccessKey = s.secretAccessKey, this.region = s.region || "auto", this.bucketName = s.bucketName, this.endpoint = s.endpoint, this.maxRequestSizeInBytes = s.maxRequestSizeInBytes || 5242880, this.requestAbortTimeout = s.requestAbortTimeout, this.logger = s.logger;
    }, this._validateConstructorParams(e, t, r, n), this.accessKeyId = e, this.secretAccessKey = t, this.endpoint = r, this.bucketName = n, this.region = o, this.maxRequestSizeInBytes = i, this.requestAbortTimeout = a, this.logger = c;
  }
  _validateConstructorParams(e, t, r, n) {
    if (typeof e != "string" || e.trim().length === 0) throw new TypeError(ee);
    if (typeof t != "string" || t.trim().length === 0) throw new TypeError(te);
    if (typeof r != "string" || r.trim().length === 0) throw new TypeError(se);
    if (typeof n != "string" || n.trim().length === 0) throw new TypeError(re);
  }
  _checkMethodHeadnGet(e) {
    if (e !== "GET" && e !== "HEAD") throw this._log("error", `${h}method must be either GET or HEAD`), new Error("method must be either GET or HEAD");
  }
  _checkKey(e) {
    if (typeof e != "string" || e.trim().length === 0) throw this._log("error", L), new TypeError(L);
  }
  _checkDelimiter(e) {
    if (typeof e != "string" || e.trim().length === 0) throw this._log("error", G), new TypeError(G);
  }
  _checkPrefix(e) {
    if (typeof e != "string") throw this._log("error", B), new TypeError(B);
  }
  _checkMaxKeys(e) {
    if (typeof e != "number" || e <= 0) throw this._log("error", F), new TypeError(F);
  }
  _checkOpts(e) {
    if (typeof e != "object") throw this._log("error", `${h}opts must be an object`), new TypeError(`${h}opts must be an object`);
  }
  _log(e, t, r = {}) {
    if (this.logger && typeof this.logger[e] == "function") {
      let n = (a) => typeof a != "object" || a === null ? a : Object.keys(a).reduce((c, s) => (X.includes(s.toLowerCase()) ? c[s] = "[REDACTED]" : typeof a[s] == "object" && a[s] !== null ? c[s] = n(a[s]) : c[s] = a[s], c), Array.isArray(a) ? [] : {}), o = n(r), i = { timestamp: (/* @__PURE__ */ new Date()).toISOString(), level: e, message: t, ...o, context: n({ bucketName: this.bucketName, region: this.region, endpoint: this.endpoint, accessKeyId: this.accessKeyId ? `${this.accessKeyId.substring(0, 4)}...` : void 0 }) };
      this.logger[e](i);
    }
  }
  async getContentLength(e) {
    this._checkKey(e);
    let t = { [_]: f }, r = y(e), { url: n, headers: o } = await this._sign("HEAD", r, {}, t, ""), a = (await this._sendRequest(n, "HEAD", o)).headers.get(R);
    return a ? parseInt(a, 10) : 0;
  }
  async bucketExists() {
    let e = { [_]: f }, { url: t, headers: r } = await this._sign("HEAD", "", {}, e, ""), n = await this._sendRequest(t, "HEAD", r, "", [200, 404, 403]);
    return this._log("error", `Response status: ${n.status, n.statusText}`), !!(n.ok && n.status === 200);
  }
  async createBucket() {
    let e = `
    <CreateBucketConfiguration xmlns="http://s3.amazonaws.com/doc/2006-03-01/">
      <LocationConstraint>${this.region}</LocationConstraint>
    </CreateBucketConfiguration>
    `, t = { [m]: U, [R]: Buffer.byteLength(e).toString(), [_]: await b(e) }, r = encodeURI(""), { url: n, headers: o } = await this._sign("PUT", r, {}, t, ""), i = await this._sendRequest(n, "PUT", o, e, [200, 404, 403]);
    return !!(i.ok && i.status === 200);
  }
  async fileExists(e, t = {}) {
    this._checkKey(e);
    let { filteredOpts: r, conditionalHeaders: n } = this._filterIfHeaders(t), o = { [_]: f, ...n }, i = y(e), { url: a, headers: c } = await this._sign("HEAD", i, r, o, "");
    try {
      let s = await this._sendRequest(a, "HEAD", c, "", [200, 404, 412, 304]);
      return s.status === 404 ? false : s.status === 412 || s.status === 304 ? null : s.ok && s.status === 200 ? true : (this._handleErrorResponse(s), false);
    } catch (s) {
      let l = s instanceof Error ? s.message : String(s);
      throw this._log("error", `${h}Failed to check if file exists: ${l}`), new Error(`${h}Failed to check if file exists: ${l}`);
    }
  }
  async _sign(e, t, r = {}, n, o) {
    let i = (/* @__PURE__ */ new Date()).toISOString().replace(/[:-]|\.\d{3}/g, ""), a = typeof t == "string" && t.length > 0 ? new URL(t, this.endpoint) : new URL(this.endpoint);
    a.pathname = `/${encodeURI(this.bucketName)}${a.pathname}`, n[_] = o ? await b(o) : f, n[Z] = i, n[V] = a.host;
    let c = this._buildCanonicalHeaders(n), s = Object.keys(n).map((E) => E.toLowerCase()).sort().join(";"), l = await this._buildCanonicalRequest(e, a, r, c, s, o), u = await this._buildStringToSign(i, l), d = await this._calculateSignature(i, u), g = this._buildAuthorizationHeader(i, s, d);
    return n[J] = g, { url: a.toString(), headers: n };
  }
  _buildCanonicalHeaders(e) {
    return Object.entries(e).map(([t, r]) => `${t.toLowerCase()}:${String(r).trim()}`).sort().join(`
`);
  }
  async _buildCanonicalRequest(e, t, r, n, o, i) {
    return [e, t.pathname, this._buildCanonicalQueryString(r), `${n}
`, o, i ? await b(i) : f].join(`
`);
  }
  async _buildStringToSign(e, t) {
    let r = [e.slice(0, 8), this.region, D, I].join("/");
    return [N, e, r, await b(t)].join(`
`);
  }
  async _calculateSignature(e, t) {
    let r = await this._getSignatureKey(e.slice(0, 8));
    return S(r, t, "hex");
  }
  _buildAuthorizationHeader(e, t, r) {
    let n = [e.slice(0, 8), this.region, D, I].join("/");
    return [`${N} Credential=${this.accessKeyId}/${n}`, `SignedHeaders=${t}`, `Signature=${r}`].join(", ");
  }
  _filterIfHeaders(e) {
    let t = {}, r = {}, n = ["if-match", "if-none-match", "if-modified-since", "if-unmodified-since"];
    for (let [o, i] of Object.entries(e)) n.includes(o) ? r[o] = i : t[o] = i;
    return { filteredOpts: t, conditionalHeaders: r };
  }
  async list(e = "/", t = "", r = 1e3, n = "GET", o = {}) {
    this._checkDelimiter(e), this._checkPrefix(t), this._checkMaxKeys(r), this._checkMethodHeadnGet(n), this._checkOpts(o), this._log("info", `Listing objects in ${t}`);
    let i = { "list-type": v, "max-keys": String(r), ...o };
    t.length > 0 && (i.prefix = t);
    let a = { [m]: w, [_]: f }, c = e === "/" ? e : K(e), { url: s, headers: l } = await this._sign("GET", c, i, a, ""), u = `${s}?${new URLSearchParams(i)}`, d = await this._sendRequest(u, "GET", l), g = await d.text();
    if (n === "HEAD") {
      let C = d.headers.get(R), x = d.headers.get(M), Y = d.headers.get(P);
      return { size: C ? +C : void 0, mtime: x ? new Date(x) : void 0, ETag: Y || void 0 };
    }
    let E = $(g), q = E.listBucketResult || E.error || E;
    return q.contents || q;
  }
  async listMultiPartUploads(e = "/", t = "", r = "GET", n = {}) {
    this._checkDelimiter(e), this._checkPrefix(t), this._checkMethodHeadnGet(r), this._checkOpts(n), this._log("info", `Listing multipart uploads in ${t}`);
    let o = { uploads: "", ...n }, i = { [m]: w, [_]: f }, a = e === "/" ? e : K(e), { url: c, headers: s } = await this._sign("GET", a, o, i, ""), l = `${c}?${new URLSearchParams(o)}`, u = await this._sendRequest(l, "GET", s), d = await u.text();
    if (r === "HEAD") return { size: +(u.headers.get(R) ?? "0"), mtime: new Date(u.headers.get(M) ?? ""), ETag: u.headers.get(P) ?? "" };
    let g = $(d), E = g.listMultipartUploadsResult || g.error || g;
    return E.uploads || E;
  }
  async get(e, t = {}) {
    this._checkKey(e), this._log("info", `Getting object ${e}`);
    let { filteredOpts: r, conditionalHeaders: n } = this._filterIfHeaders(t), o = { [m]: w, [_]: f, ...n }, i = y(e), { url: a, headers: c } = await this._sign("GET", i, r, o, ""), s = await this._sendRequest(a, "GET", c, "", [200, 404, 412, 304]);
    if (s.status === 404 || s.status === 412 || s.status === 304) return this._log("error", `Failed to get object. Status: ${s.status}`), null;
    if (!s.ok) throw this._log("error", `Failed to get object. Status: ${s.status}`), new Error(`Failed to get object. Status: ${s.status}`);
    return s;
  }
  async getObjectWithETag(e, t = {}) {
    this._checkKey(e), this._log("info", `Getting object ${e}`);
    let { filteredOpts: r, conditionalHeaders: n } = this._filterIfHeaders(t), o = { [m]: w, [_]: f, ...n }, i = y(e), { url: a, headers: c } = await this._sign("GET", i, r, o, "");
    try {
      let s = await this._sendRequest(a, "GET", c, "", [200, 404, 412, 304]);
      if (s.status === 404 || s.status === 412 || s.status === 304) return this._log("error", `Failed to get object. Status: ${s.status}`), { etag: null, data: null };
      if (!s.ok) throw this._log("error", `Failed to get object. Status: ${s.status}`), new Error(`Failed to get object. Status: ${s.status}`);
      let l = s.headers.get("etag");
      if (!l) throw new Error("ETag not found in response headers");
      let u = await s.text();
      return { etag: A(l), data: u };
    } catch (s) {
      throw this._log("error", `Error getting object ${e} with ETag: ${s}`), s;
    }
  }
  async getEtag(e, t = {}) {
    this._checkKey(e), this._log("info", `Getting etag object ${e}`);
    let { filteredOpts: r, conditionalHeaders: n } = this._filterIfHeaders(t), o = { [m]: w, [_]: f, ...n }, i = y(e), { url: a, headers: c } = await this._sign("HEAD", i, r, o, ""), s = await this._sendRequest(a, "HEAD", c, "", [200, 412, 304]);
    if (this._log("info", `Response status: ${s.status, s.statusText}`), s.status === 412 || s.status === 304) return null;
    let l = s.headers.get("etag");
    if (!l) throw this._log("error", "ETag not found in response headers"), new Error("ETag not found in response headers");
    return A(l);
  }
  async getResponse(e, t = true, r = 0, n = this.maxRequestSizeInBytes, o = {}) {
    this._checkKey(e);
    let { filteredOpts: i, conditionalHeaders: a } = this._filterIfHeaders({ ...o }), c = { [m]: w, [_]: f, ...t ? {} : { range: `bytes=${r}-${n - 1}` }, ...a }, s = y(e), { url: l, headers: u } = await this._sign("GET", s, i, c, ""), d = `${l}?${new URLSearchParams(i)}`;
    return this._sendRequest(d, "GET", u);
  }
  async put(e, t) {
    if (this._checkKey(e), !(t instanceof Buffer || typeof t == "string")) throw this._log("error", H), new TypeError(H);
    this._log("info", `Uploading object ${e}`);
    let r = typeof t == "string" ? Buffer.byteLength(t) : t.length, n = { [R]: r }, o = y(e), { url: i, headers: a } = await this._sign("PUT", o, {}, n, t);
    return this._sendRequest(i, "PUT", a, t, [200]);
  }
  async getMultipartUploadId(e, t = W) {
    if (this._checkKey(e), typeof t != "string") throw this._log("error", `${h}fileType must be a string`), new TypeError(`${h}fileType must be a string`);
    this._log("info", `Initiating multipart upload for object ${e}`);
    let r = { uploads: "" }, n = { [m]: t, [_]: f }, o = y(e), { url: i, headers: a } = await this._sign("POST", o, r, n, ""), c = `${i}?${new URLSearchParams(r)}`, l = await (await this._sendRequest(c, "POST", a)).text(), u = $(l);
    if (typeof u == "object" && u !== null && "error" in u && typeof u.error == "object" && u.error !== null && "message" in u.error) {
      let d = String(u.error.message);
      throw this._log("error", `${h}Failed to abort multipart upload: ${d}`), new Error(`${h}Failed to abort multipart upload: ${d}`);
    }
    if (typeof u == "object" && u !== null) {
      if (!u.initiateMultipartUploadResult || !u.initiateMultipartUploadResult.uploadId) throw this._log("error", `${h}Failed to create multipart upload: no uploadId in response`), new Error(`${h}Failed to create multipart upload: Missing upload ID in response`);
      return u.initiateMultipartUploadResult.uploadId;
    } else throw this._log("error", `${h}Failed to create multipart upload: unexpected response format`), new Error(`${h}Failed to create multipart upload: Unexpected response format`);
  }
  async uploadPart(e, t, r, n, o = {}) {
    this._validateUploadPartParams(e, t, r, n, o);
    let i = { uploadId: r, partNumber: n, ...o }, a = { [R]: t.length }, c = y(e), { url: s, headers: l } = await this._sign("PUT", c, i, a, t), u = `${s}?${new URLSearchParams(i)}`, d = await this._sendRequest(u, "PUT", l, t), g = A(d.headers.get("etag") || "");
    return { partNumber: n, ETag: g };
  }
  _validateUploadPartParams(e, t, r, n, o) {
    if (this._checkKey(e), !(t instanceof Buffer || typeof t == "string")) throw this._log("error", H), new TypeError(H);
    if (typeof r != "string" || r.trim().length === 0) throw this._log("error", T), new TypeError(T);
    if (!Number.isInteger(n) || n <= 0) throw this._log("error", `${h}partNumber must be a positive integer`), new TypeError(`${h}partNumber must be a positive integer`);
    this._checkOpts(o);
  }
  async completeMultipartUpload(e, t, r) {
    if (this._checkKey(e), typeof t != "string" || t.trim().length === 0) throw this._log("error", T), new TypeError(T);
    if (!Array.isArray(r) || r.length === 0) throw this._log("error", j), new TypeError(j);
    if (!r.every((E) => typeof E.partNumber == "number" && typeof E.ETag == "string")) throw this._log("error", k), new TypeError(k);
    this._log("info", `Complete multipart upload ${t} for object ${e}`);
    let n = { uploadId: t }, o = this._buildCompleteMultipartUploadXml(r), i = { [m]: U, [R]: Buffer.byteLength(o).toString(), [_]: await b(o) }, a = y(e), { url: c, headers: s } = await this._sign("POST", a, n, i, o), l = `${c}?${new URLSearchParams(n)}`, d = await (await this._sendRequest(l, "POST", s, o)).text(), g = $(d);
    if (typeof g == "object" && g !== null && "error" in g && typeof g.error == "object" && g.error !== null && "message" in g.error) {
      let E = String(g.error.message);
      throw this._log("error", `${h}Failed to abort multipart upload: ${E}`), new Error(`${h}Failed to abort multipart upload: ${E}`);
    }
    return g.completeMultipartUploadResult;
  }
  async abortMultipartUpload(e, t) {
    if (this._checkKey(e), typeof t != "string" || t.trim().length === 0) throw this._log("error", T), new TypeError(T);
    this._log("info", `Aborting multipart upload ${t} for object ${e}`);
    let r = { uploadId: t }, n = { [m]: U, [_]: f };
    try {
      let o = y(e), { url: i, headers: a } = await this._sign("DELETE", o, r, n, ""), c = `${i}?${new URLSearchParams(r)}`, s = await this._sendRequest(c, "DELETE", a);
      if (s.ok) {
        let l = await s.text(), u = $(l);
        if (typeof u == "object" && u !== null && "error" in u && typeof u.error == "object" && u.error !== null && "message" in u.error) {
          let d = String(u.error.message);
          throw this._log("error", `${h}Failed to abort multipart upload: ${d}`), new Error(`${h}Failed to abort multipart upload: ${d}`);
        }
        return { status: "Aborted", key: e, uploadId: t, response: u };
      } else throw this._log("error", `${h}Abort request failed with status ${s.status}`), new Error(`${h}Abort request failed with status ${s.status}`);
    } catch (o) {
      let i = o instanceof Error ? o.message : String(o);
      throw this._log("error", `${h}Failed to abort multipart upload for key ${e}: ${i}`), new Error(`${h}Failed to abort multipart upload for key ${e}: ${i}`);
    }
  }
  _buildCompleteMultipartUploadXml(e) {
    return `
      <CompleteMultipartUpload>
        ${e.map((t) => `
          <Part>
            <PartNumber>${t.partNumber}</PartNumber>
            <ETag>${t.ETag}</ETag>
          </Part>
        `).join("")}
      </CompleteMultipartUpload>
    `;
  }
  async delete(e) {
    this._checkKey(e), this._log("info", `Deleting object ${e}`);
    let t = { [m]: w, [_]: f }, r = y(e), { url: n, headers: o } = await this._sign("DELETE", r, {}, t, ""), i = await this._sendRequest(n, "DELETE", o);
    return i.status === 204 || i.status === 200;
  }
  async _sendRequest(e, t, r, n, o = []) {
    this._log("info", `Sending ${t} request to ${e}, headers: ${JSON.stringify(r)}`);
    let i = await fetch(e, { method: t, headers: r, body: ["GET", "HEAD"].includes(t) ? void 0 : n, signal: this.requestAbortTimeout !== void 0 ? AbortSignal.timeout(this.requestAbortTimeout) : void 0 });
    return this._log("info", `Response status: ${i.status, o}`), !i.ok && !o.includes(i.status) && await this._handleErrorResponse(i), i;
  }
  async _handleErrorResponse(e) {
    let t = await e.text(), r = e.headers.get("x-amz-error-code") || "Unknown", n = e.headers.get("x-amz-error-message") || e.statusText;
    throw this._log("error", `${h}Request failed with status ${e.status}: ${r} - ${n},err body: ${t}`), new Error(`${h}Request failed with status ${e.status}: ${r} - ${n}, err body: ${t}`);
  }
  _buildCanonicalQueryString(e) {
    return Object.keys(e).length < 1 ? "" : Object.keys(e).sort().map((t) => `${encodeURIComponent(t)}=${encodeURIComponent(e[t])}`).join("&");
  }
  async _getSignatureKey(e) {
    let t = await S(`AWS4${this.secretAccessKey}`, e), r = await S(t, this.region), n = await S(r, D);
    return S(n, I);
  }
};
var b = async (p) => {
  let e = Q("sha256");
  return e.update(p), e.digest("hex");
};
var S = async (p, e, t) => {
  let r = z("sha256", p);
  return r.update(e), r.digest(t);
};
var A = (p) => {
  let e = { '"': "", "&quot;": "", "&#34;": "", "&QUOT;": "", "&#x00022": "" };
  return p.replace(/^("|&quot;|&#34;)|("|&quot;|&#34;)$/g, (t) => e[t]);
};
var $ = (p) => {
  let e = (o) => o.replace(/&quot;/g, '"').replace(/&apos;/g, "'").replace(/&lt;/g, "<").replace(/&gt;/g, ">").replace(/&amp;/g, "&"), t = {}, r = /<(\w)([-\w]+)(?:\/|[^>]*>((?:(?!<\1)[\s\S])*)<\/\1\2)>/gm, n;
  for (; n = r.exec(p); ) {
    let [, o, i, a] = n, c = o.toLowerCase() + i, s = a != null ? $(a) : true;
    typeof s == "string" ? t[c] = A(e(s)) : Array.isArray(t[c]) ? t[c].push(s) : t[c] = t[c] != null ? [t[c], s] : ne[c] ? [s] : s;
  }
  return Object.keys(t).length ? t : e(p);
};
var import_index_no_eval = __toESM(require_index_no_eval(), 1);
var lowstorage_ERROR_CODES = {
  MISSING_ARGUMENT: "MISSING_ARGUMENT",
  COLLECTION_EXISTS: "COLLECTION_EXISTS",
  CREATE_COLLECTION_ERROR: "CREATE_COLLECTION_ERROR",
  LIST_COLLECTIONS_ERROR: "LIST_COLLECTIONS_ERROR",
  RENAME_COLLECTION_ERROR: "RENAME_COLLECTION_ERROR",
  REMOVE_COLLECTION_ERROR: "REMOVE_COLLECTION_ERROR",
  COLLECTION_NOT_FOUND: "COLLECTION_NOT_FOUND",
  DOCUMENT_VALIDATION_ERROR: "DOCUMENT_VALIDATION_ERROR",
  S3_OPERATION_ERROR: "S3_OPERATION_ERROR",
  FIND_ERROR: "FIND_ERROR",
  FIND_ONE_ERROR: "FIND_ONE_ERROR",
  SAVE_DATA_ERROR: "SAVE_DATA_ERROR",
  INSERT_ERROR: "INSERT_ERROR",
  UPDATE_ERROR: "UPDATE_ERROR",
  UPDATE_ONE_ERROR: "UPDATE_ONE_ERROR",
  DELETE_ERROR: "DELETE_ERROR",
  COUNT_ERROR: "COUNT_ERROR",
  UNKNOWN_ERROR: "UNKNOWN_ERROR"
};
var lowstorageError = class extends Error {
  code;
  constructor(message, code = lowstorage_ERROR_CODES.UNKNOWN_ERROR) {
    super(`lowstorageError: ${message} :: code: ${code}`);
    this.name = this.constructor.name;
    this.code = code;
    Error.captureStackTrace(this, this.constructor);
  }
};
var DocumentValidationError = class extends lowstorageError {
  constructor(message, code = lowstorage_ERROR_CODES.DOCUMENT_VALIDATION_ERROR) {
    super(message, lowstorage_ERROR_CODES.DOCUMENT_VALIDATION_ERROR);
  }
};
var S3OperationError = class extends lowstorageError {
  constructor(message, operation) {
    super(`S3 ${operation} operation failed: ${message}`, lowstorage_ERROR_CODES.S3_OPERATION_ERROR);
  }
};
var MOD_NAME = "lowstorage";
var DELIMITER = "/";
var DIR_PREFIX = "lowstorage";
var COL_SUFFIX = ".mpck";
var CHUNK_5MB = 5 * 1024 * 1024;
var EMPTY_DATA = "";
var generateUUID = async () => {
  if (typeof crypto !== "undefined" && typeof crypto.randomUUID === "function") {
    return crypto.randomUUID();
  }
  const nodeCrypto = await import("node:crypto");
  if (typeof nodeCrypto.randomUUID !== "undefined" && typeof nodeCrypto.randomUUID === "function") {
    return nodeCrypto.randomUUID();
  }
  return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (c) => {
    var r = Math.random() * 16 | 0, v2 = c === "x" ? r : r & 3 | 8;
    return v2.toString(16);
  });
};
var matchesQuery = (document, query) => {
  return Object.keys(query).every((key) => document[key] === query[key]);
};
var _hasColName = (colName = "") => {
  if (colName.trim() === "" || colName === null || typeof colName === "undefined" || colName.length > 255) {
    throw new lowstorageError(`Collection name is required, null or too long`, lowstorage_ERROR_CODES.MISSING_ARGUMENT);
  }
};
var lowstorage = class {
  /**
   * Create a new lowstorage instance.
   * @param {Object} options - Configuration options for lowstorage.
   * @param {string} options.accessKeyId - S3 access key ID.
   * @param {string} options.secretAccessKey - S3 secret access key.
   * @param {string} options.endpoint - S3 endpoint URL.
   * @param {string} options.bucketName - S3 bucket name.
   * @param {string} [options.region='auto'] - S3 region.
   * @param {Object} [options.logger=null] - Logger object.
   * @param {string} [options.dirPrefix=DIR_PREFIX] - Directory prefix for collections.
   * @param {Number} [options.maxRequestSizeInBytes=CHUNK_5MB] - Chunk size for reading and writing data. AWS S3 has a minimum of 5MB per object.
   * @returns {lowstorage} A new lowstorage instance.
   */
  _s3;
  _dirPrefix;
  constructor(options) {
    this._checkArgs(options);
    this._s3 = new O(options);
    this._dirPrefix = options.dirPrefix || DIR_PREFIX;
  }
  _checkArgs = (args) => {
    const requiredFields = ["accessKeyId", "secretAccessKey", "endpoint", "bucketName"];
    for (const field of requiredFields) {
      if (!args[field]) {
        throw new lowstorageError(`${field} is required`, lowstorage_ERROR_CODES.MISSING_ARGUMENT);
      }
    }
  };
  /**
   * Check if a bucket exists.
   * @returns {Promise<boolean>} True if the bucket exists, false otherwise.
   * @throws {lowstorageError} If there's an error.
   */
  async checkIfStorageExists() {
    try {
      const exists = await this._s3.bucketExists();
      return !!exists;
    } catch (error) {
      if (error.message.includes("Not Found")) {
        return false;
      }
      throw new lowstorageError(`${error.message}`, lowstorage_ERROR_CODES.S3_OPERATION_ERROR);
    }
  }
  /**
   * Create a new storage bucket if it doesn't exist.
   * @returns {Promise<boolean>} A Promise that resolves to true if the bucket was created or already exists, false otherwise.
   * @throws {lowstorageError} If there's an error.
   */
  async createStorage() {
    try {
      const exists = await this.checkIfStorageExists();
      if (!exists) {
        const createdBucket = await this._s3.createBucket();
        return !!createdBucket;
      }
      return exists;
    } catch (error) {
      if (error instanceof lowstorageError) {
        throw error;
      }
      throw new lowstorageError(`${error.message}`, lowstorage_ERROR_CODES.S3_OPERATION_ERROR);
    }
  }
  // TODO: fix if list has more than 1000 items
  /**
   * List all collections.
   * @returns {Promise<string[]>} An array of collection names.
   * @throws {S3OperationError} If there's an error during S3 operation.
   * @throws {lowstorageError} If there's an error.
   */
  async listCollections() {
    try {
      const listed = await this._s3.list(DELIMITER, this._dirPrefix);
      if (Array.isArray(listed)) {
        const filtered = listed.filter((entry) => entry.key.endsWith(COL_SUFFIX));
        return filtered.map((entry) => entry.key.slice(this._dirPrefix.length + 1, -COL_SUFFIX.length));
      } else if (typeof listed === "object" && listed !== null && "keyCount" in listed && listed.keyCount === "0") {
        return [];
      }
      return [];
    } catch (error) {
      if (error instanceof S3OperationError) {
        throw error;
      }
      throw new lowstorageError(`${error.message}`, lowstorage_ERROR_CODES.LIST_COLLECTIONS_ERROR);
    }
  }
  /**
   * Check if a collection exists.
   * @param {string} colName - The name of the collection.
   * @returns {Promise<boolean>} True if the collection exists, false otherwise.
   * @throws {lowstorageError} If there's an error.
   */
  async collectionExists(colName = "") {
    try {
      _hasColName(colName);
      const exists = await this._s3.fileExists(`${this._dirPrefix}${DELIMITER}${colName}${COL_SUFFIX}`);
      return !!exists;
    } catch (error) {
      if (error.message.includes("Not Found")) {
        return false;
      }
      throw new lowstorageError(`${error.message}`, lowstorage_ERROR_CODES.COLLECTION_NOT_FOUND);
    }
  }
  /**
   * Create a new collection.
   * @param {string} colName - The name of the collection.
   * @param {Array} [data=[]] - The initial data for the collection.
   * @returns {Promise<Collection>} A Promise that resolves to a Collection object.
   * @throws {lowstorageError} If there's an error.
   */
  async createCollection(colName = "", data = []) {
    try {
      _hasColName(colName);
      const exists = await this.collectionExists(colName);
      if (!exists) {
        if (data.length > 0) {
          const packr = new import_index_no_eval.Packr();
          await this._s3.put(`${this._dirPrefix}${DELIMITER}${colName}${COL_SUFFIX}`, packr.pack(data));
        } else {
          await this._s3.put(`${this._dirPrefix}${DELIMITER}${colName}${COL_SUFFIX}`, EMPTY_DATA);
        }
        return this.collection(colName);
      }
      throw new lowstorageError(`Collection ${colName} already exists`, lowstorage_ERROR_CODES.COLLECTION_EXISTS);
    } catch (error) {
      throw new lowstorageError(`${error.message}`, lowstorage_ERROR_CODES.CREATE_COLLECTION_ERROR);
    }
  }
  /**
   * Remove a collection.
   * @param {string} colName - The name of the collection.
   * @returns {Promise<boolean>} A Promise that resolves to true if the collection is removed, false otherwise.
   * @throws {lowstorageError} If there's an error.
   */
  async removeCollection(colName = "") {
    try {
      _hasColName(colName);
      const deleted = await this._s3.delete(`${this._dirPrefix}${DELIMITER}${colName}${COL_SUFFIX}`);
      const exists = await this.collectionExists(colName);
      if (!deleted || exists) {
        return false;
      }
      if (deleted && !exists) {
        return true;
      }
      if (typeof exists !== "boolean") {
        throw new lowstorageError(`Failed to delete collection ${colName}`, lowstorage_ERROR_CODES.S3_OPERATION_ERROR);
      }
      throw new lowstorageError(`Collection ${colName} does not exist`, lowstorage_ERROR_CODES.REMOVE_COLLECTION_ERROR);
    } catch (error) {
      if (error instanceof S3OperationError) {
        throw error;
      }
      throw new lowstorageError(`Failed to remove collection: ${error.message}`, lowstorage_ERROR_CODES.REMOVE_COLLECTION_ERROR);
    }
  }
  /**
   * Get or create a collection.
   * @param {string} colName - The name of the collection.
   * @param {boolean} [autoCreate=true] - Whether to automatically create the collection if it doesn't exist.
   * @returns {Promise<Collection>} A Promise that resolves to a Collection object.
   * @throws {lowstorageError} If there's an error.
   */
  async collection(colName = "", autoCreate = true) {
    try {
      _hasColName(colName);
      const colPath = `${this._dirPrefix}${DELIMITER}${colName}${COL_SUFFIX}`;
      const exists = await this._s3.fileExists(colPath);
      if (!exists) {
        if (!autoCreate) {
          throw new lowstorageError(`Collection ${colName} does not exist`, lowstorage_ERROR_CODES.COLLECTION_NOT_FOUND);
        }
        await this._s3.put(colPath, EMPTY_DATA);
      }
      return new Collection(colName, this._s3, this._dirPrefix);
    } catch (error) {
      throw new lowstorageError(`${error.message}`, lowstorage_ERROR_CODES.COLLECTION_NOT_FOUND);
    }
  }
  /**
   * Get the S3 instance associated with the lowstorage instance.
   * @returns {S3} The S3 instance. Use this to perform S3 operations. Check for ultralight-s3 for more details.
   */
  s3 = () => {
    return this._s3;
  };
};
var Collection = class _Collection {
  /**
   * Create a new Collection instance.
   * @param {string} colName - The name of the collection.
   * @param {S3} s3 - The S3 instance.
   * @param {string} [dirPrefix=DIR_PREFIX] - The directory prefix for the collection.
   * @param {boolean} [safeWrite=false] - Whether to perform a safe write operation. It doublechecks the ETag of the object before writing. False = overwrites the object, True = only writes if the object has not been modified.
   * @param {Number} [chunkSize=CHUNK_5MB] - The chunk size for reading and writing data. AWS S3 has a maximum of 5MB per object.
   * @returns {Collection} A new Collection instance.
   */
  _colName;
  _s3;
  _dirPrefix;
  _chunkSize;
  _lastETag;
  _dataCache;
  _key;
  _packr;
  constructor(colName = "", s3, dirPrefix = DIR_PREFIX, chunkSize = CHUNK_5MB) {
    this._colName = colName.trim();
    this._s3 = s3;
    this._dirPrefix = dirPrefix;
    this._chunkSize = chunkSize || CHUNK_5MB;
    this._lastETag = "";
    this._s3.setMaxRequestSizeInBytes(this._chunkSize);
    this._dataCache = [];
    this._key = `${this._dirPrefix}${DELIMITER}${this._colName}${COL_SUFFIX}`;
    this._packr = new import_index_no_eval.Packr();
  }
  getProps = () => ({
    colName: this._colName,
    s3: this._s3,
    dirPrefix: this._dirPrefix,
    chunkSize: this._chunkSize
  });
  setProps = (props) => {
    this._colName = props.colName;
    this._s3 = props.s3;
    this._dirPrefix = props.dirPrefix;
    this._chunkSize = props.chunkSize;
  };
  getCollectionETag = () => {
    return this._lastETag;
  };
  async _isSameFile(key) {
    const resp = await this._s3.fileExists(this._key, { "if-match": this._lastETag });
    if (resp === null || !resp) {
      return false;
    }
    return true;
  }
  async _loadData() {
    try {
      const response = await this._s3.get(this._key, { "if-none-match": this._lastETag });
      if (response === null) {
        return this._dataCache;
      }
      const data = await response.arrayBuffer();
      const etag = this._s3.sanitizeETag(response.headers.get("etag") || response.headers.get("ETag") || "");
      this._lastETag = etag === null || etag.length === 0 ? this._lastETag : etag;
      if (data.byteLength < this._chunkSize) {
        this._dataCache = data.byteLength > 0 ? this._packr.unpack(data) : [];
        return this._dataCache;
      }
      let offset = this._chunkSize;
      let bufferArr = [Buffer.from(data)];
      let repeat = true;
      while (repeat) {
        const nextDataResponse = await this._s3.getResponse(this._key, false, offset, offset + this._chunkSize);
        const nextDataBody = await nextDataResponse.arrayBuffer();
        bufferArr.push(Buffer.from(nextDataBody));
        offset += this._chunkSize;
        const contentLength = parseInt(nextDataResponse.headers.get("content-length") || nextDataBody.byteLength.toString());
        if (contentLength < this._chunkSize) {
          repeat = false;
        }
      }
      this._dataCache = this._packr.unpack(Buffer.concat(bufferArr));
      return this._dataCache;
    } catch (error) {
      if (error.toString().indexOf("status 404: Unknown - Not Found") > -1) {
        this._dataCache = [];
        return this._dataCache;
      }
      throw new S3OperationError(`${MOD_NAME}: Failed to load data: ${error.message}`, lowstorage_ERROR_CODES.S3_OPERATION_ERROR);
    }
  }
  async _saveData(data) {
    try {
      const dataBuffer = data.length > 0 ? this._packr.pack(data) : EMPTY_DATA;
      const resp = await this._s3.put(this._key, dataBuffer);
      if (typeof resp === "object" && "status" in resp && resp.status !== 200) {
        throw new S3OperationError(`${MOD_NAME}: Failed to save data`, lowstorage_ERROR_CODES.S3_OPERATION_ERROR);
      }
      const newETag = resp.headers?.get("etag") || "";
      if (newETag && newETag.length > 0) {
        this._lastETag = this._s3.sanitizeETag(newETag);
        this._dataCache = data;
      }
      return true;
    } catch (error) {
      if (error instanceof S3OperationError || error instanceof lowstorageError) {
        throw error;
      }
      throw new lowstorageError(`${error.message}`, lowstorage_ERROR_CODES.SAVE_DATA_ERROR);
    }
  }
  /**
   * Insert a document into the collection.
   * @param {Object|Array} doc - The document to insert.
   * @returns {Promise<Array>} A Promise that resolves to the array of inserted document(s).
   * @throws {lowstorageError} If there's an error.
   */
  async insert(doc) {
    try {
      if (doc === void 0 || doc === null) {
        throw new lowstorageError(`Document is required for insert`, lowstorage_ERROR_CODES.INSERT_ERROR);
      }
      if (typeof doc !== "object" && !Array.isArray(doc)) {
        throw new DocumentValidationError(
          `${MOD_NAME}: Document must be an object or an array`,
          lowstorage_ERROR_CODES.DOCUMENT_VALIDATION_ERROR
        );
      }
      const items = !Array.isArray(doc) ? [doc] : doc;
      const data = await this._loadData();
      for (let item of items) {
        if (typeof item !== "object" || item === null) {
          throw new DocumentValidationError(
            `${MOD_NAME}: Invalid input: input must be an object or an array of objects`,
            lowstorage_ERROR_CODES.DOCUMENT_VALIDATION_ERROR
          );
        }
        item._id = item._id || await generateUUID();
        data.push(item);
      }
      const success = await this._saveData(data);
      if (!success) {
        throw new S3OperationError(`${MOD_NAME}: Failed to insert document`, lowstorage_ERROR_CODES.S3_OPERATION_ERROR);
      }
      return items;
    } catch (error) {
      throw new lowstorageError(`Insert operation failed: ${error.message}`, lowstorage_ERROR_CODES.INSERT_ERROR);
    }
  }
  /**
   * Find documents in the collection.
   * @param {Object} [query={}] - The query to filter documents.
   * @param {Object} [options={}] - The options for pagination.
   * @param {number} [options.skip=0] - The number of documents to skip. Default is 0.
   * @param {number} [options.limit=undefined] - The maximum number of documents to return. Default is undefined, which means no limit.
   * @returns {Promise<Array>} A Promise that resolves to an array of matching documents.
   * @throws {lowstorageError} If there's an error.
   */
  async find(query = {}, options = {}) {
    try {
      if (query === void 0 || query === null) {
        throw new lowstorageError(`Query is required for update`, lowstorage_ERROR_CODES.MISSING_ARGUMENT);
      }
      const data = await this._loadData();
      const start = options.skip !== void 0 ? parseInt(String(options.skip), 10) : 0;
      const end = options.limit !== void 0 ? start + parseInt(String(options.limit), 10) : void 0;
      const filteredData = data.filter((doc) => matchesQuery(doc, query)).slice(start, end);
      return filteredData;
    } catch (error) {
      throw new lowstorageError(`Find operation failed: ${error.message}`, lowstorage_ERROR_CODES.FIND_ERROR);
    }
  }
  /**
   * Find the first document in the collection that matches the query.
   * @param {Object} [query={}] - The query to filter documents.
   * @returns {Promise<Object|null>} A Promise that resolves to the first matching document or null if no match is found.
   * @throws {lowstorageError} If there's an error.
   */
  async findOne(query = {}) {
    try {
      if (query === null) {
        throw new lowstorageError(`${MOD_NAME}: Query cannot be null`, lowstorage_ERROR_CODES.INVALID_ARGUMENT);
      }
      const result = await this.find(query, { limit: 1 });
      return result[0] || null;
    } catch (error) {
      if (error instanceof lowstorageError) {
        throw error;
      }
      throw new lowstorageError(`${MOD_NAME}: FindOne operation failed: ${error.message}`, lowstorage_ERROR_CODES.FIND_ONE_ERROR);
    }
  }
  /**
   * Update a single document in the collection that matches the query.
   * @param {Object} [query={}] - The query to filter the document to update.
   * @param {Object} [update={}] - The update operations to apply to the matching document.
   * @returns {Promise<number>} A Promise that resolves to number of documents updated.
   * @throws {lowstorageError} If the updateOne operation fails.
   * @throws {DocumentValidationError} If the updated document is invalid.
   * @throws {S3OperationError} If the S3 operation fails.
   */
  async update(query = {}, update = {}, options = {}) {
    try {
      if (query === void 0 || query === null || update === void 0 || update === null) {
        throw new lowstorageError(`Query and update values are required for update`, lowstorage_ERROR_CODES.MISSING_ARGUMENT);
      }
      const data = await this._loadData();
      if (data.length === 0) return 0;
      let updatedCount = 0;
      for (let i = 0; i < data.length; i++) {
        if (matchesQuery(data[i], query)) {
          const updatedDoc = { ...data[i], ...update };
          data[i] = updatedDoc;
          updatedCount++;
        }
      }
      if (updatedCount > 0) {
        const success = await this._saveData(data);
        if (!success) {
          throw new S3OperationError(`${MOD_NAME}: Failed to update document`, lowstorage_ERROR_CODES.S3_OPERATION_ERROR);
        }
      } else if (options && "upsert" in options && options.upsert) {
        const success = await this.insert(update);
        if (!success) {
          throw new S3OperationError(`${MOD_NAME}: Failed to update document`, lowstorage_ERROR_CODES.S3_OPERATION_ERROR);
        }
        updatedCount = 1;
      }
      return updatedCount;
    } catch (error) {
      if (error instanceof S3OperationError) {
        throw error;
      }
      throw new lowstorageError(`Update operation failed: ${error.message}`, lowstorage_ERROR_CODES.UPDATE_ERROR);
    }
  }
  /**
   * Update a single document in the collection that matches the query.
   * @param {Object} [query={}] - The query to filter the document to update.
   * @param {Object} [update={}] - The update operations to apply to the matching document.
   * @returns {Promise<number>} A Promise that resolves to 1 if a document was updated, 0 otherwise.
   /**
   * Update a single document in the collection that matches the query.
   * @throws {lowstorageError} If the updateOne operation fails.
   * @throws {DocumentValidationError} If the updated document is invalid.
   * @throws {S3OperationError} If the S3 operation fails.
   */
  async updateOne(query = {}, update = {}, options = {}) {
    try {
      if (query === void 0 || query === null || update === void 0 || update === null) {
        throw new lowstorageError(`Query is required`, lowstorage_ERROR_CODES.MISSING_ARGUMENT);
      }
      const data = await this._loadData();
      if (data.length === 0) return 0;
      const docIndex = data.findIndex((doc) => matchesQuery(doc, query));
      if (docIndex !== -1) {
        const updatedDoc = { ...data[docIndex], ...update };
        data[docIndex] = updatedDoc;
        const success = await this._saveData(data);
        if (!success) {
          throw new S3OperationError(`${MOD_NAME}: Failed to update document`, lowstorage_ERROR_CODES.S3_OPERATION_ERROR);
        }
        return 1;
      }
      if (options && "upsert" in options && options.upsert) {
        const success = await this.insert(update);
        if (!success) {
          throw new S3OperationError(`${MOD_NAME}: Failed to update document`, lowstorage_ERROR_CODES.S3_OPERATION_ERROR);
        }
        return 1;
      }
      return 0;
    } catch (error) {
      throw new lowstorageError(`UpdateOne operation failed: ${error.message}`, lowstorage_ERROR_CODES.UPDATE_ONE_ERROR);
    }
  }
  /**
   * Delete documents from the collection.
   * @param {Object} [query={}] - The query to filter documents to delete.
   * @returns {Promise<number>} A Promise that resolves to the number of documents deleted.
   * @throws {lowstorageError} If the delete operation fails.
   * @throws {S3OperationError} If the S3 operation fails.
   */
  async delete(query = {}) {
    try {
      if (query === void 0 || query === null) {
        throw new lowstorageError(`Query is required`, lowstorage_ERROR_CODES.MISSING_ARGUMENT);
      }
      const data = await this._loadData();
      if (data.length === 0) return 0;
      const initialLength = data.length;
      const newData = data.filter((doc) => !matchesQuery(doc, query));
      const success = await this._saveData(newData);
      if (!success) {
        throw new S3OperationError(`${MOD_NAME}: Failed to delete document`, lowstorage_ERROR_CODES.S3_OPERATION_ERROR);
      }
      return initialLength - newData.length;
    } catch (error) {
      if (error instanceof S3OperationError) {
        throw error;
      }
      throw new lowstorageError(`Delete operation failed: ${error.message}`, lowstorage_ERROR_CODES.DELETE_ERROR);
    }
  }
  /**
   * Delete all documents from the collection.
   * @returns {Promise<number>} A Promise that resolves to the number of documents deleted.
   * @throws {lowstorageError} If the delete operation fails.
   * @throws {S3OperationError} If the S3 operation fails.
   */
  async deleteAll() {
    try {
      const data = await this._loadData();
      const initialLength = data.length;
      const success = await this._saveData([]);
      if (!success) {
        throw new S3OperationError(`${MOD_NAME}: Failed to delete document`, lowstorage_ERROR_CODES.S3_OPERATION_ERROR);
      }
      return initialLength;
    } catch (error) {
      if (error instanceof S3OperationError) {
        throw error;
      }
      throw new lowstorageError(`Delete operation failed: ${error.message}`, lowstorage_ERROR_CODES.DELETE_ERROR);
    }
  }
  /**
   * Count the number of documents in the collection.
   * @param {Object} [query={}] - The query to filter documents.
   * @returns {Promise<number>} A Promise that resolves to the number of documents in the collection.
   * @throws {lowstorageError} If the count operation fails.
   */
  async count(query = {}) {
    try {
      const data = await this.find(query);
      return data.length;
    } catch (error) {
      throw new lowstorageError(`Count operation failed: ${error.message}`, lowstorage_ERROR_CODES.COUNT_ERROR);
    }
  }
  async renameCollection(newColName) {
    try {
      _hasColName(newColName);
      const exists = await this._s3.fileExists(`${this._dirPrefix}${DELIMITER}${newColName}${COL_SUFFIX}`);
      if (!!exists) {
        throw new lowstorageError(`${MOD_NAME}: Collection ${newColName} already exists`, lowstorage_ERROR_CODES.COLLECTION_EXISTS);
      }
      const data = await this._loadData();
      const createNew = new _Collection(newColName, this._s3, this._dirPrefix, this._chunkSize);
      await createNew._saveData(data);
      await this._s3.delete(`${this._dirPrefix}${DELIMITER}${this._colName}${COL_SUFFIX}`);
      return createNew;
    } catch (error) {
      if (error instanceof lowstorageError) {
        throw error;
      }
      throw new lowstorageError(`Rename collection failed: ${error.message}`, lowstorage_ERROR_CODES.RENAME_COLLECTION_ERROR);
    }
  }
};
export {
  lowstorage,
  lowstorageError,
  lowstorage_ERROR_CODES
};
