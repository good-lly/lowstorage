var se=crypto.createHmac||(await import("node:crypto")).createHmac,ie=crypto.createHash||(await import("node:crypto")).createHash;typeof se>"u"&&typeof ie>"u"&&console.error("ultralight-S3 Module: Crypto functions are not available, please report the issue with necessary description: https://github.com/sentienhq/ultralight-s3/issues");var V="AWS4-HMAC-SHA256",B="aws4_request",F="s3",ue="2",g="UNSIGNED-PAYLOAD",de="application/octet-stream",z="application/xml",L="application/json",fe=["accessKeyId","secretAccessKey","sessionToken","password"],Q=5*1024*1024,E="x-amz-content-sha256",pe="x-amz-date",_e="host",Re="Authorization",O="Content-Type",b="Content-Length",X="etag",W="last-modified",d="ultralight-s3 Module: ",ge=`${d}accessKeyId must be a non-empty string`,Ee=`${d}secretAccessKey must be a non-empty string`,we=`${d}endpoint must be a non-empty string`,ye=`${d}bucketName must be a non-empty string`,Y=`${d}key must be a non-empty string`,x=`${d}uploadId must be a non-empty string`,J=`${d}parts must be a non-empty array`,Z=`${d}Each part must have a partNumber (number) and ETag (string)`,M=`${d}data must be a Buffer or string`,ee=`${d}prefix must be a string`,te=`${d}maxKeys must be a positive integer`,re=`${d}delimiter must be a string`,me={contents:!0},Oe=r=>`%${r.charCodeAt(0).toString(16).toUpperCase()}`,K=r=>encodeURIComponent(r).replace(/[!'()*]/g,Oe),m=r=>K(r).replace(/%2F/g,"/"),ae=class{constructor({accessKeyId:r,secretAccessKey:e,endpoint:t,bucketName:s,region:i="auto",maxRequestSizeInBytes:a=Q,requestAbortTimeout:n=void 0,logger:h=void 0}){this.getBucketName=()=>this.bucketName,this.setBucketName=o=>{this.bucketName=o},this.getRegion=()=>this.region,this.setRegion=o=>{this.region=o},this.getEndpoint=()=>this.endpoint,this.setEndpoint=o=>{this.endpoint=o},this.getMaxRequestSizeInBytes=()=>this.maxRequestSizeInBytes,this.setMaxRequestSizeInBytes=o=>{this.maxRequestSizeInBytes=o},this.getProps=()=>({accessKeyId:this.accessKeyId,secretAccessKey:this.secretAccessKey,region:this.region,bucket:this.bucketName,endpoint:this.endpoint,maxRequestSizeInBytes:this.maxRequestSizeInBytes,requestAbortTimeout:this.requestAbortTimeout,logger:this.logger}),this.setProps=o=>{this._validateConstructorParams(o.accessKeyId,o.secretAccessKey,o.bucketName,o.endpoint),this.accessKeyId=o.accessKeyId,this.secretAccessKey=o.secretAccessKey,this.region=o.region||"auto",this.bucketName=o.bucketName,this.endpoint=o.endpoint,this.maxRequestSizeInBytes=o.maxRequestSizeInBytes||Q,this.requestAbortTimeout=o.requestAbortTimeout,this.logger=o.logger},this._validateConstructorParams(r,e,t,s),this.accessKeyId=r,this.secretAccessKey=e,this.endpoint=t,this.bucketName=s,this.region=i,this.maxRequestSizeInBytes=a,this.requestAbortTimeout=n,this.logger=h}_validateConstructorParams(r,e,t,s){if(typeof r!="string"||r.trim().length===0)throw new TypeError(ge);if(typeof e!="string"||e.trim().length===0)throw new TypeError(Ee);if(typeof t!="string"||t.trim().length===0)throw new TypeError(we);if(typeof s!="string"||s.trim().length===0)throw new TypeError(ye)}_checkMethodHeadnGet(r){if(r!=="GET"&&r!=="HEAD")throw this._log("error",`${d}method must be either GET or HEAD`),new Error("method must be either GET or HEAD")}_checkKey(r){if(typeof r!="string"||r.trim().length===0)throw this._log("error",Y),new TypeError(Y)}_checkDelimiter(r){if(typeof r!="string"||r.trim().length===0)throw this._log("error",re),new TypeError(re)}_checkPrefix(r){if(typeof r!="string")throw this._log("error",ee),new TypeError(ee)}_checkMaxKeys(r){if(typeof r!="number"||r<=0)throw this._log("error",te),new TypeError(te)}_checkOpts(r){if(typeof r!="object")throw this._log("error",`${d}opts must be an object`),new TypeError(`${d}opts must be an object`)}_log(r,e,t={}){if(this.logger&&typeof this.logger[r]=="function"){let s=n=>typeof n!="object"||n===null?n:Object.keys(n).reduce((h,o)=>(fe.includes(o.toLowerCase())?h[o]="[REDACTED]":typeof n[o]=="object"&&n[o]!==null?h[o]=s(n[o]):h[o]=n[o],h),Array.isArray(n)?[]:{}),i=s(t),a={timestamp:new Date().toISOString(),level:r,message:e,...i,context:s({bucketName:this.bucketName,region:this.region,endpoint:this.endpoint,accessKeyId:this.accessKeyId?`${this.accessKeyId.substring(0,4)}...`:void 0})};this.logger[r](a)}}async getContentLength(r){this._checkKey(r);let e={[E]:g},t=m(r),{url:s,headers:i}=await this._sign("HEAD",t,{},e,""),a=(await this._sendRequest(s,"HEAD",i)).headers.get(b);return a?parseInt(a,10):0}async bucketExists(){let r={[E]:g},{url:e,headers:t}=await this._sign("HEAD","",{},r,""),s=await this._sendRequest(e,"HEAD",t);return!!(s.ok&&s.status===200)}async fileExists(r){this._checkKey(r);let e={[E]:g},t=m(r),{url:s,headers:i}=await this._sign("HEAD",t,{},e,"");try{let a=await fetch(s,{method:"HEAD",headers:i});return a.ok&&a.status===200?!0:(a.status===404||this._handleErrorResponse(a),!1)}catch(a){let n=a instanceof Error?a.message:String(a);throw this._log("error",`${d}Failed to check if file exists: ${n}`),new Error(`${d}Failed to check if file exists: ${n}`)}}async _sign(r,e,t,s,i){let a=new Date().toISOString().replace(/[:-]|\.\d{3}/g,""),n=typeof e=="string"&&e.length>0?new URL(e,this.endpoint):new URL(this.endpoint);n.pathname=`/${encodeURI(this.bucketName)}${n.pathname}`,s[E]=i?await k(i):g,s[pe]=a,s[_e]=n.host;let h=this._buildCanonicalHeaders(s),o=Object.keys(s).map(y=>y.toLowerCase()).sort().join(";"),u=await this._buildCanonicalRequest(r,n,t,h,o,i),p=await this._buildStringToSign(a,u),_=await this._calculateSignature(a,p),w=this._buildAuthorizationHeader(a,o,_);return s[Re]=w,{url:n.toString(),headers:s}}_buildCanonicalHeaders(r){return Object.entries(r).map(([e,t])=>`${e.toLowerCase()}:${String(t).trim()}`).sort().join(`
`)}async _buildCanonicalRequest(r,e,t,s,i,a){return[r,e.pathname,this._buildCanonicalQueryString(t),`${s}
`,i,a?await k(a):g].join(`
`)}async _buildStringToSign(r,e){let t=[r.slice(0,8),this.region,F,B].join("/");return[V,r,t,await k(e)].join(`
`)}async _calculateSignature(r,e){let t=await this._getSignatureKey(r.slice(0,8));return U(t,e,"hex")}_buildAuthorizationHeader(r,e,t){let s=[r.slice(0,8),this.region,F,B].join("/");return[`${V} Credential=${this.accessKeyId}/${s}`,`SignedHeaders=${e}`,`Signature=${t}`].join(", ")}async list(r="/",e="",t=1e3,s="GET",i={}){this._checkDelimiter(r),this._checkPrefix(e),this._checkMaxKeys(t),this._checkMethodHeadnGet(s),this._checkOpts(i),this._log("info",`Listing objects in ${e}`);let a={"list-type":ue,"max-keys":String(t),...i};e.length>0&&(a.prefix=e);let n={[O]:L,[E]:g},h=r==="/"?r:K(r),{url:o,headers:u}=await this._sign("GET",h,a,n,""),p=`${o}?${new URLSearchParams(a)}`,_=await this._sendRequest(p,"GET",u),w=await _.text();if(s==="HEAD"){let N=_.headers.get(b),C=_.headers.get(W),le=_.headers.get(X);return{size:N?+N:void 0,mtime:C?new Date(C):void 0,ETag:le||void 0}}let y=D(w),v=y.listBucketResult||y.error||y;return v.contents||v}async listMultiPartUploads(r="/",e="",t="GET",s={}){var i,a,n;this._checkDelimiter(r),this._checkPrefix(e),this._checkMethodHeadnGet(t),this._checkOpts(s),this._log("info",`Listing multipart uploads in ${e}`);let h={uploads:"",...s},o={[O]:L,[E]:g},u=r==="/"?r:K(r),{url:p,headers:_}=await this._sign("GET",u,h,o,""),w=`${p}?${new URLSearchParams(h)}`,y=await this._sendRequest(w,"GET",_),v=await y.text();if(t==="HEAD")return{size:+((i=y.headers.get(b))!==null&&i!==void 0?i:"0"),mtime:new Date((a=y.headers.get(W))!==null&&a!==void 0?a:""),ETag:(n=y.headers.get(X))!==null&&n!==void 0?n:""};let N=D(v),C=N.listMultipartUploadsResult||N.error||N;return C.uploads||C}async get(r,e={}){this._checkKey(r),this._log("info",`Getting object ${r}`);let t={[O]:L,[E]:g},s=m(r),{url:i,headers:a}=await this._sign("GET",s,e,t,"");return(await this._sendRequest(i,"GET",a)).text()}async getResponse(r,e=!0,t=0,s=this.maxRequestSizeInBytes,i={}){this._checkKey(r);let a=i,n={[O]:L,[E]:g,...e?{}:{range:`bytes=${t}-${s-1}`}},h=m(r),{url:o,headers:u}=await this._sign("GET",h,a,n,""),p=`${o}?${new URLSearchParams(a)}`;return this._sendRequest(p,"GET",u)}async put(r,e){if(this._checkKey(r),!(e instanceof Buffer||typeof e=="string"))throw this._log("error",M),new TypeError(M);this._log("info",`Uploading object ${r}`);let t=typeof e=="string"?Buffer.byteLength(e):e.length,s={[b]:t},i=m(r),{url:a,headers:n}=await this._sign("PUT",i,{},s,e);return await this._sendRequest(a,"PUT",n,e)}async getMultipartUploadId(r,e=de){if(this._checkKey(r),typeof e!="string")throw this._log("error",`${d}fileType must be a string`),new TypeError(`${d}fileType must be a string`);this._log("info",`Initiating multipart upload for object ${r}`);let t={uploads:""},s={[O]:e,[E]:g},i=m(r),{url:a,headers:n}=await this._sign("POST",i,t,s,""),h=`${a}?${new URLSearchParams(t)}`,o=await(await this._sendRequest(h,"POST",n)).text(),u=D(o);if(typeof u=="object"&&u!==null&&"error"in u&&typeof u.error=="object"&&u.error!==null&&"message"in u.error){let p=String(u.error.message);throw this._log("error",`${d}Failed to abort multipart upload: ${p}`),new Error(`${d}Failed to abort multipart upload: ${p}`)}if(typeof u=="object"&&u!==null){if(!u.initiateMultipartUploadResult||!u.initiateMultipartUploadResult.uploadId)throw this._log("error",`${d}Failed to create multipart upload: no uploadId in response`),new Error(`${d}Failed to create multipart upload: Missing upload ID in response`);return u.initiateMultipartUploadResult.uploadId}else throw this._log("error",`${d}Failed to create multipart upload: unexpected response format`),new Error(`${d}Failed to create multipart upload: Unexpected response format`)}async uploadPart(r,e,t,s,i={}){this._validateUploadPartParams(r,e,t,s,i);let a={uploadId:t,partNumber:s,...i},n={[b]:e.length},h=m(r),{url:o,headers:u}=await this._sign("PUT",h,a,n,e),p=`${o}?${new URLSearchParams(a)}`,_=(await this._sendRequest(p,"PUT",u,e)).headers.get("etag")||"";return{partNumber:s,ETag:_}}_validateUploadPartParams(r,e,t,s,i){if(this._checkKey(r),!(e instanceof Buffer||typeof e=="string"))throw this._log("error",M),new TypeError(M);if(typeof t!="string"||t.trim().length===0)throw this._log("error",x),new TypeError(x);if(!Number.isInteger(s)||s<=0)throw this._log("error",`${d}partNumber must be a positive integer`),new TypeError(`${d}partNumber must be a positive integer`);this._checkOpts(i)}async completeMultipartUpload(r,e,t){if(this._checkKey(r),typeof e!="string"||e.trim().length===0)throw this._log("error",x),new TypeError(x);if(!Array.isArray(t)||t.length===0)throw this._log("error",J),new TypeError(J);if(!t.every(w=>typeof w.partNumber=="number"&&typeof w.ETag=="string"))throw this._log("error",Z),new TypeError(Z);this._log("info",`Complete multipart upload ${e} for object ${r}`);let s={uploadId:e},i=this._buildCompleteMultipartUploadXml(t),a={[O]:z,[b]:Buffer.byteLength(i).toString(),[E]:await k(i)},n=m(r),{url:h,headers:o}=await this._sign("POST",n,s,a,i),u=`${h}?${new URLSearchParams(s)}`,p=await(await this._sendRequest(u,"POST",o,i)).text(),_=D(p);if(typeof _=="object"&&_!==null&&"error"in _&&typeof _.error=="object"&&_.error!==null&&"message"in _.error){let w=String(_.error.message);throw this._log("error",`${d}Failed to abort multipart upload: ${w}`),new Error(`${d}Failed to abort multipart upload: ${w}`)}return _.completeMultipartUploadResult}async abortMultipartUpload(r,e){if(this._checkKey(r),typeof e!="string"||e.trim().length===0)throw this._log("error",x),new TypeError(x);this._log("info",`Aborting multipart upload ${e} for object ${r}`);let t={uploadId:e},s={[O]:z,[E]:g};try{let i=m(r),{url:a,headers:n}=await this._sign("DELETE",i,t,s,""),h=`${a}?${new URLSearchParams(t)}`,o=await this._sendRequest(h,"DELETE",n);if(o.ok){let u=await o.text(),p=D(u);if(typeof p=="object"&&p!==null&&"error"in p&&typeof p.error=="object"&&p.error!==null&&"message"in p.error){let _=String(p.error.message);throw this._log("error",`${d}Failed to abort multipart upload: ${_}`),new Error(`${d}Failed to abort multipart upload: ${_}`)}return{status:"Aborted",key:r,uploadId:e,response:p}}else throw this._log("error",`${d}Abort request failed with status ${o.status}`),new Error(`${d}Abort request failed with status ${o.status}`)}catch(i){let a=i instanceof Error?i.message:String(i);throw this._log("error",`${d}Failed to abort multipart upload for key ${r}: ${a}`),new Error(`${d}Failed to abort multipart upload for key ${r}: ${a}`)}}_buildCompleteMultipartUploadXml(r){return`
      <CompleteMultipartUpload>
        ${r.map(e=>`
          <Part>
            <PartNumber>${e.partNumber}</PartNumber>
            <ETag>${e.ETag}</ETag>
          </Part>
        `).join("")}
      </CompleteMultipartUpload>
    `}async delete(r){this._checkKey(r),this._log("info",`Deleting object ${r}`);let e={[O]:L,[E]:g},t=m(r),{url:s,headers:i}=await this._sign("DELETE",t,{},e,"");return(await this._sendRequest(s,"DELETE",i)).text()}async _sendRequest(r,e,t,s){this._log("info",`Sending ${e} request to ${r}, headers: ${JSON.stringify(t)}`);let i=await fetch(r,{method:e,headers:t,body:s,signal:this.requestAbortTimeout!==void 0?AbortSignal.timeout(this.requestAbortTimeout):void 0});return i.ok||await this._handleErrorResponse(i),i}async _handleErrorResponse(r){let e=await r.text(),t=r.headers.get("x-amz-error-code")||"Unknown",s=r.headers.get("x-amz-error-message")||r.statusText;throw this._log("error",`${d}Request failed with status ${r.status}: ${t} - ${s},err body: ${e}`),new Error(`${d}Request failed with status ${r.status}: ${t} - ${s}, err body: ${e}`)}_buildCanonicalQueryString(r){return Object.keys(r).length<1?"":Object.keys(r).sort().map(e=>`${encodeURIComponent(e)}=${encodeURIComponent(r[e])}`).join("&")}async _getSignatureKey(r){let e=await U(`AWS4${this.secretAccessKey}`,r),t=await U(e,this.region),s=await U(t,F);return U(s,B)}},k=async r=>{let e=ie("sha256");return e.update(r),e.digest("hex")},U=async(r,e,t)=>{let s=se("sha256",r);return s.update(e),s.digest(t)},D=r=>{let e=a=>a.replace(/&quot;/g,'"').replace(/&apos;/g,"'").replace(/&lt;/g,"<").replace(/&gt;/g,">").replace(/&amp;/g,"&"),t={},s=/<(\w)([-\w]+)(?:\/|[^>]*>((?:(?!<\1)[\s\S])*)<\/\1\2)>/gm,i;for(;i=s.exec(r);){let[,a,n,h]=i,o=a.toLowerCase()+n,u=h!=null?D(h):!0;typeof u=="string"?t[o]=e(u):Array.isArray(t[o])?t[o].push(u):t[o]=t[o]!=null?[t[o],u]:me[o]?[u]:u}return Object.keys(t).length?t:e(r)};import he from"avro-js";var c={MISSING_ARGUMENT:"MISSING_ARGUMENT",COLLECTION_EXISTS:"COLLECTION_EXISTS",CREATE_COLLECTION_ERROR:"CREATE_COLLECTION_ERROR",RENAME_COLLECTION_ERROR:"RENAME_COLLECTION_ERROR",REMOVE_COLLECTION_ERROR:"REMOVE_COLLECTION_ERROR",UPDATE_COLLECTION_SCHEMA_ERROR:"UPDATE_COLLECTION_SCHEMA_ERROR",COLLECTION_NOT_FOUND:"COLLECTION_NOT_FOUND",SCHEMA_VALIDATION_ERROR:"SCHEMA_VALIDATION_ERROR",DOCUMENT_VALIDATION_ERROR:"DOCUMENT_VALIDATION_ERROR",S3_OPERATION_ERROR:"S3_OPERATION_ERROR",FIND_ERROR:"FIND_ERROR",FIND_ONE_ERROR:"FIND_ONE_ERROR",SAVE_DATA_ERROR:"SAVE_DATA_ERROR",INSERT_ERROR:"INSERT_ERROR",UPDATE_ERROR:"UPDATE_ERROR",UPDATE_ONE_ERROR:"UPDATE_ONE_ERROR",DELETE_ERROR:"DELETE_ERROR",COUNT_ERROR:"COUNT_ERROR",UNKNOWN_ERROR:"UNKNOWN_ERROR"},f=class extends Error{constructor(e,t=c.UNKNOWN_ERROR){super(`lowstorageError: ${e} :: code: ${t}`),this.name=this.constructor.name,this.code=t,Error.captureStackTrace(this,this.constructor)}},P=class extends f{constructor(e){super(`Collection ${e} not found`,c.COLLECTION_NOT_FOUND)}},$=class extends f{constructor(e){super(e,c.SCHEMA_VALIDATION_ERROR)}},T=class extends f{constructor(e){super(e,c.DOCUMENT_VALIDATION_ERROR)}},R=class extends f{constructor(e,t){super(`S3 ${t} operation failed: ${e}`,c.S3_OPERATION_ERROR)}};import{randomUUID as j}from"node:crypto";var S=(r,e)=>Object.keys(e).every(t=>r[t]===e[t]),oe=async()=>typeof j<"u"&&typeof j=="function"?j():typeof crypto<"u"&&typeof crypto=="object"&&typeof crypto.randomUUID=="function"?crypto.randomUUID():"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g,function(r){var e=Math.random()*16|0,t=r==="x"?e:e&3|8;return t.toString(16)}),ne=(r,e="SubAutoGenerated")=>{switch(typeof r){case"string":return $e(r)?{type:"string",name:"_id",size:16,logicalType:"UUID"}:"string";case"number":return Number.isInteger(r)?"int":"float";case"boolean":return"boolean";case"object":return r===null?"null":Array.isArray(r)?{type:"array",items:ne(r[0])}:q(r,e);default:return"string"}},q=(r,e="AutoGenerated")=>{Array.isArray(r)&&(r=r[0]);let t=Object.entries(r).map(([s,i])=>({name:s,type:ne(i,`${e}.${s}`)}));return{type:"record",name:e,fields:t}},$e=r=>/^[0-9A-F]{8}-[0-9A-F]{4}-4[0-9A-F]{3}-[89AB][0-9A-F]{3}-[0-9A-F]{12}$/i.test(r);var l="lowstorage",I="/",G="lowstorage",A=".avro",Te=1024*1024,Ie=5*Te,ce=class{constructor(e={accessKeyId:void 0,secretAccessKey:void 0,endpoint:void 0,bucketName:void 0,region:"auto",logger:null,dirPrefix:G}){this._checkArgs(e),this._schemas=new Map,this._s3=new ae(e),this._dirPrefix=e.dirPrefix||G,this._avro=he}_checkArgs=e=>{let t=["accessKeyId","secretAccessKey","endpoint","bucketName"];for(let s of t)if(!e[s])throw new f(`${l}: ${s} is required`,c.MISSING_ARGUMENT)};_hasColName=e=>{if(e.trim()===""||e===null||typeof e>"u")throw new f(`${l}: Collection name is required`,c.MISSING_ARGUMENT)};async listCollections(){try{let e=await this._s3.list(I,this._dirPrefix);return typeof e=="object"&&e!==null&&e.keyCount==="0"?[]:e.map(t=>t.key.slice(this._dirPrefix.length+1,-A.length))}catch(e){throw new R(`${l}: ${e.message}`,c.S3_OPERATION_ERROR)}}async collectionExists(e){try{return this._hasColName(e),await this._s3.fileExists(`${this._dirPrefix}${I}${e}${A}`)}catch(t){if(t.message.includes("Not Found"))return!1;throw new f(`${l}: ${t.message}`,c.COLLECTION_NOT_FOUND)}}async createCollection(e,t,s=[]){try{if(this._hasColName(e),!await this.collectionExists(e))return await this._s3.put(`${this._dirPrefix}${I}${e}${A}`,s.length>0?s:""),this.collection(e,t);throw new f(`${l}: Collection ${e} already exists`,c.COLLECTION_EXISTS)}catch(i){throw i instanceof f?i:new f(`${l}: ${i.message}`,c.CREATE_COLLECTION_ERROR)}}async removeCollection(e){try{this._hasColName(e);let t=`${this._dirPrefix}${I}${e}${A}`;if(await this.collectionExists(e)){await this._s3.delete(t);let i=await this.collectionExists(e);if(typeof i=="boolean")return!i;throw new R(`${l}: Failed to delete collection ${e}`,c.S3_OPERATION_ERROR)}throw new f(`${l}: Collection ${e} does not exist`,c.REMOVE_COLLECTION_ERROR)}catch(t){throw t instanceof R?t:new f(`${l}: Failed to remove collection: ${t.message}`,c.REMOVE_COLLECTION_ERROR)}}async renameCollection(e,t){try{if(this._hasColName(e),this._hasColName(t),!await this.collectionExists(e))throw new P(`${l}: Collection ${e} does not exist`,c.COLLECTION_NOT_FOUND);let i=await this.collection(e),a=await i._loadDataBuffer();if(!await this.removeCollection(e))throw new f(`${l}: Failed to rename collection`,c.RENAME_COLLECTION_ERROR);return await this.createCollection(t,i._avroType,a)}catch(s){throw s instanceof f?s:new f(`${l}: Rename collection failed: ${s.message}`,c.RENAME_COLLECTION_ERROR)}}async collection(e,t,s=!0){try{this._hasColName(e);let i=`${this._dirPrefix}${I}${e}${A}`,a,n=await this._s3.fileExists(i);if(!n&&!s)throw new f(`${l}: Collection ${e} does not exist`,c.COLLECTION_NOT_FOUND);if(t)a=this._avro.parse(t),this._schemas.set(e,a),!n&&s&&await this._s3.put(i,"");else if(this._schemas.has(e))a=this._schemas.get(e);else if(n){let h=await this._s3.get(i);a=this._avro.parse(h),this._schemas.set(e,a)}else s&&await this._s3.put(i,"");return new H(e,this._s3,a,this._dirPrefix)}catch(i){throw i.message.includes("unknown type")?new $(`${l}: Schema input is invalid: ${i.message}`,c.SCHEMA_VALIDATION_ERROR):new f(`${l}: ${i.message}`,c.COLLECTION_NOT_FOUND)}}s3=()=>this._s3},H=class{constructor(e,t,s=void 0,i=G){this._colName=e,this._s3=t,this._avro=he,this._avroType=s,this._dirPrefix=i}async insert(e,t=void 0){try{if(e==null)throw new f(`${l}: Document is required for insert`,c.INSERT_ERROR);if(typeof e!="object"&&!Array.isArray(e))throw new T(`${l}: Document must be an object or an array`,c.DOCUMENT_VALIDATION_ERROR);let s=Array.isArray(e)?e:[e],i=t?this._avro.parse(t):this._avroType||this._avro.parse(q(e));if(!i)throw new $(`${l}: Schema is required - Pass a schema to the insert method`,c.SCHEMA_VALIDATION_ERROR);this._avroType=i;let a=this._avro.parse({type:"array",items:this._avroType}),n=await this._loadDataBuffer(),h=n.length>0?a.fromBuffer(n):[];for(let u of s){if(typeof u!="object"||u===null)throw new T(`${l}: Invalid input: input must be an object or an array of objects`,c.DOCUMENT_VALIDATION_ERROR);if(u._id=u._id||await oe(),!this._avroType.isValid(u))throw new T(`${l}: Invalid document or schema`,c.DOCUMENT_VALIDATION_ERROR);h.push(u)}if(!await this._saveDataBuffer(a.toBuffer(h)))throw new R(`${l}: Failed to insert document`,c.S3_OPERATION_ERROR);return s}catch(s){throw s.message.includes("unknown type")?new $(`${l}: Schema input is invalid: ${s.message}`,c.SCHEMA_VALIDATION_ERROR):s instanceof f?s:new f(`${l} Insert operation failed: ${s.message}`,c.INSERT_ERROR)}}async _loadDataBuffer(){try{let e=`${this._dirPrefix}${I}${this._colName}${A}`,t=this._s3.getMaxRequestSizeInBytes()||Ie,s=await this._s3.get(e);if(s.length<t)return Buffer.from(s,"utf8");let i=t,a=[Buffer.from(s,"utf8")],n=!0;for(;n;){let h=await this._s3.getResponse(e,!1,i,i+t),o=await h.text();a.push(Buffer.from(o,"utf8")),i+=t,(h.headers.get("content-length")||o.length)<t&&(n=!1)}return Buffer.concat(a)}catch(e){if(e.toString().indexOf("status 404: Unknown - Not Found")>-1)return Buffer.from("");throw new R(`${l}: Failed to load data buffer: ${e.message}`,c.S3_OPERATION_ERROR)}}async _saveDataBuffer(e){try{let t=`${this._dirPrefix}${I}${this._colName}${A}`;if((await this._s3.put(t,e)).status!==200)throw new R(`${l}: Failed to save data`,c.S3_OPERATION_ERROR);return!0}catch(t){throw t instanceof R?t:new f(`${l}: ${t.message}`,c.SAVE_DATA_ERROR)}}async find(e={},t={}){try{if(e==null)throw new f(`${l}: Query is required for update`,c.MISSING_ARGUMENT);let s=await this._loadDataBuffer();if(s.length===0)return[];let i=this._avro.parse({type:"array",items:this._avroType}),a=s.length>0?i.fromBuffer(s):[],n=parseInt(t.skip,10)||0,h=parseInt(t.limit,10)?n+parseInt(t.limit,10):void 0;return a.filter(u=>S(u,e)).slice(n,h)}catch(s){throw new f(`${l}: Find operation failed: ${s.message}`,c.FIND_ERROR)}}async findOne(e={}){try{if(e==null)throw new f(`${l}: Query is required for update`,c.MISSING_ARGUMENT);return(await this.find(e))[0]||[]}catch(t){throw new f(`${l}: FindOne operation failed: ${t.message}`,c.FIND_ONE_ERROR)}}async update(e={},t={}){try{if(e==null||t===void 0||t===null)throw new f(`${l}: Query is required for update`,c.MISSING_ARGUMENT);if(!this._avroType)throw new $(`${l}: Schema is not defined for this collection`,c.SCHEMA_VALIDATION_ERROR);let s=await this._loadDataBuffer();if(s.length===0)return 0;let i=this._avro.parse({type:"array",items:this._avroType}),a=s.length>0?i.fromBuffer(s):[],n=0;for(let h=0;h<a.length;h++)if(S(a[h],e)){let o={...a[h],...t};if(!this._avroType.isValid(o))throw new T(`${l}: Invalid document or schema`,c.DOCUMENT_VALIDATION_ERROR);a[h]=o,n++}if(n>0&&!await this._saveDataBuffer(i.toBuffer(a)))throw new R(`${l}: Failed to update document`,c.S3_OPERATION_ERROR);return n}catch(s){throw s instanceof R?s:new f(`${l}: Update operation failed: ${s.message}`,c.UPDATE_ERROR)}}async updateOne(e={},t={}){try{if(e==null||t===void 0||t===null)throw new f(`${l}: Query is required`,c.MISSING_ARGUMENT);if(!this._avroType)throw new $(`${l}: Schema is not defined for this collection`,c.SCHEMA_VALIDATION_ERROR);let s=await this._loadDataBuffer();if(s.length===0)return 0;let i=this._avro.parse({type:"array",items:this._avroType}),a=s.length>0?i.fromBuffer(s):[],n=a.findIndex(h=>S(h,e));if(n!==-1){let h={...a[n],...t};if(!this._avroType.isValid(h))throw new T(`${l}: Invalid document or schema`,c.DOCUMENT_VALIDATION_ERROR);if(a[n]=h,!await this._saveDataBuffer(i.toBuffer(a)))throw new R(`${l}: Failed to update document`,c.S3_OPERATION_ERROR);return 1}return 0}catch(s){throw s instanceof f?s:new f(`${l}: UpdateOne operation failed: ${s.message}`,c.UPDATE_ONE_ERROR)}}async delete(e={}){try{if(e==null)throw new f(`${l}: Query is required`,c.MISSING_ARGUMENT);let t=await this._loadDataBuffer();if(t.length===0)return 0;let s=this._avro.parse({type:"array",items:this._avroType}),i=t.length>0?s.fromBuffer(t):[],a=i.length,n=i.filter(o=>!S(o,e));if(!await this._saveDataBuffer(s.toBuffer(n)))throw new R(`${l}: Failed to delete document`,c.S3_OPERATION_ERROR);return a-n.length}catch(t){throw t instanceof R?t:new f(`${l}: Delete operation failed: ${t.message}`,c.DELETE_ERROR)}}async deleteAll(){try{let e=await this._loadDataBuffer();if(e.length===0)return 0;let t=this._avro.parse({type:"array",items:this._avroType}),s=e.length>0?t.fromBuffer(e):[],i=s.length,a=s.filter(h=>!S(h,{}));if(!await this._saveDataBuffer(t.toBuffer(a)))throw new R(`${l}: Failed to delete document`,c.S3_OPERATION_ERROR);return i-a.length}catch(e){throw e instanceof R?e:new f(`${l}: Delete operation failed: ${e.message}`,c.DELETE_ERROR)}}async count(e={}){try{return(await this.find(e)).length}catch(t){throw new f(`${l}: Count operation failed: ${t.message}`,c.COUNT_ERROR)}}};export{ce as lowstorage,f as lowstorageError,c as lowstorage_ERROR_CODES};
//# sourceMappingURL=lowstorage.js.map
