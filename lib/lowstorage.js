"use strict";var l=Object.defineProperty;var $=Object.getOwnPropertyDescriptor;var m=Object.getOwnPropertyNames;var p=Object.prototype.hasOwnProperty;var y=(o,t)=>{for(var s in t)l(o,s,{get:t[s],enumerable:!0})},w=(o,t,s,e)=>{if(t&&typeof t=="object"||typeof t=="function")for(let r of m(t))!p.call(o,r)&&r!==s&&l(o,r,{get:()=>t[r],enumerable:!(e=$(t,r))||e.enumerable});return o};var N=o=>w(l({},"__esModule",{value:!0}),o);var D={};y(D,{default:()=>a});module.exports=N(D);var c="____";function g(...o){for(let t of o)if(typeof t!="object")throw new Error("lowstorage: missing args or args not an object")}function j(o,t){return Object.keys(t).every(s=>o[s]===t[s])}function h(){return crypto.randomUUID()}function b(o,t=null){let s=null;if(t){if(s=o[t],s.get&&s.put&&s.delete&&s.list)return s;throw new Error(`lowstorage: store ${t} not found`)}for(let e of Object.values(o))if(e.get&&e.put&&e.delete&&e.list)return e;throw new Error("lowstorage: no valid store found")}var u=class{constructor(t,s){this._colName=t,this._store=s}async insert(t){if(Array.isArray(t)){let s=t.map(async e=>{e._id=e._id||h();let r=`${this.this._colName}/${this._colName}${c}${e._id}`;return this._store.put(r,JSON.stringify(e))});return Promise.all(s)}if(typeof t=="object"&&t!==null){t._id=t._id||h();let s=`${this.this._colName}/${this.this._colName}${c}${t._id}`;return this._store.put(s,JSON.stringify(t))}throw new Error("Invalid input: input must be an object or an array of objects")}async find(t={}){if(t._id){let i=await this._store.get(`${this._colName}/${this._colName}${c}${t._id}`);return i?[await i.json()]:[]}let s=await this._store.list({prefix:`${this._colName}/${this._colName}${c}`}),e=s.truncated,r=e?s.cursor:void 0;for(;e;){let i=await this._store.list({prefix:`${this._colName}/${this._colName}${c}`,cursor:r});s.objects.push(...i.objects),e=i.truncated,r=i.cursor}let n=s.objects.map(async i=>(await this._store.get(`${i.key}`)).json());return(await Promise.all(n)).filter(i=>j(i,t))}async findOne(t={}){return(await this.find(t))[0]}async update(t={},s={}){let r=(await this.find(t)).map(async n=>{let d={...n,...s},_=`${this._colName}/${this._colName}${c}${n._id}`;return this._store.put(_,JSON.stringify(d))});return Promise.all(r)}async updateOne(t={},s={}){let e=await this.findOne(t),r={...e,...s},n=`${this._colName}/${this._colName}${c}${e._id}`;return this._store.put(n,JSON.stringify(r))}async delete(t={}){let e=(await this.find(t)).map(async r=>{let n=`${this._colName}/${this._colName}${c}${r._id}`;return this._store.delete(n)});return Promise.all(e)}},a=class{constructor(t,s){g(t),this._store=b(t,s)}collection(t){return new u(t,this._store)}};
