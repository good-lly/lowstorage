var c=(...e)=>{for(let t of e)if(typeof t!="object"||t===null)throw new Error("lowstorage: missing args or args not an object")},i=(e,t)=>Object.keys(t).every(a=>e[a]===t[a]),h=()=>crypto.randomUUID(),_=(e,t=null)=>{let a=null;if(t){if(a=e[t],a.get&&a.put&&a.delete&&a.list)return a;throw new Error(`lowstorage: store ${t} not found`)}for(let s of Object.values(e))if(s.get&&s.put&&s.delete&&s.list)return s;throw new Error("lowstorage: no valid store found")},r=class{constructor(t,a){this._colName=t,this._store=a,this._data=this._loadData().then(s=>{this._data=s})}async _loadData(){try{let t=await this._store.get(`${this._colName}/${this._colName}.json`);return t?t.json():[]}catch(t){if(t.code==="ENOENT")return[];throw t}}async _saveData(){let t=`${this._colName}/${this._colName}.json`;return this._store.put(t,JSON.stringify(this._data))}async insert(t){Array.isArray(t)||(t=[t]),await this._data;for(let a of t){if(typeof a!="object"||a===null)throw new Error("Invalid input: input must be an object or an array of objects");a._id=a._id||h(),this._data.push(a)}await this._saveData()}async find(t={}){return await this._data,this._data.filter(a=>i(a,t))}async findOne(t={}){return(await this.find(t))[0]||null}async update(t={},a={}){let s=await this.find(t);return s.forEach(o=>{Object.assign(o,a)}),await this._saveData(),s.length}async updateOne(t={},a={}){let s=await this.findOne(t);return s?(Object.assign(s,a),await this._saveData(),1):0}async delete(t={}){await this._data;let a=this._data.length;return this._data=this._data.filter(s=>!i(s,t)),await this._saveData(),a-this._data.length}async count(t={}){return(await this.find(t)).length}async remove(){await this._data;let t=this._data.length;return this._data=[],await this._saveData(),t}},n=class{constructor(t,a){c(t),this._store=_(t,a)}collection(t){return new r(t,this._store)}},l=n;export{l as default};
