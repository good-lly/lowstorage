"use strict";var l=Object.defineProperty;var h=Object.getOwnPropertyDescriptor;var f=Object.getOwnPropertyNames;var $=Object.prototype.hasOwnProperty;var m=(r,t)=>{for(var s in t)l(r,s,{get:t[s],enumerable:!0})},y=(r,t,s,e)=>{if(t&&typeof t=="object"||typeof t=="function")for(let o of f(t))!$.call(r,o)&&o!==s&&l(r,o,{get:()=>t[o],enumerable:!(e=h(t,o))||e.enumerable});return r};var p=r=>y(l({},"__esModule",{value:!0}),r);var b={};m(b,{default:()=>j});module.exports=p(b);var n="____";function w(...r){for(let t of r)if(typeof t!="object"||t===null)throw new Error("lowstorage: missing args or args not an object")}function g(r,t){return Object.keys(t).every(s=>r[s]===t[s])}function _(){return crypto.randomUUID()}function N(r,t=null){let s=null;if(t){if(s=r[t],s.get&&s.put&&s.delete&&s.list)return s;throw new Error(`lowstorage: store ${t} not found`)}for(let e of Object.values(r))if(e.get&&e.put&&e.delete&&e.list)return e;throw new Error("lowstorage: no valid store found")}var d=class{constructor(t,s){this._colName=t,this._store=s}async _getAllFiles(){let t=await this._store.list({prefix:`${this._colName}/${this._colName}${n}`}),s=t.truncated,e=s?t.cursor:void 0;for(;s;){let o=await this._store.list({prefix:`${this._colName}/${this._colName}${n}`,cursor:e});t.objects.push(...o.objects),s=o.truncated,e=o.cursor}return t.objects}async insert(t){if(Array.isArray(t)){let s=t.map(async e=>{e._id=e._id||_();let o=`${this._colName}/${this._colName}${n}${e._id}`;return this._store.put(o,JSON.stringify(e))});return Promise.all(s)}if(typeof t=="object"&&t!==null){t._id=t._id||_();let s=`${this._colName}/${this._colName}${n}${t._id}`;return this._store.put(s,JSON.stringify(t))}throw new Error("Invalid input: input must be an object or an array of objects")}async find(t={}){if(t._id){let i=await this._store.get(`${this._colName}/${this._colName}${n}${t._id}`);return i?[await i.json()]:[]}let e=(await this._getAllFiles()).map(async i=>(await this._store.get(`${i.key}`)).json()),o=await Promise.all(e);return Object.keys(t).length===0?o:o.filter(i=>g(i,t))}async findOne(t={}){return(await this.find(t))[0]}async update(t={},s={}){let o=(await this.find(t)).map(async c=>{let i={...c,...s},a=`${this._colName}/${this._colName}${n}${c._id}`;return this._store.put(a,JSON.stringify(i))});return Promise.all(o)}async updateOne(t={},s={}){let e=await this.findOne(t),o={...e,...s},c=`${this._colName}/${this._colName}${n}${e._id}`;return this._store.put(c,JSON.stringify(o))}async delete(t={}){let e=(await this.find(t)).map(async o=>{let c=`${this._colName}/${this._colName}${n}${o._id}`;return this._store.delete(c)});return Promise.all(e)}async count(t={}){return Object.keys(t).length===0?(await this._getAllFiles()).length:(await this.find(t)).length}async remove(){let s=(await this._getAllFiles()).map(async e=>this._store.delete(`${e.key}`));return Promise.all(s)}},u=class{constructor(t,s){w(t),this._store=N(t,s)}collection(t){return new d(t,this._store)}},j=u;
