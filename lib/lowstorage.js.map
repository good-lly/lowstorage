{
  "version": 3,
  "sources": ["../node_modules/ultralight-s3/src/index.ts", "../src/lowstorage.js", "../src/errors.js", "../src/helpers.js"],
  "sourcesContent": ["'use strict';\n\n// Constants\nconst AWS_ALGORITHM = 'AWS4-HMAC-SHA256';\nconst AWS_REQUEST_TYPE = 'aws4_request';\nconst S3_SERVICE = 's3';\nconst LIST_TYPE = '2';\nconst UNSIGNED_PAYLOAD = 'UNSIGNED-PAYLOAD';\nconst DEFAULT_STREAM_CONTENT_TYPE = 'application/octet-stream';\nconst XML_CONTENT_TYPE = 'application/xml';\nconst JSON_CONTENT_TYPE = 'application/json';\n// List of keys that might contain sensitive information\nconst SENSITIVE_KEYS_REDACTED = ['accessKeyId', 'secretAccessKey', 'sessionToken', 'password'];\nconst MIN_MAX_REQUEST_SIZE_IN_BYTES = 5 * 1024 * 1024;\n\n// Headers\nconst HEADER_AMZ_CONTENT_SHA256 = 'x-amz-content-sha256';\nconst HEADER_AMZ_DATE = 'x-amz-date';\nconst HEADER_HOST = 'host';\nconst HEADER_AUTHORIZATION = 'Authorization';\nconst HEADER_CONTENT_TYPE = 'Content-Type';\nconst HEADER_CONTENT_LENGTH = 'Content-Length';\nconst HEADER_ETAG = 'etag';\nconst HEADER_LAST_MODIFIED = 'last-modified';\n\n// Error messages\nconst ERROR_PREFIX = 'ultralight-s3 Module: ';\nconst ERROR_ACCESS_KEY_REQUIRED = `${ERROR_PREFIX}accessKeyId must be a non-empty string`;\nconst ERROR_SECRET_KEY_REQUIRED = `${ERROR_PREFIX}secretAccessKey must be a non-empty string`;\nconst ERROR_ENDPOINT_REQUIRED = `${ERROR_PREFIX}endpoint must be a non-empty string`;\nconst ERROR_BUCKET_NAME_REQUIRED = `${ERROR_PREFIX}bucketName must be a non-empty string`;\nconst ERROR_KEY_REQUIRED = `${ERROR_PREFIX}key must be a non-empty string`;\nconst ERROR_UPLOAD_ID_REQUIRED = `${ERROR_PREFIX}uploadId must be a non-empty string`;\nconst ERROR_PARTS_REQUIRED = `${ERROR_PREFIX}parts must be a non-empty array`;\nconst ERROR_INVALID_PART = `${ERROR_PREFIX}Each part must have a partNumber (number) and ETag (string)`;\nconst ERROR_DATA_BUFFER_REQUIRED = `${ERROR_PREFIX}data must be a Buffer or string`;\n// const ERROR_PATH_REQUIRED = `${ERROR_PREFIX}path must be a string`;\nconst ERROR_PREFIX_TYPE = `${ERROR_PREFIX}prefix must be a string`;\nconst ERROR_MAX_KEYS_TYPE = `${ERROR_PREFIX}maxKeys must be a positive integer`;\nconst ERROR_DELIMITER_REQUIRED = `${ERROR_PREFIX}delimiter must be a string`;\n\n// const STATUS_CODES: Record<number, string> = {\n//   200: 'OK',\n//   204: 'No Content',\n//   205: 'Reset Content',\n//   206: 'Partial Content',\n//   301: 'Moved Permanently',\n//   302: 'Found',\n//   400: 'Bad Request',\n//   401: 'Unauthorized',\n//   403: 'Forbidden',\n//   404: 'Not Found',\n//   418: \"I'm a Teapot\",\n//   428: 'Precondition Required',\n//   429: 'Too Many Requests',\n//   500: 'Internal Server Error',\n//   501: 'Not Implemented',\n// };\n\ninterface S3Config {\n  accessKeyId: string;\n  secretAccessKey: string;\n  endpoint: string;\n  bucketName: string;\n  region?: string;\n  maxRequestSizeInBytes?: number;\n  requestAbortTimeout?: number;\n  logger?: Logger;\n}\n\ndeclare global {\n  interface Crypto {\n    createHmac: (\n      algorithm: string,\n      key: string | Buffer,\n    ) => {\n      update: (data: string | Buffer) => void;\n      digest: (encoding?: 'hex' | 'base64' | 'latin1') => string;\n    };\n    createHash: (algorithm: string) => {\n      update: (data: string | Buffer) => void;\n      digest: (encoding?: 'hex' | 'base64' | 'latin1') => string;\n    };\n  }\n}\n\ninterface Logger {\n  info: (message: string, ...args: any[]) => void;\n  warn: (message: string, ...args: any[]) => void;\n  error: (message: string, ...args: any[]) => void;\n}\n\ninterface UploadPart {\n  partNumber: number;\n  ETag: string;\n}\n\ninterface CompleteMultipartUploadResult {\n  Location: string;\n  Bucket: string;\n  Key: string;\n  ETag: string;\n}\n\ntype HttpMethod = 'POST' | 'GET' | 'HEAD' | 'PUT' | 'DELETE';\n\n// false - Not found (404)\n// true - Found (200)\n// null - ETag mismatch (412)\ntype ExistResponseCode = false | true | null;\n\nlet _createHmac = crypto.createHmac || (await import('node:crypto')).createHmac;\nlet _createHash = crypto.createHash || (await import('node:crypto')).createHash;\n\nif (typeof _createHmac === 'undefined' && typeof _createHash === 'undefined') {\n  console.error(\n    'ultralight-S3 Module: Crypto functions are not available, please report the issue with necessary description: https://github.com/sentienhq/ultralight-s3/issues',\n  );\n}\n\nconst expectArray: { [key: string]: boolean } = {\n  contents: true,\n};\n\nconst encodeAsHex = (c: string): string => `%${c.charCodeAt(0).toString(16).toUpperCase()}`;\n\nconst uriEscape = (uriStr: string): string => {\n  return encodeURIComponent(uriStr).replace(/[!'()*]/g, encodeAsHex);\n};\n\nconst uriResourceEscape = (string: string): string => {\n  return uriEscape(string).replace(/%2F/g, '/');\n};\n\n/**\n * S3 class for interacting with S3-compatible object storage services.\n * This class provides methods for common S3 operations such as uploading, downloading,\n * and deleting objects, as well as multipart uploads.\n *\n * @class\n * @example\n * const s3 = new S3({\n *   accessKeyId: 'your-access-key',\n *   secretAccessKey: 'your-secret-key',\n *   endpoint: 'https://your-s3-endpoint.com',\n *   bucketName: 'your-bucket-name',\n *   region: 'us-east-1' // by default is auto\n * });\n *\n * // Upload a file\n * await s3.put('example.txt', 'Hello, World!');\n *\n * // Download a file\n * const content = await s3.get('example.txt');\n *\n * // Delete a file\n * await s3.delete('example.txt');\n */\nclass S3 {\n  /**\n   * Creates an instance of the S3 class.\n   *\n   * @constructor\n   * @param {Object} config - Configuration options for the S3 instance.\n   * @param {string} config.accessKeyId - The access key ID for authentication.\n   * @param {string} config.secretAccessKey - The secret access key for authentication.\n   * @param {string} config.endpoint - The endpoint URL of the S3-compatible service.\n   * @param {string} [config.bucketName=''] - The name of the bucket to operate on.\n   * @param {string} [config.region='auto'] - The region of the S3 service.\n   * @param {number} [config.maxRequestSizeInBytes=5242880] - The maximum size of a single request in bytes (minimum for AWS S3 is 5MB).\n   * @param {number} [config.requestAbortTimeout=undefined] - The timeout in milliseconds after which a request should be aborted (careful on streamed requests).\n   * @param {Object} [config.logger=null] - A logger object with methods like info, warn, error.\n   * @throws {TypeError} Will throw an error if required parameters are missing or of incorrect type.\n   */\n  private accessKeyId: string;\n  private secretAccessKey: string;\n  private endpoint: string;\n  private bucketName: string;\n  private region: string;\n  private maxRequestSizeInBytes: number;\n  private requestAbortTimeout?: number;\n  private logger?: Logger;\n\n  constructor({\n    accessKeyId,\n    secretAccessKey,\n    endpoint,\n    bucketName,\n    region = 'auto',\n    maxRequestSizeInBytes = MIN_MAX_REQUEST_SIZE_IN_BYTES,\n    requestAbortTimeout = undefined,\n    logger = undefined,\n  }: S3Config) {\n    this._validateConstructorParams(accessKeyId, secretAccessKey, endpoint, bucketName);\n    this.accessKeyId = accessKeyId;\n    this.secretAccessKey = secretAccessKey;\n    this.endpoint = endpoint;\n    this.bucketName = bucketName;\n    this.region = region;\n    this.maxRequestSizeInBytes = maxRequestSizeInBytes;\n    this.requestAbortTimeout = requestAbortTimeout;\n    this.logger = logger;\n  }\n\n  private _validateConstructorParams(\n    accessKeyId: string,\n    secretAccessKey: string,\n    endpoint: string,\n    bucketName: string,\n  ): void {\n    if (typeof accessKeyId !== 'string' || accessKeyId.trim().length === 0)\n      throw new TypeError(ERROR_ACCESS_KEY_REQUIRED);\n    if (typeof secretAccessKey !== 'string' || secretAccessKey.trim().length === 0)\n      throw new TypeError(ERROR_SECRET_KEY_REQUIRED);\n    if (typeof endpoint !== 'string' || endpoint.trim().length === 0) throw new TypeError(ERROR_ENDPOINT_REQUIRED);\n    if (typeof bucketName !== 'string' || bucketName.trim().length === 0)\n      throw new TypeError(ERROR_BUCKET_NAME_REQUIRED);\n  }\n\n  private _checkMethodHeadnGet(method: string): void {\n    if (method !== 'GET' && method !== 'HEAD') {\n      this._log('error', `${ERROR_PREFIX}method must be either GET or HEAD`);\n      throw new Error('method must be either GET or HEAD');\n    }\n  }\n\n  private _checkKey(key: string): void {\n    if (typeof key !== 'string' || key.trim().length === 0) {\n      this._log('error', ERROR_KEY_REQUIRED);\n      throw new TypeError(ERROR_KEY_REQUIRED);\n    }\n  }\n\n  private _checkDelimiter(delimiter: string): void {\n    if (typeof delimiter !== 'string' || delimiter.trim().length === 0) {\n      this._log('error', ERROR_DELIMITER_REQUIRED);\n      throw new TypeError(ERROR_DELIMITER_REQUIRED);\n    }\n  }\n\n  private _checkPrefix(prefix: string): void {\n    if (typeof prefix !== 'string') {\n      this._log('error', ERROR_PREFIX_TYPE);\n      throw new TypeError(ERROR_PREFIX_TYPE);\n    }\n  }\n\n  private _checkMaxKeys(maxKeys: number): void {\n    if (typeof maxKeys !== 'number' || maxKeys <= 0) {\n      this._log('error', ERROR_MAX_KEYS_TYPE);\n      throw new TypeError(ERROR_MAX_KEYS_TYPE);\n    }\n  }\n\n  private _checkOpts(opts: Record<string, any>): void {\n    if (typeof opts !== 'object') {\n      this._log('error', `${ERROR_PREFIX}opts must be an object`);\n      throw new TypeError(`${ERROR_PREFIX}opts must be an object`);\n    }\n  }\n\n  /**\n   * Internal method to log messages with sanitized sensitive information.\n   * @param {string} level - The log level (e.g., 'info', 'warn', 'error').\n   * @param {string} message - The message to log.\n   * @param {Object} [additionalData={}] - Additional data to include in the log.\n   * @private\n   */\n  private _log(\n    level: 'info' | 'warn' | 'error',\n    message: string,\n    additionalData: Record<string, any> | string = {},\n  ): void {\n    if (this.logger && typeof this.logger[level] === 'function') {\n      // Function to recursively sanitize an object\n      const sanitize = (obj: any): any => {\n        if (typeof obj !== 'object' || obj === null) {\n          return obj;\n        }\n        return Object.keys(obj).reduce(\n          (acc: any, key) => {\n            if (SENSITIVE_KEYS_REDACTED.includes(key.toLowerCase())) {\n              acc[key] = '[REDACTED]';\n            } else if (typeof obj[key] === 'object' && obj[key] !== null) {\n              acc[key] = sanitize(obj[key]);\n            } else {\n              acc[key] = obj[key];\n            }\n            return acc;\n          },\n          Array.isArray(obj) ? [] : {},\n        );\n      };\n\n      // Sanitize the additional data\n      const sanitizedData = sanitize(additionalData);\n      // Prepare the log entry\n      const logEntry = {\n        timestamp: new Date().toISOString(),\n        level,\n        message,\n        ...sanitizedData,\n        // Include some general context, but sanitize sensitive parts\n        context: sanitize({\n          bucketName: this.bucketName,\n          region: this.region,\n          endpoint: this.endpoint,\n          // Only include the first few characters of the access key, if it exists\n          accessKeyId: this.accessKeyId ? `${this.accessKeyId.substring(0, 4)}...` : undefined,\n        }),\n      };\n\n      // Log the sanitized entry\n      this.logger[level](logEntry);\n    }\n  }\n\n  getBucketName = () => this.bucketName;\n  setBucketName = (bucketName: string) => {\n    this.bucketName = bucketName;\n  };\n  getRegion = () => this.region;\n  setRegion = (region: string) => {\n    this.region = region;\n  };\n  getEndpoint = () => this.endpoint;\n  setEndpoint = (endpoint: string) => {\n    this.endpoint = endpoint;\n  };\n  getMaxRequestSizeInBytes = () => this.maxRequestSizeInBytes;\n  setMaxRequestSizeInBytes = (maxRequestSizeInBytes: number) => {\n    this.maxRequestSizeInBytes = maxRequestSizeInBytes;\n  };\n  sanitizeETag = (etag: string): string => sanitizeETag(etag);\n\n  getProps = () => ({\n    accessKeyId: this.accessKeyId,\n    secretAccessKey: this.secretAccessKey,\n    region: this.region,\n    bucket: this.bucketName,\n    endpoint: this.endpoint,\n    maxRequestSizeInBytes: this.maxRequestSizeInBytes,\n    requestAbortTimeout: this.requestAbortTimeout,\n    logger: this.logger,\n  });\n  setProps = (props: S3Config) => {\n    this._validateConstructorParams(props.accessKeyId, props.secretAccessKey, props.bucketName, props.endpoint);\n    this.accessKeyId = props.accessKeyId;\n    this.secretAccessKey = props.secretAccessKey;\n    this.region = props.region || 'auto';\n    this.bucketName = props.bucketName;\n    this.endpoint = props.endpoint;\n    this.maxRequestSizeInBytes = props.maxRequestSizeInBytes || MIN_MAX_REQUEST_SIZE_IN_BYTES;\n    this.requestAbortTimeout = props.requestAbortTimeout;\n    this.logger = props.logger;\n  };\n\n  /**\n   * Get the content length of an object.\n   * @param {string} key - The key of the object.\n   * @returns {Promise<number>} The content length of the object in bytes.\n   * @throws {TypeError} If the key is not a non-empty string.\n   */\n  async getContentLength(key: string): Promise<number> {\n    this._checkKey(key);\n    const headers = {\n      [HEADER_AMZ_CONTENT_SHA256]: UNSIGNED_PAYLOAD,\n    };\n    const encodedKey = uriResourceEscape(key);\n    const { url, headers: signedHeaders } = await this._sign('HEAD', encodedKey, {}, headers, '');\n    const res = await this._sendRequest(url, 'HEAD', signedHeaders);\n    const contentLength = res.headers.get(HEADER_CONTENT_LENGTH);\n    return contentLength ? parseInt(contentLength, 10) : 0;\n  }\n\n  /**\n   * Check if a bucket exists.\n   * @returns {Promise<boolean>} True if the bucket exists, false otherwise.\n   */\n  async bucketExists(): Promise<boolean> {\n    const headers = {\n      [HEADER_AMZ_CONTENT_SHA256]: UNSIGNED_PAYLOAD,\n    };\n    const { url, headers: signedHeaders } = await this._sign('HEAD', '', {}, headers, '');\n    const res = await this._sendRequest(url, 'HEAD', signedHeaders);\n    if (res.ok && res.status === 200) {\n      return true;\n    }\n    return false;\n  }\n\n  // TBD\n  // async createBucket(bucketName) {\n  //   const xmlBody = `\n  //   <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n  //     <CreateBucketConfiguration xmlns=\"http://s3.amazonaws.com/doc/2006-03-01/\">\n  //     <LocationConstraint>${this.region}</LocationConstraint>\n  //   </CreateBucketConfiguration>\n  //   `;\n  //   const headers = {\n  //     [HEADER_CONTENT_TYPE]: XML_CONTENT_TYPE,\n  //     [HEADER_CONTENT_LENGTH]: Buffer.byteLength(xmlBody).toString(),\n  //     [HEADER_AMZ_CONTENT_SHA256]: await _hash(xmlBody),\n  //   };\n  //   const encodedKey = encodeURI(bucketName);\n  //   const { url, headers: signedHeaders } = await this._sign('PUT', encodedKey, {}, headers, '');\n  //   const res = await this._sendRequest(url, 'PUT', signedHeaders);\n  //   if (res.ok && res.status === 200) {\n  //     return true;\n  //   }\n  //   return false;\n  // }\n\n  /**\n   * Check if a file exists in the bucket.\n   * @param {string} key - The key of the object.\n   * @param {Object} [opts={}] - Additional options for the fileExists operation.\n   * @returns {Promise<ExistResponseCode>} True if the file exists, false otherwise. 0 - Not found (404), 1 - Found (200), 2 - ETag mismatch (412).\n   * @throws {TypeError} If the key is not a non-empty string.\n   */\n  async fileExists(key: string, opts: Record<string, any> = {}): Promise<ExistResponseCode> {\n    this._checkKey(key);\n    const { filteredOpts, conditionalHeaders } = this._filterIfHeaders(opts);\n    const headers = { [HEADER_AMZ_CONTENT_SHA256]: UNSIGNED_PAYLOAD, ...conditionalHeaders };\n    const encodedKey = uriResourceEscape(key);\n    const { url, headers: signedHeaders } = await this._sign('HEAD', encodedKey, filteredOpts, headers, '');\n    try {\n      const res = await this._sendRequest(url, 'HEAD', signedHeaders, '', [200, 404, 412, 304]);\n      if (res.status === 404) {\n        return false;\n      }\n      if (res.status === 412 || res.status === 304) {\n        return null;\n      }\n      if (res.ok && res.status === 200) return true;\n      else this._handleErrorResponse(res);\n      return false; // should never happen\n    } catch (error: unknown) {\n      const errorMessage = error instanceof Error ? error.message : String(error);\n      this._log('error', `${ERROR_PREFIX}Failed to check if file exists: ${errorMessage}`);\n      throw new Error(`${ERROR_PREFIX}Failed to check if file exists: ${errorMessage}`);\n    }\n  }\n  private async _sign(\n    method: HttpMethod,\n    keyPath: string,\n    query: Object,\n    headers: Record<string, string | number>,\n    body: string | Buffer,\n  ): Promise<{ url: string; headers: Record<string, any> }> {\n    const datetime = new Date().toISOString().replace(/[:-]|\\.\\d{3}/g, '');\n    const url =\n      typeof keyPath === 'string' && keyPath.length > 0 ? new URL(keyPath, this.endpoint) : new URL(this.endpoint);\n    url.pathname = `/${encodeURI(this.bucketName)}${url.pathname}`;\n    headers[HEADER_AMZ_CONTENT_SHA256] = body ? await _hash(body) : UNSIGNED_PAYLOAD;\n    headers[HEADER_AMZ_DATE] = datetime;\n    headers[HEADER_HOST] = url.host;\n    const canonicalHeaders = this._buildCanonicalHeaders(headers);\n    const signedHeaders = Object.keys(headers)\n      .map(key => key.toLowerCase())\n      .sort()\n      .join(';');\n\n    const canonicalRequest = await this._buildCanonicalRequest(\n      method,\n      url,\n      query,\n      canonicalHeaders,\n      signedHeaders,\n      body,\n    );\n    const stringToSign = await this._buildStringToSign(datetime, canonicalRequest);\n    const signature = await this._calculateSignature(datetime, stringToSign);\n    const authorizationHeader = this._buildAuthorizationHeader(datetime, signedHeaders, signature);\n    headers[HEADER_AUTHORIZATION] = authorizationHeader;\n    return { url: url.toString(), headers };\n  }\n\n  private _buildCanonicalHeaders(headers: Record<string, string | number>): string {\n    return Object.entries(headers)\n      .map(([key, value]) => `${key.toLowerCase()}:${String(value).trim()}`)\n      .sort()\n      .join('\\n');\n  }\n\n  async _buildCanonicalRequest(\n    method: HttpMethod,\n    url: URL,\n    query: Object,\n    canonicalHeaders: string,\n    signedHeaders: string,\n    body: string | Buffer,\n  ): Promise<string> {\n    return [\n      method,\n      url.pathname,\n      this._buildCanonicalQueryString(query),\n      `${canonicalHeaders}\\n`,\n      signedHeaders,\n      body ? await _hash(body) : UNSIGNED_PAYLOAD,\n    ].join('\\n');\n  }\n\n  async _buildStringToSign(datetime: string, canonicalRequest: string): Promise<string> {\n    const credentialScope = [datetime.slice(0, 8), this.region, S3_SERVICE, AWS_REQUEST_TYPE].join('/');\n    return [AWS_ALGORITHM, datetime, credentialScope, await _hash(canonicalRequest)].join('\\n');\n  }\n\n  async _calculateSignature(datetime: string, stringToSign: string): Promise<string> {\n    const signingKey = await this._getSignatureKey(datetime.slice(0, 8));\n    return _hmac(signingKey, stringToSign, 'hex');\n  }\n\n  private _buildAuthorizationHeader(datetime: string, signedHeaders: string, signature: string): string {\n    const credentialScope = [datetime.slice(0, 8), this.region, S3_SERVICE, AWS_REQUEST_TYPE].join('/');\n    return [\n      `${AWS_ALGORITHM} Credential=${this.accessKeyId}/${credentialScope}`,\n      `SignedHeaders=${signedHeaders}`,\n      `Signature=${signature}`,\n    ].join(', ');\n  }\n\n  private _filterIfHeaders(opts: Record<string, any>): {\n    filteredOpts: Record<string, any>;\n    conditionalHeaders: Record<string, string>;\n  } {\n    const filteredOpts: Record<string, any> = {};\n    const conditionalHeaders: Record<string, string> = {};\n    const ifHeaders = ['if-match', 'if-none-match', 'if-modified-since', 'if-unmodified-since'];\n\n    for (const [key, value] of Object.entries(opts)) {\n      if (ifHeaders.includes(key)) {\n        conditionalHeaders[key] = value;\n      } else {\n        filteredOpts[key] = value;\n      }\n    }\n\n    return { filteredOpts, conditionalHeaders };\n  }\n  /**\n   * List objects in the bucket.\n   * @param {string} [delimiter='/'] - The delimiter to use for grouping objects in specific path.\n   * @param {string} [prefix=''] - The prefix to filter objects in specific path.\n   * @param {number} [maxKeys=1000] - The maximum number of keys to return.\n   * @param {string} [method='GET'] - The HTTP method to use (GET or HEAD).\n   * @param {Object} [opts={}] - Additional options for the list operation.\n   * @returns {Promise<Object|Array>} The list of objects or object metadata.\n   * @throws {TypeError} If any of the parameters are of incorrect type.\n   */\n  async list(\n    delimiter: string = '/',\n    prefix: string = '',\n    maxKeys: number = 1000,\n    method: HttpMethod = 'GET',\n    opts: Object = {},\n  ): Promise<Object | Array<Object>> {\n    this._checkDelimiter(delimiter);\n    this._checkPrefix(prefix);\n    this._checkMaxKeys(maxKeys);\n    this._checkMethodHeadnGet(method);\n    this._checkOpts(opts);\n    this._log('info', `Listing objects in ${prefix}`);\n\n    const query = {\n      'list-type': LIST_TYPE,\n      'max-keys': String(maxKeys),\n      ...opts,\n    } as { [key: string]: any };\n    if (prefix.length > 0) {\n      query['prefix'] = prefix;\n    }\n    const headers = {\n      [HEADER_CONTENT_TYPE]: JSON_CONTENT_TYPE,\n      [HEADER_AMZ_CONTENT_SHA256]: UNSIGNED_PAYLOAD,\n    };\n    const encodedKey = delimiter === '/' ? delimiter : uriEscape(delimiter);\n    const { url, headers: signedHeaders } = await this._sign('GET', encodedKey, query, headers, '');\n    const urlWithQuery = `${url}?${new URLSearchParams(query)}`;\n    const res = await this._sendRequest(urlWithQuery, 'GET', signedHeaders);\n    const responseBody = await res.text();\n\n    if (method === 'HEAD') {\n      const contentLength = res.headers.get(HEADER_CONTENT_LENGTH);\n      const lastModified = res.headers.get(HEADER_LAST_MODIFIED);\n      const etag = res.headers.get(HEADER_ETAG);\n\n      return {\n        size: contentLength ? +contentLength : undefined,\n        mtime: lastModified ? new Date(lastModified) : undefined,\n        ETag: etag || undefined,\n      };\n    }\n\n    const data = _parseXml(responseBody);\n    const output = data.listBucketResult || data.error || data;\n    return output.contents || output;\n  }\n\n  /**\n   * List multipart uploads in the bucket.\n   * @param {string} [delimiter='/'] - The delimiter to use for grouping objects in specific path.\n   * @param {string} [prefix=''] - The prefix to filter objects in specific path.\n   * @param {string} [method='GET'] - The HTTP method to use (GET or HEAD).\n   * @param {Object} [opts={}] - Additional options for the list operation.\n   * @returns {Promise<Object|Array>} The list of objects or object metadata.\n   * @throws {TypeError} If any of the parameters are of incorrect type.\n   */\n  async listMultiPartUploads(\n    delimiter: string = '/',\n    prefix: string = '',\n    method: HttpMethod = 'GET',\n    opts: Object = {},\n  ): Promise<any> {\n    this._checkDelimiter(delimiter);\n    this._checkPrefix(prefix);\n    this._checkMethodHeadnGet(method);\n    this._checkOpts(opts);\n    this._log('info', `Listing multipart uploads in ${prefix}`);\n\n    const query = {\n      uploads: '',\n      ...opts,\n    } as Record<string, any>;\n    const headers = {\n      [HEADER_CONTENT_TYPE]: JSON_CONTENT_TYPE,\n      [HEADER_AMZ_CONTENT_SHA256]: UNSIGNED_PAYLOAD,\n    };\n    const encodedKey = delimiter === '/' ? delimiter : uriEscape(delimiter);\n    const { url, headers: signedHeaders } = await this._sign('GET', encodedKey, query, headers, '');\n    const urlWithQuery = `${url}?${new URLSearchParams(query)}`;\n    const res = await this._sendRequest(urlWithQuery, 'GET', signedHeaders);\n    const responseBody = await res.text();\n\n    if (method === 'HEAD') {\n      return {\n        size: +(res.headers.get(HEADER_CONTENT_LENGTH) ?? '0'),\n        mtime: new Date(res.headers.get(HEADER_LAST_MODIFIED) ?? ''),\n        ETag: res.headers.get(HEADER_ETAG) ?? '',\n      };\n    }\n\n    const data = _parseXml(responseBody);\n    const output = data.listMultipartUploadsResult || data.error || data;\n    return output.uploads || output;\n  }\n\n  /**\n   * Get an object from the bucket.\n   * @param {string} key - The key of the object to get.\n   * @param {Object} [opts={}] - Additional options for the get operation.\n   * @returns {Promise<string|null>} The content of the object. If the object does not exist, null will be returned.\n   */\n  async get(key: string, opts: Record<string, any> = {}): Promise<string | null> {\n    this._checkKey(key);\n    this._log('info', `Getting object ${key}`);\n    const { filteredOpts, conditionalHeaders } = this._filterIfHeaders(opts);\n    const headers = {\n      [HEADER_CONTENT_TYPE]: JSON_CONTENT_TYPE,\n      [HEADER_AMZ_CONTENT_SHA256]: UNSIGNED_PAYLOAD,\n      ...conditionalHeaders,\n    };\n    const encodedKey = uriResourceEscape(key);\n    const { url, headers: signedHeaders } = await this._sign('GET', encodedKey, filteredOpts, headers, '');\n    const res = await this._sendRequest(url, 'GET', signedHeaders, '', [200, 404, 412, 304]);\n    if (res.status === 404 || res.status === 412 || res.status === 304) {\n      this._log('error', `Failed to get object. Status: ${res.status}`);\n      return null;\n    }\n    if (!res.ok) {\n      this._log('error', `Failed to get object. Status: ${res.status}`);\n      throw new Error(`Failed to get object. Status: ${res.status}`);\n    }\n    return res.text();\n  }\n\n  /**\n   *\n   * @param {string} key - The key of the object to get.\n   * @param {Object} [opts={}] - Additional options for the get operation.\n   * @returns {Promise<{ etag: string|null; data: string|null }>} The content of the object. If the object does not exist, etag and data will be null.\n   */\n  async getObjectWithETag(\n    key: string,\n    opts: Record<string, any> = {},\n  ): Promise<{ etag: string | null; data: string | null }> {\n    this._checkKey(key);\n    this._log('info', `Getting object ${key}`);\n    const { filteredOpts, conditionalHeaders } = this._filterIfHeaders(opts);\n    const headers = {\n      [HEADER_CONTENT_TYPE]: JSON_CONTENT_TYPE,\n      [HEADER_AMZ_CONTENT_SHA256]: UNSIGNED_PAYLOAD,\n      ...conditionalHeaders,\n    };\n    const encodedKey = uriResourceEscape(key);\n    const { url, headers: signedHeaders } = await this._sign('GET', encodedKey, filteredOpts, headers, '');\n    try {\n      const res = await this._sendRequest(url, 'GET', signedHeaders, '', [200, 404, 412, 304]);\n      if (res.status === 404 || res.status === 412 || res.status === 304) {\n        this._log('error', `Failed to get object. Status: ${res.status}`);\n        return { etag: null, data: null };\n      }\n      if (!res.ok) {\n        this._log('error', `Failed to get object. Status: ${res.status}`);\n        throw new Error(`Failed to get object. Status: ${res.status}`);\n      }\n\n      const etag = res.headers.get('etag');\n      if (!etag) {\n        throw new Error('ETag not found in response headers');\n      }\n      const data = await res.text();\n      return { etag: sanitizeETag(etag), data };\n    } catch (error) {\n      this._log('error', `Error getting object ${key} with ETag: ${error}`);\n      throw error;\n    }\n  }\n\n  /**\n   * Get the ETag of an object.\n   * @param {string} key - The key of the object to get.\n   * @param {Object} [opts={}] - Additional options for the get operation.\n   * @returns {Promise<string|null>} The ETag of the object or null if the object etag does not match.\n   */\n  async getEtag(key: string, opts: Record<string, any> = {}): Promise<string | null> {\n    this._checkKey(key);\n    this._log('info', `Getting etag object ${key}`);\n    const { filteredOpts, conditionalHeaders } = this._filterIfHeaders(opts);\n    const headers = {\n      [HEADER_CONTENT_TYPE]: JSON_CONTENT_TYPE,\n      [HEADER_AMZ_CONTENT_SHA256]: UNSIGNED_PAYLOAD,\n      ...conditionalHeaders,\n    };\n    const encodedKey = uriResourceEscape(key);\n    const { url, headers: signedHeaders } = await this._sign('HEAD', encodedKey, filteredOpts, headers, '');\n\n    const res = await this._sendRequest(url, 'HEAD', signedHeaders, '', [200, 412, 304]);\n    this._log('info', `Response status: ${(res.status, res.statusText)}`);\n    // etag does not match\n    if (res.status === 412 || res.status === 304) {\n      return null;\n    }\n\n    const etag = res.headers.get('etag');\n    if (!etag) {\n      this._log('error', `ETag not found in response headers`);\n      throw new Error(`ETag not found in response headers`);\n    }\n    return sanitizeETag(etag);\n  }\n\n  /**\n   * Get a response of an object from the bucket.\n   * @param {string} key - The key of the object to get.\n   * @param {boolean} [wholeFile=true] - Whether to get the whole file or a part.\n   * @param {number} [rangeFrom=0] - The range from to get if not getting the whole file.\n   * @param {number} [rangeTo=this.maxRequestSizeInBytes] - The range to to get if not getting the whole file. Note: rangeTo is inclusive.\n   * @param {Object} [opts={}] - Additional options for the get operation.\n   * @returns {Promise<Response>} Response of the object content. Use readableStream() to get the stream from .body.\n   */\n  async getResponse(\n    key: string,\n    wholeFile: boolean = true,\n    rangeFrom: number = 0,\n    rangeTo: number = this.maxRequestSizeInBytes,\n    opts: Record<string, any> = {},\n  ): Promise<Response> {\n    this._checkKey(key);\n    const { filteredOpts, conditionalHeaders } = this._filterIfHeaders({ ...opts });\n    const headers = {\n      [HEADER_CONTENT_TYPE]: JSON_CONTENT_TYPE,\n      [HEADER_AMZ_CONTENT_SHA256]: UNSIGNED_PAYLOAD,\n      ...(wholeFile ? {} : { range: `bytes=${rangeFrom}-${rangeTo - 1}` }),\n      ...conditionalHeaders,\n    };\n    const encodedKey = uriResourceEscape(key);\n    const { url, headers: signedHeaders } = await this._sign('GET', encodedKey, filteredOpts, headers, '');\n    const urlWithQuery = `${url}?${new URLSearchParams(filteredOpts)}`;\n\n    return this._sendRequest(urlWithQuery, 'GET', signedHeaders);\n  }\n\n  /**\n   * Put an object into the bucket.\n   * @param {string} key - The key of the object to put. To create a folder, include a trailing slash.\n   * @param {Buffer|string} data - The content of the object to put.\n   * @returns {Promise<Object>} The response from the put operation.\n   * @throws {TypeError} If the key is not a non-empty string or data is not a Buffer or string.\n   */\n  async put(key: string, data: string | Buffer): Promise<Object> {\n    this._checkKey(key);\n    if (!(data instanceof Buffer || typeof data === 'string')) {\n      this._log('error', ERROR_DATA_BUFFER_REQUIRED);\n      throw new TypeError(ERROR_DATA_BUFFER_REQUIRED);\n    }\n    // const encodedKey = encodeURIComponent(key);\n    this._log('info', `Uploading object ${key}`);\n    const contentLength = typeof data === 'string' ? Buffer.byteLength(data) : data.length;\n    const headers = {\n      [HEADER_CONTENT_LENGTH]: contentLength,\n    };\n    const encodedKey = uriResourceEscape(key);\n    const { url, headers: signedHeaders } = await this._sign('PUT', encodedKey, {}, headers, data);\n    const res = await this._sendRequest(url, 'PUT', signedHeaders, data);\n    return res;\n  }\n\n  /**\n   * Initiate a multipart upload.\n   * @param {string} key - The key of the object to upload.\n   * @param {string} [fileType='application/octet-stream'] - The MIME type of the file.\n   * @returns {Promise<string>} The upload ID for the multipart upload.\n   * @throws {TypeError} If the key is not a non-empty string or fileType is not a string.\n   * @throws {Error} If the multipart upload initiation fails.\n   */\n  async getMultipartUploadId(key: string, fileType: string = DEFAULT_STREAM_CONTENT_TYPE): Promise<string> {\n    this._checkKey(key);\n    if (typeof fileType !== 'string') {\n      this._log('error', `${ERROR_PREFIX}fileType must be a string`);\n      throw new TypeError(`${ERROR_PREFIX}fileType must be a string`);\n    }\n    this._log('info', `Initiating multipart upload for object ${key}`);\n    const query = { uploads: '' };\n    const headers = {\n      [HEADER_CONTENT_TYPE]: fileType,\n      [HEADER_AMZ_CONTENT_SHA256]: UNSIGNED_PAYLOAD,\n    };\n\n    const encodedKey = uriResourceEscape(key);\n    const { url, headers: signedHeaders } = await this._sign('POST', encodedKey, query, headers, '');\n    const urlWithQuery = `${url}?${new URLSearchParams(query)}`;\n\n    const res = await this._sendRequest(urlWithQuery, 'POST', signedHeaders);\n    const responseBody = await res.text();\n    const parsedResponse = _parseXml(responseBody);\n\n    if (\n      typeof parsedResponse === 'object' &&\n      parsedResponse !== null &&\n      'error' in parsedResponse &&\n      typeof parsedResponse.error === 'object' &&\n      parsedResponse.error !== null &&\n      'message' in parsedResponse.error\n    ) {\n      const errorMessage = String(parsedResponse.error.message);\n      this._log('error', `${ERROR_PREFIX}Failed to abort multipart upload: ${errorMessage}`);\n      throw new Error(`${ERROR_PREFIX}Failed to abort multipart upload: ${errorMessage}`);\n    }\n\n    if (typeof parsedResponse === 'object' && parsedResponse !== null) {\n      if (!parsedResponse.initiateMultipartUploadResult || !parsedResponse.initiateMultipartUploadResult.uploadId) {\n        this._log('error', `${ERROR_PREFIX}Failed to create multipart upload: no uploadId in response`);\n        throw new Error(`${ERROR_PREFIX}Failed to create multipart upload: Missing upload ID in response`);\n      }\n\n      return parsedResponse.initiateMultipartUploadResult.uploadId;\n    } else {\n      this._log('error', `${ERROR_PREFIX}Failed to create multipart upload: unexpected response format`);\n      throw new Error(`${ERROR_PREFIX}Failed to create multipart upload: Unexpected response format`);\n    }\n  }\n\n  /**\n   * Upload a part in a multipart upload.\n   * @param {string} key - The key of the object being uploaded.\n   * @param {Buffer|string} data - The content of the part.\n   * @param {string} uploadId - The upload ID of the multipart upload.\n   * @param {number} partNumber - The part number.\n   * @param {Object} [opts={}] - Additional options for the upload.\n   * @returns {Promise<Object>} The ETag and part number of the uploaded part.\n   * @throws {TypeError} If any of the parameters are of incorrect type.\n   */\n  async uploadPart(\n    key: string,\n    data: Buffer | string,\n    uploadId: string,\n    partNumber: number,\n    opts: Object = {},\n  ): Promise<UploadPart> {\n    this._validateUploadPartParams(key, data, uploadId, partNumber, opts);\n    const query = { uploadId, partNumber, ...opts } as { [key: string]: any };\n    const headers = {\n      [HEADER_CONTENT_LENGTH]: data.length,\n    } as { [key: string]: any };\n\n    const encodedKey = uriResourceEscape(key);\n    const { url, headers: signedHeaders } = await this._sign('PUT', encodedKey, query, headers, data);\n    const urlWithQuery = `${url}?${new URLSearchParams(query)}`;\n\n    const res = await this._sendRequest(urlWithQuery, 'PUT', signedHeaders, data);\n    const ETag = sanitizeETag(res.headers.get('etag') || '');\n    return { partNumber, ETag };\n  }\n\n  private _validateUploadPartParams(\n    key: string,\n    data: Buffer | string,\n    uploadId: string,\n    partNumber: number,\n    opts: Object,\n  ) {\n    this._checkKey(key);\n    if (!(data instanceof Buffer || typeof data === 'string')) {\n      this._log('error', ERROR_DATA_BUFFER_REQUIRED);\n      throw new TypeError(ERROR_DATA_BUFFER_REQUIRED);\n    }\n    if (typeof uploadId !== 'string' || uploadId.trim().length === 0) {\n      this._log('error', ERROR_UPLOAD_ID_REQUIRED);\n      throw new TypeError(ERROR_UPLOAD_ID_REQUIRED);\n    }\n    if (!Number.isInteger(partNumber) || partNumber <= 0) {\n      this._log('error', `${ERROR_PREFIX}partNumber must be a positive integer`);\n      throw new TypeError(`${ERROR_PREFIX}partNumber must be a positive integer`);\n    }\n    this._checkOpts(opts);\n  }\n\n  /**\n   * Complete a multipart upload.\n   * @param {string} key - The key of the object being uploaded.\n   * @param {string} uploadId - The upload ID of the multipart upload.\n   * @param {Array<Object>} parts - An array of objects containing PartNumber and ETag for each part.\n   * @returns {Promise<Object>} The result of the complete multipart upload operation.\n   * @throws {TypeError} If any of the parameters are of incorrect type.\n   * @throws {Error} If the complete multipart upload operation fails.\n   */\n  async completeMultipartUpload(\n    key: string,\n    uploadId: string,\n    parts: Array<UploadPart>,\n  ): Promise<CompleteMultipartUploadResult> {\n    this._checkKey(key);\n    if (typeof uploadId !== 'string' || uploadId.trim().length === 0) {\n      this._log('error', ERROR_UPLOAD_ID_REQUIRED);\n      throw new TypeError(ERROR_UPLOAD_ID_REQUIRED);\n    }\n    if (!Array.isArray(parts) || parts.length === 0) {\n      this._log('error', ERROR_PARTS_REQUIRED);\n      throw new TypeError(ERROR_PARTS_REQUIRED);\n    }\n    if (!parts.every(part => typeof part.partNumber === 'number' && typeof part.ETag === 'string')) {\n      this._log('error', ERROR_INVALID_PART);\n      throw new TypeError(ERROR_INVALID_PART);\n    }\n    this._log('info', `Complete multipart upload ${uploadId} for object ${key}`);\n    const query = { uploadId };\n    const xmlBody = this._buildCompleteMultipartUploadXml(parts);\n    const headers = {\n      [HEADER_CONTENT_TYPE]: XML_CONTENT_TYPE,\n      [HEADER_CONTENT_LENGTH]: Buffer.byteLength(xmlBody).toString(),\n      [HEADER_AMZ_CONTENT_SHA256]: await _hash(xmlBody),\n    };\n    const encodedKey = uriResourceEscape(key);\n    const { url, headers: signedHeaders } = await this._sign('POST', encodedKey, query, headers, xmlBody);\n    const urlWithQuery = `${url}?${new URLSearchParams(query)}`;\n\n    const res = await this._sendRequest(urlWithQuery, 'POST', signedHeaders, xmlBody);\n    const responseBody = await res.text();\n    const parsedResponse = _parseXml(responseBody);\n\n    if (\n      typeof parsedResponse === 'object' &&\n      parsedResponse !== null &&\n      'error' in parsedResponse &&\n      typeof parsedResponse.error === 'object' &&\n      parsedResponse.error !== null &&\n      'message' in parsedResponse.error\n    ) {\n      const errorMessage = String(parsedResponse.error.message);\n      this._log('error', `${ERROR_PREFIX}Failed to abort multipart upload: ${errorMessage}`);\n      throw new Error(`${ERROR_PREFIX}Failed to abort multipart upload: ${errorMessage}`);\n    }\n\n    return parsedResponse.completeMultipartUploadResult;\n  }\n\n  /**\n   * Aborts a multipart upload.\n   * @param {string} key - The key of the object being uploaded.\n   * @param {string} uploadId - The ID of the multipart upload to abort.\n   * @returns {Promise<Object>} - A promise that resolves to the abort response.\n   * @throws {Error} If the abort operation fails.\n   */\n  async abortMultipartUpload(key: string, uploadId: string): Promise<object> {\n    // Input validation\n    this._checkKey(key);\n    if (typeof uploadId !== 'string' || uploadId.trim().length === 0) {\n      this._log('error', ERROR_UPLOAD_ID_REQUIRED);\n      throw new TypeError(ERROR_UPLOAD_ID_REQUIRED);\n    }\n\n    this._log('info', `Aborting multipart upload ${uploadId} for object ${key}`);\n\n    // Prepare the request\n    const query = { uploadId };\n    const headers = {\n      [HEADER_CONTENT_TYPE]: XML_CONTENT_TYPE,\n      [HEADER_AMZ_CONTENT_SHA256]: UNSIGNED_PAYLOAD,\n    };\n\n    try {\n      // Sign and send the request\n      const encodedKey = uriResourceEscape(key);\n      const { url, headers: signedHeaders } = await this._sign('DELETE', encodedKey, query, headers, '');\n      const urlWithQuery = `${url}?${new URLSearchParams(query)}`;\n\n      const res = await this._sendRequest(urlWithQuery, 'DELETE', signedHeaders);\n\n      // Check for successful response\n      if (res.ok) {\n        const responseBody = await res.text();\n        const parsedResponse = _parseXml(responseBody);\n\n        if (\n          typeof parsedResponse === 'object' &&\n          parsedResponse !== null &&\n          'error' in parsedResponse &&\n          typeof parsedResponse.error === 'object' &&\n          parsedResponse.error !== null &&\n          'message' in parsedResponse.error\n        ) {\n          const errorMessage = String(parsedResponse.error.message);\n          this._log('error', `${ERROR_PREFIX}Failed to abort multipart upload: ${errorMessage}`);\n          throw new Error(`${ERROR_PREFIX}Failed to abort multipart upload: ${errorMessage}`);\n        }\n\n        return {\n          status: 'Aborted',\n          key,\n          uploadId,\n          response: parsedResponse,\n        };\n      } else {\n        this._log('error', `${ERROR_PREFIX}Abort request failed with status ${res.status}`);\n        throw new Error(`${ERROR_PREFIX}Abort request failed with status ${res.status}`);\n      }\n    } catch (error: unknown) {\n      const errorMessage = error instanceof Error ? error.message : String(error);\n      this._log('error', `${ERROR_PREFIX}Failed to abort multipart upload for key ${key}: ${errorMessage}`);\n      throw new Error(`${ERROR_PREFIX}Failed to abort multipart upload for key ${key}: ${errorMessage}`);\n    }\n  }\n\n  private _buildCompleteMultipartUploadXml(parts: Array<UploadPart>): string {\n    return `\n      <CompleteMultipartUpload>\n        ${parts\n          .map(\n            part => `\n          <Part>\n            <PartNumber>${part.partNumber}</PartNumber>\n            <ETag>${part.ETag}</ETag>\n          </Part>\n        `,\n          )\n          .join('')}\n      </CompleteMultipartUpload>\n    `;\n  }\n\n  /**\n   * Delete an object from the bucket.\n   * @param {string} key - The key of the object to delete.\n   * @returns {Promise<boolean>} The response from the delete operation. True if the delete operation was successful, false otherwise. Note: The delete operation may return a 204 status code even if the object was not found.\n   */\n  async delete(key: string): Promise<boolean> {\n    this._checkKey(key);\n    this._log('info', `Deleting object ${key}`);\n    const headers = {\n      [HEADER_CONTENT_TYPE]: JSON_CONTENT_TYPE,\n      [HEADER_AMZ_CONTENT_SHA256]: UNSIGNED_PAYLOAD,\n    };\n    const encodedKey = uriResourceEscape(key);\n    const { url, headers: signedHeaders } = await this._sign('DELETE', encodedKey, {}, headers, '');\n    const res = await this._sendRequest(url, 'DELETE', signedHeaders);\n    if (res.status === 204 || res.status === 200) {\n      return true;\n    }\n    return false;\n  }\n\n  async _sendRequest(\n    url: string,\n    method: HttpMethod,\n    headers: Record<string, string | any>,\n    body?: string | Buffer,\n    toleratedStatusCodes: number[] = [],\n  ): Promise<Response> {\n    this._log('info', `Sending ${method} request to ${url}, headers: ${JSON.stringify(headers)}`);\n    const res = await fetch(url, {\n      method,\n      headers,\n      body: ['GET', 'HEAD'].includes(method) ? undefined : body,\n      signal: this.requestAbortTimeout !== undefined ? AbortSignal.timeout(this.requestAbortTimeout) : undefined,\n    });\n\n    if (!res.ok && !toleratedStatusCodes.includes(res.status)) {\n      await this._handleErrorResponse(res);\n    }\n\n    return res;\n  }\n\n  async _handleErrorResponse(res: Response) {\n    const errorBody = await res.text();\n    const errorCode = res.headers.get('x-amz-error-code') || 'Unknown';\n    const errorMessage = res.headers.get('x-amz-error-message') || res.statusText;\n    this._log(\n      'error',\n      `${ERROR_PREFIX}Request failed with status ${res.status}: ${errorCode} - ${errorMessage},err body: ${errorBody}`,\n    );\n    throw new Error(\n      `${ERROR_PREFIX}Request failed with status ${res.status}: ${errorCode} - ${errorMessage}, err body: ${errorBody}`,\n    );\n  }\n\n  _buildCanonicalQueryString(queryParams: Object): string {\n    if (Object.keys(queryParams).length < 1) {\n      return '';\n    }\n\n    return Object.keys(queryParams)\n      .sort()\n      .map(key => `${encodeURIComponent(key)}=${encodeURIComponent((queryParams as Record<string, any>)[key])}`)\n      .join('&');\n  }\n  async _getSignatureKey(dateStamp: string): Promise<string> {\n    const kDate = await _hmac(`AWS4${this.secretAccessKey}`, dateStamp);\n    const kRegion = await _hmac(kDate, this.region);\n    const kService = await _hmac(kRegion, S3_SERVICE);\n    return _hmac(kService, AWS_REQUEST_TYPE);\n  }\n}\n\nconst _hash = async (content: string | Buffer): Promise<string> => {\n  const hashSum = _createHash('sha256');\n  hashSum.update(content);\n  return hashSum.digest('hex');\n};\n\nconst _hmac = async (key: string | Buffer, content: string, encoding?: 'hex'): Promise<string> => {\n  const hmacSum = _createHmac('sha256', key);\n  hmacSum.update(content);\n  return hmacSum.digest(encoding);\n};\nexport const sanitizeETag = (etag: string): string => {\n  const replaceChars: Record<string, string> = {\n    '\"': '',\n    '&quot;': '',\n    '&#34;': '',\n    '&QUOT;': '',\n    '&#x00022': '',\n  };\n  return etag.replace(/^(\"|&quot;|&#34;)|(\"|&quot;|&#34;)$/g, m => replaceChars[m] as string);\n};\n\nconst _parseXml = (str: string): string | object | any => {\n  const unescapeXml = (value: string): string => {\n    return value\n      .replace(/&quot;/g, '\"')\n      .replace(/&apos;/g, \"'\")\n      .replace(/&lt;/g, '<')\n      .replace(/&gt;/g, '>')\n      .replace(/&amp;/g, '&');\n  };\n\n  const json = {};\n  const re = /<(\\w)([-\\w]+)(?:\\/|[^>]*>((?:(?!<\\1)[\\s\\S])*)<\\/\\1\\2)>/gm;\n  let match;\n\n  while ((match = re.exec(str))) {\n    const [, prefix, key, value] = match;\n    const fullKey = prefix.toLowerCase() + key;\n    const parsedValue = value != null ? _parseXml(value) : true;\n\n    if (typeof parsedValue === 'string') {\n      (json as { [key: string]: any })[fullKey] = sanitizeETag(unescapeXml(parsedValue));\n    } else if (Array.isArray((json as { [key: string]: any })[fullKey])) {\n      (json as { [key: string]: any })[fullKey].push(parsedValue);\n    } else {\n      (json as { [key: string]: any })[fullKey] =\n        (json as { [key: string]: any })[fullKey] != null\n          ? [(json as { [key: string]: any })[fullKey], parsedValue]\n          : expectArray[fullKey]\n            ? [parsedValue]\n            : parsedValue;\n    }\n  }\n\n  return Object.keys(json).length ? json : unescapeXml(str);\n};\n\nexport { S3 };\nexport default S3;\n", "'use strict';\n\nimport { S3 } from 'ultralight-s3';\nimport avro from 'avro-js'; // eslint-disable-line\nimport {\n\tlowstorage_ERROR_CODES,\n\tlowstorageError,\n\tCollectionNotFoundError,\n\tSchemaValidationError,\n\tDocumentValidationError,\n\tS3OperationError,\n} from './errors.js';\nimport { matchesQuery, generateUUID, inferAvroType } from './helpers.js';\n\nconst MODULE_NAME = 'lowstorage';\nconst DEFAULT_DELIMITER = '/';\nconst PROJECT_DIR_PREFIX = 'lowstorage';\nconst COL_SUFFIX = '.avro';\nconst CHUNG_1MB = 1024 * 1024;\nconst CHUNG_5MB = 5 * CHUNG_1MB;\nconst EMPTY_DATA = Buffer.from('', 'utf8');\n\nconst errorValidationFn = (errorCode = lowstorage_ERROR_CODES.DOCUMENT_VALIDATION_ERROR) => {\n\tthrow new DocumentValidationError(`${MODULE_NAME}: Invalid document or schema`, errorCode);\n};\n\nconst _hasColName = (colName) => {\n\tif (colName.trim() === '' || colName === null || typeof colName === 'undefined' || colName.length > 255 || colName === null) {\n\t\tthrow new lowstorageError(`${MODULE_NAME}: Collection name is required, null or too long`, lowstorage_ERROR_CODES.MISSING_ARGUMENT);\n\t}\n};\n\n// code / description\n// init of new collection is automatically creating it in the bucket\n// there is optional (opt-in) switch to create new collections in bucket\n// if the schema is not provided, it will create empty buffer and save it\n// if the schema is provided, it will save it in memory and use it for all ops\n// if the schema is updated, it will save it in memory and use it for all ops\n// exposed functions are:\n// listCollections \u2705\n// collectionExists \u2705\n// createCollection \u2705\n// removeCollection \u2705\n// renameCollection \u2705\n// updateCollectionSchema \u274C\n// collection \u2705\n// s3 \u2705\n\n// Operations over collections are:\n// insert \u2705\n// find \u2705\n// findOne \u2705\n// update \u2705\n// updateOne \u2705\n// delete \u2705\n// count \u2705\n\n// Errors:\n// lowstorageError \u2705\n// CollectionNotFoundError \u2705\n// SchemaValidationError \u2705\n// DocumentValidationError \u2705\n// S3OperationError \u2705\n\n/**\n * lowstorage class for managing collections and performing operations on top of S3-compatible storages.\n * @class\n * @example\n * const storage = new lowstorage({\n * \taccessKeyId: 'YOUR_ACCESS_KEY',\n * \tsecretAccessKey: 'YOUR_SECRET_KEY',\n * \tendpoint: 'YOUR_ENDPOINT',\n * \tbucketName: 'YOUR_BUCKET_NAME',\n * \tregion: 'YOUR_REGION',\n * });\n *\n * // Create a collection\n * const userCol = await storage.collection('users');\n *\n * // Insert a document\n * await userCol.insert({\n * \tname: 'Kevin',\n * \tgender: 'whatever',\n * \tposts: [],\n * });\n *\n * // Show all users\n * const allUsers = await userCol.find({});\n *\n * // Find users with pagination (e.g., page 2, 10 users per page)\n * const secondPageUsers = await userCol.find({}, { skip: 10, limit: 10 });\n *\n * // Find user by ID and update name\n * await userCol.update({ _id: id }, { name: 'Carlos' });\n */\nclass lowstorage {\n\t/**\n\t * Create a new lowstorage instance.\n\t * @param {Object} options - Configuration options for lowstorage.\n\t * @param {string} options.accessKeyId - S3 access key ID.\n\t * @param {string} options.secretAccessKey - S3 secret access key.\n\t * @param {string} options.endpoint - S3 endpoint URL.\n\t * @param {string} options.bucketName - S3 bucket name.\n\t * @param {string} [options.region='auto'] - S3 region.\n\t * @param {Object} [options.logger=null] - Logger object.\n\t * @param {string} [options.dirPrefix=PROJECT_DIR_PREFIX] - Directory prefix for collections.\n\t * @returns {lowstorage} A new lowstorage instance.\n\t */\n\tconstructor(\n\t\toptions = {\n\t\t\taccessKeyId: undefined,\n\t\t\tsecretAccessKey: undefined,\n\t\t\tendpoint: undefined,\n\t\t\tbucketName: undefined,\n\t\t\tregion: 'auto',\n\t\t\tlogger: null,\n\t\t\tdirPrefix: PROJECT_DIR_PREFIX,\n\t\t},\n\t) {\n\t\tthis._checkArgs(options);\n\t\tthis._schemas = new Map();\n\t\tthis._s3 = new S3(options);\n\t\tthis._dirPrefix = options.dirPrefix || PROJECT_DIR_PREFIX;\n\t\tthis._avro = avro;\n\t}\n\n\t_checkArgs = (args) => {\n\t\tconst requiredFields = ['accessKeyId', 'secretAccessKey', 'endpoint', 'bucketName'];\n\t\tfor (const field of requiredFields) {\n\t\t\tif (!args[field]) {\n\t\t\t\tthrow new lowstorageError(`${MODULE_NAME}: ${field} is required`, lowstorage_ERROR_CODES.MISSING_ARGUMENT);\n\t\t\t}\n\t\t}\n\t};\n\n\t/**\n\t * List all collections.\n\t * @returns {Promise<string[]>} An array of collection names.\n\t * @throws {S3OperationError} If there's an error during S3 operation.\n\t */\n\tasync listCollections() {\n\t\ttry {\n\t\t\tconst listed = await this._s3.list(DEFAULT_DELIMITER, this._dirPrefix);\n\t\t\tif (typeof listed === 'object' && listed !== null && listed.keyCount === '0') return [];\n\t\t\t// remove the delimiter from the key\n\t\t\treturn listed.map((entry) => entry.key.slice(this._dirPrefix.length + 1, -COL_SUFFIX.length));\n\t\t} catch (error) {\n\t\t\tthrow new S3OperationError(`${MODULE_NAME}: ${error.message}`, lowstorage_ERROR_CODES.S3_OPERATION_ERROR);\n\t\t}\n\t}\n\n\t/**\n\t * Check if a collection exists.\n\t * @param {string} colName - The name of the collection.\n\t * @returns {Promise<boolean>} True if the collection exists, false otherwise.\n\t * @throws {lowstorageError} If there's an error.\n\t */\n\tasync collectionExists(colName) {\n\t\ttry {\n\t\t\t_hasColName(colName);\n\t\t\tconst exists = await this._s3.fileExists(`${this._dirPrefix}${DEFAULT_DELIMITER}${colName}${COL_SUFFIX}`);\n\t\t\tconsole.log('collectionExists::2 ', `${this._dirPrefix}${DEFAULT_DELIMITER}${colName}${COL_SUFFIX}`, exists);\n\t\t\treturn !!exists;\n\t\t} catch (error) {\n\t\t\tif (error.message.includes('Not Found')) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tconsole.log('collectionExists::3 ', colName, error);\n\t\t\tthrow new lowstorageError(`${MODULE_NAME}: ${error.message}`, lowstorage_ERROR_CODES.COLLECTION_NOT_FOUND);\n\t\t}\n\t}\n\n\t/**\n\t * Create a new collection.\n\t * @param {string} colName - The name of the collection.\n\t * @param {Object} [schema] - The schema for the collection.\n\t * @param {Array} [data=[]] - The initial data for the collection.\n\t * @returns {Promise<Collection>} A Promise that resolves to a Collection object.\n\t * @throws {lowstorageError} If there's an error.\n\t */\n\tasync createCollection(colName, schema, data = []) {\n\t\ttry {\n\t\t\t_hasColName(colName);\n\t\t\tconst exists = await this.collectionExists(colName);\n\t\t\tif (!exists) {\n\t\t\t\tif (data.length > 0 && schema) {\n\t\t\t\t\tconst wrapperType = this._avro.parse({ type: 'array', items: schema });\n\t\t\t\t\tawait this._s3.put(`${this._dirPrefix}${DEFAULT_DELIMITER}${colName}${COL_SUFFIX}`, wrapperType.toBuffer(data));\n\t\t\t\t} else {\n\t\t\t\t\tawait this._s3.put(`${this._dirPrefix}${DEFAULT_DELIMITER}${colName}${COL_SUFFIX}`, EMPTY_DATA);\n\t\t\t\t}\n\t\t\t\treturn this.collection(colName, schema, false);\n\t\t\t}\n\t\t\tthrow new lowstorageError(`${MODULE_NAME}: Collection ${colName} already exists`, lowstorage_ERROR_CODES.COLLECTION_EXISTS);\n\t\t} catch (error) {\n\t\t\tif (error instanceof lowstorageError) {\n\t\t\t\tthrow error;\n\t\t\t}\n\t\t\tthrow new lowstorageError(`${MODULE_NAME}: ${error.message}`, lowstorage_ERROR_CODES.CREATE_COLLECTION_ERROR);\n\t\t}\n\t}\n\n\t/**\n\t * Remove a collection.\n\t * @param {string} colName - The name of the collection.\n\t * @returns {Promise<boolean>} A Promise that resolves to true if the collection is removed, false otherwise.\n\t * @throws {lowstorageError} If there's an error.\n\t */\n\tasync removeCollection(colName) {\n\t\ttry {\n\t\t\t_hasColName(colName);\n\t\t\tconst KEY = `${this._dirPrefix}${DEFAULT_DELIMITER}${colName}${COL_SUFFIX}`;\n\t\t\tconst exists = await this.collectionExists(colName);\n\t\t\tif (exists) {\n\t\t\t\tawait this._s3.delete(KEY);\n\t\t\t\tconst exists2 = await this.collectionExists(colName);\n\t\t\t\tif (typeof exists2 === 'boolean') {\n\t\t\t\t\tif (!exists2) {\n\t\t\t\t\t\tthis._schemas.delete(colName);\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\tthrow new lowstorageError(`${MODULE_NAME}: Failed to delete collection ${colName}`, lowstorage_ERROR_CODES.S3_OPERATION_ERROR);\n\t\t\t\t}\n\t\t\t\tthrow new S3OperationError(`${MODULE_NAME}: Failed to delete collection ${colName}`, lowstorage_ERROR_CODES.S3_OPERATION_ERROR);\n\t\t\t}\n\t\t\tthrow new lowstorageError(`${MODULE_NAME}: Collection ${colName} does not exist`, lowstorage_ERROR_CODES.REMOVE_COLLECTION_ERROR);\n\t\t} catch (error) {\n\t\t\tif (error instanceof S3OperationError) {\n\t\t\t\tthrow error;\n\t\t\t}\n\t\t\tthrow new lowstorageError(\n\t\t\t\t`${MODULE_NAME}: Failed to remove collection: ${error.message}`,\n\t\t\t\tlowstorage_ERROR_CODES.REMOVE_COLLECTION_ERROR,\n\t\t\t);\n\t\t}\n\t}\n\n\t/**\n\t * Get or create a collection.\n\t * @param {string} colName - The name of the collection.\n\t * @param {Object} [schema] - The schema for the collection.\n\t * @param {boolean} [autoCreate=true] - Whether to automatically create the collection if it doesn't exist.\n\t * @returns {Promise<Collection>} A Promise that resolves to a Collection object.\n\t * @throws {lowstorageError} If there's an error.\n\t */\n\tasync collection(colName, schema, autoCreate = true) {\n\t\ttry {\n\t\t\t_hasColName(colName);\n\t\t\tconst colPath = `${this._dirPrefix}${DEFAULT_DELIMITER}${colName}${COL_SUFFIX}`;\n\t\t\tconst exists = await this._s3.fileExists(colPath);\n\t\t\tif (!exists) {\n\t\t\t\tif (!autoCreate) {\n\t\t\t\t\tthrow new lowstorageError(`${MODULE_NAME}: Collection ${colName} does not exist`, lowstorage_ERROR_CODES.COLLECTION_NOT_FOUND);\n\t\t\t\t}\n\t\t\t\t// TODO: check if this is the right way to handle empty data\n\t\t\t\tawait this._s3.put(colPath, EMPTY_DATA);\n\t\t\t}\n\t\t\tconst colSchema = schema || this._schemas.get(colName) || undefined;\n\t\t\treturn new Collection(colName, colSchema, this._s3, this._dirPrefix);\n\t\t} catch (error) {\n\t\t\t// check if error message contains \"unknown type\" and if so, throw a schema validation error\n\t\t\tif (error.message.includes('unknown type')) {\n\t\t\t\tthrow new SchemaValidationError(\n\t\t\t\t\t`${MODULE_NAME}: Schema input is invalid: ${error.message}`,\n\t\t\t\t\tlowstorage_ERROR_CODES.SCHEMA_VALIDATION_ERROR,\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tthrow new lowstorageError(`${MODULE_NAME}: ${error.message}`, lowstorage_ERROR_CODES.COLLECTION_NOT_FOUND);\n\t\t}\n\t}\n\n\t/**\n\t * Get the S3 instance associated with the lowstorage instance.\n\t * @returns {S3} The S3 instance. Use this to perform S3 operations. Check for ultralight-s3 for more details.\n\t */\n\ts3 = () => {\n\t\treturn this._s3;\n\t};\n}\n\n/**\n * Collection class for managing documents in a collection.\n * @class\n * @example\n * const storage = new lowstorage({\n * \taccessKeyId: 'YOUR_ACCESS_KEY',\n * \tsecretAccessKey: 'YOUR_SECRET_KEY',\n * \tendpoint: 'YOUR_ENDPOINT',\n * \tbucketName: 'YOUR_BUCKET_NAME',\n * \tregion: 'YOUR_REGION',\n * });\n *\n * // Create a collection\n * const userCol = await storage.collection('users');\n *\n * // Insert a document\n * await userCol.insert({\n * \tname: 'Kevin',\n * \tgender: 'whatever',\n * \tposts: [],\n * });\n *\n * // Show all users\n * const allUsers = await userCol.find({});\n *\n * // Find users with pagination (e.g., page 2, 10 users per page)\n * const secondPageUsers = await userCol.find({}, { skip: 10, limit: 10 });\n *\n * // Find user by ID and update name\n * await userCol.update({ _id: id }, { name: 'Carlos' });\n */\nclass Collection {\n\t/**\n\t * Create a new Collection instance.\n\t * @param {string} colName - The name of the collection.\n\t * @param {S3} s3 - The S3 instance.\n\t * @param {Object} [schema] - The Avro schema for the collection.\n\t * @param {string} [dirPrefix=PROJECT_DIR_PREFIX] - The directory prefix for the collection.\n\t * @param {boolean} [safeWrite=false] - Whether to perform a safe write operation. It doublechecks the ETag of the object before writing. False = overwrites the object, True = only writes if the object has not been modified.\n\t * @returns {Collection} A new Collection instance.\n\t */\n\tconstructor(colName, schema, s3, dirPrefix = PROJECT_DIR_PREFIX, safeWrite = false) {\n\t\tthis._colName = colName;\n\t\tthis._s3 = s3;\n\t\tthis._avro = avro;\n\t\tthis._lastETag = '';\n\t\tthis._dataCache = [];\n\t\tthis._schema = schema;\n\t\tthis._avroType = typeof schema === 'undefined' ? null : this._avro.parse(schema);\n\t\tthis._dirPrefix = dirPrefix;\n\t\tthis._safeWrite = safeWrite;\n\t}\n\n\tgetProps = () => ({\n\t\tcolName: this._colName,\n\t\ts3: this._s3,\n\t\tavro: this._avro,\n\t\tavroType: this._avroType,\n\t\tdirPrefix: this._dirPrefix,\n\t\tsafeWrite: this._safeWrite,\n\t});\n\n\tsetProps = (props) => {\n\t\tthis._colName = props.colName;\n\t\tthis._s3 = props.s3;\n\t\tthis._avro = props.avro;\n\t\tthis._schema = props.schema;\n\t\tthis._avroType = props.avroType;\n\t\tthis._dirPrefix = props.dirPrefix;\n\t\tthis._safeWrite = props.safeWrite;\n\t};\n\n\tsetSafeWrite = (safeWrite) => {\n\t\tthis._safeWrite = safeWrite;\n\t};\n\n\tgetSafeWrite = () => {\n\t\treturn this._safeWrite;\n\t};\n\n\tgetAvroSchema = () => {\n\t\treturn this._avroType;\n\t};\n\n\tsetAvroSchema = (schema) => {\n\t\tthis._schema = schema;\n\t\tthis._avroType = typeof schema === 'undefined' ? null : this._avro.parse(schema);\n\t};\n\n\tasync _loadData() {\n\t\ttry {\n\t\t\tconst KEY = `${this._dirPrefix}${DEFAULT_DELIMITER}${this._colName}${COL_SUFFIX}`;\n\t\t\tconst CHUNK_SIZE = this._s3.getMaxRequestSizeInBytes() || CHUNG_5MB;\n\t\t\tif (this._avroType === null || typeof this._avroType === 'undefined') {\n\t\t\t\tthrow new lowstorageError(\n\t\t\t\t\t`${MODULE_NAME}: Missing type definition. Configure before operations `,\n\t\t\t\t\tlowstorage_ERROR_CODES.SCHEMA_VALIDATION_ERROR,\n\t\t\t\t);\n\t\t\t}\n\t\t\tconsole.log('Getting object:', KEY, this._lastETag);\n\t\t\tlet { etag, data } = await this._s3.getObjectWithETag(KEY, { 'if-none-match': this._lastETag });\n\t\t\tconsole.log('data :::::::::::::::::::::::::', data, etag, this._dataCache);\n\t\t\tif (data === null) {\n\t\t\t\t// console.log('data is null, returning cache');\n\t\t\t\treturn this._dataCache;\n\t\t\t}\n\t\t\tthis._lastETag = etag === null ? this._lastETag : etag;\n\t\t\tconst wrapperType = this._avro.parse({ type: 'array', items: this._avroType });\n\t\t\tif (data.length < CHUNK_SIZE) {\n\t\t\t\tthis._dataCache = data.length > 0 ? wrapperType.fromBuffer(data) : [];\n\t\t\t\treturn this._dataCache;\n\t\t\t}\n\t\t\tlet offset = CHUNK_SIZE;\n\t\t\tlet bufferArr = [Buffer.from(data, 'utf8')];\n\t\t\tlet repeat = true;\n\t\t\twhile (repeat) {\n\t\t\t\tconst nextDataResponse = await this._s3.getResponse(KEY, false, offset, offset + CHUNK_SIZE);\n\t\t\t\tconst nextDataBody = await nextDataResponse.text();\n\t\t\t\tbufferArr.push(Buffer.from(nextDataBody, 'utf8'));\n\t\t\t\toffset += CHUNK_SIZE;\n\t\t\t\tconst contentLength = nextDataResponse.headers.get('content-length') || nextDataBody.length;\n\t\t\t\tif (contentLength < CHUNK_SIZE) {\n\t\t\t\t\trepeat = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tconst bufferedData = Buffer.concat(bufferArr);\n\t\t\tthis._dataCache = wrapperType.fromBuffer(bufferedData);\n\t\t\treturn this._dataCache;\n\t\t} catch (error) {\n\t\t\tif (error.toString().indexOf('status 404: Unknown - Not Found') > -1) {\n\t\t\t\tthis._dataCache = [];\n\t\t\t\treturn this._dataCache;\n\t\t\t}\n\t\t\tthrow new S3OperationError(`${MODULE_NAME}: Failed to load data: ${error.message}`, lowstorage_ERROR_CODES.S3_OPERATION_ERROR);\n\t\t}\n\t}\n\n\tasync _saveData(data) {\n\t\ttry {\n\t\t\tif (this._avroType === null || typeof this._avroType === 'undefined') {\n\t\t\t\tthrow new lowstorageError(\n\t\t\t\t\t`${MODULE_NAME}: Missing type definition. Configure before operations `,\n\t\t\t\t\tlowstorage_ERROR_CODES.SCHEMA_VALIDATION_ERROR,\n\t\t\t\t);\n\t\t\t}\n\t\t\tconst wrapperType = this._avro.parse({ type: 'array', items: this._avroType });\n\t\t\tconst dataBuffer = data.length > 0 ? wrapperType.toBuffer(data) : EMPTY_DATA; // TODO: check if this is the right way to handle empty data\n\n\t\t\tconst KEY = `${this._dirPrefix}${DEFAULT_DELIMITER}${this._colName}${COL_SUFFIX}`;\n\t\t\tif (this._safeWrite && this._lastETag !== '') {\n\t\t\t\tconst currentETag = await this._s3.getEtag(KEY);\n\t\t\t\t// If we have a current ETag, check if it matches our last known ETag\n\t\t\t\tif (currentETag !== null && currentETag !== this._lastETag) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst resp = await this._s3.put(KEY, dataBuffer);\n\t\t\tif (resp.status !== 200) {\n\t\t\t\tthrow new S3OperationError(`${MODULE_NAME}: Failed to save data`, lowstorage_ERROR_CODES.S3_OPERATION_ERROR);\n\t\t\t}\n\n\t\t\t// Update the cached ETag\n\t\t\tconst newETag = resp.headers.get('etag');\n\t\t\t// console.log('saveddata newETag', this._s3.sanitizeETag(newETag));\n\t\t\tif (newETag) {\n\t\t\t\tthis._lastETag = this._s3.sanitizeETag(newETag);\n\t\t\t\t// console.log('saveddata lastETag', this._lastETag, 'data is ', data);\n\t\t\t\tthis._dataCache = data;\n\t\t\t}\n\t\t\treturn true;\n\t\t} catch (error) {\n\t\t\tif (error instanceof S3OperationError) {\n\t\t\t\tthrow error;\n\t\t\t}\n\t\t\tthrow new lowstorageError(`${MODULE_NAME}: ${error.message}`, lowstorage_ERROR_CODES.SAVE_DATA_ERROR);\n\t\t}\n\t}\n\n\t/**\n\t * Insert a document into the collection.\n\t * @param {Object|Array} doc - The document to insert.\n\t * @param {Object} [schema=undefined] - The schema for the document.\n\t * @returns {Promise<Array>} A Promise that resolves to the array of inserted document(s).\n\t * @throws {lowstorageError} If there's an error.\n\t */\n\tasync insert(doc, schema = undefined) {\n\t\ttry {\n\t\t\tif (doc === undefined || doc === null) {\n\t\t\t\tthrow new lowstorageError(`${MODULE_NAME}: Document is required for insert`, lowstorage_ERROR_CODES.INSERT_ERROR);\n\t\t\t}\n\t\t\tif (typeof doc !== 'object' && !Array.isArray(doc)) {\n\t\t\t\tthrow new DocumentValidationError(\n\t\t\t\t\t`${MODULE_NAME}: Document must be an object or an array`,\n\t\t\t\t\tlowstorage_ERROR_CODES.DOCUMENT_VALIDATION_ERROR,\n\t\t\t\t);\n\t\t\t}\n\t\t\tconst items = !Array.isArray(doc) ? [doc] : doc;\n\n\t\t\tconst schemaWithId = schema || this._avroType || inferAvroType(items[0]);\n\t\t\tconst avroType = this._avro.parse(schemaWithId);\n\t\t\tif (!avroType) {\n\t\t\t\tthrow new SchemaValidationError(\n\t\t\t\t\t`${MODULE_NAME}: Schema is required - Pass a schema to the insert method`,\n\t\t\t\t\tlowstorage_ERROR_CODES.SCHEMA_VALIDATION_ERROR,\n\t\t\t\t);\n\t\t\t}\n\t\t\tthis._avroType = avroType;\n\t\t\tconst data = await this._loadData();\n\t\t\tfor (let item of items) {\n\t\t\t\tif (typeof item !== 'object' || item === null) {\n\t\t\t\t\tthrow new DocumentValidationError(\n\t\t\t\t\t\t`${MODULE_NAME}: Invalid input: input must be an object or an array of objects`,\n\t\t\t\t\t\tlowstorage_ERROR_CODES.DOCUMENT_VALIDATION_ERROR,\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\titem._id = item._id || (await generateUUID());\n\t\t\t\tconst validBuffer = this._avroType.isValid(item, {\n\t\t\t\t\terrorHook: errorValidationFn,\n\t\t\t\t\tnoUndeclaredFields: true,\n\t\t\t\t});\n\t\t\t\tif (validBuffer === true) {\n\t\t\t\t\tdata.push(item);\n\t\t\t\t} else {\n\t\t\t\t\tthrow new DocumentValidationError(`${MODULE_NAME}: Invalid document or schema`, lowstorage_ERROR_CODES.DOCUMENT_VALIDATION_ERROR);\n\t\t\t\t}\n\t\t\t}\n\t\t\tconst success = await this._saveData(data);\n\t\t\tif (!success) {\n\t\t\t\tthrow new S3OperationError(`${MODULE_NAME}: Failed to insert document`, lowstorage_ERROR_CODES.S3_OPERATION_ERROR);\n\t\t\t}\n\t\t\treturn items;\n\t\t} catch (error) {\n\t\t\tif (error.message.includes('unknown type')) {\n\t\t\t\tthrow new SchemaValidationError(\n\t\t\t\t\t`${MODULE_NAME}: Schema input is invalid: ${error.message}`,\n\t\t\t\t\tlowstorage_ERROR_CODES.SCHEMA_VALIDATION_ERROR,\n\t\t\t\t);\n\t\t\t}\n\t\t\tif (error instanceof lowstorageError) {\n\t\t\t\tthrow error;\n\t\t\t}\n\t\t\tthrow new lowstorageError(`${MODULE_NAME} Insert operation failed: ${error.message}`, lowstorage_ERROR_CODES.INSERT_ERROR);\n\t\t}\n\t}\n\n\t/**\n\t * Find documents in the collection.\n\t * @param {Object} [query={}] - The query to filter documents.\n\t * @param {Object} [options={}] - The options for pagination.\n\t * @param {number} [options.skip=0] - The number of documents to skip. Default is 0.\n\t * @param {number} [options.limit=undefined] - The maximum number of documents to return. Default is undefined, which means no limit.\n\t * @returns {Promise<Array>} A Promise that resolves to an array of matching documents.\n\t * @throws {lowstorageError} If there's an error.\n\t */\n\tasync find(query = {}, options = {}) {\n\t\ttry {\n\t\t\tif (query === undefined || query === null) {\n\t\t\t\tthrow new lowstorageError(`${MODULE_NAME}: Query is required for update`, lowstorage_ERROR_CODES.MISSING_ARGUMENT);\n\t\t\t}\n\t\t\tconst data = await this._loadData();\n\t\t\tconst start = parseInt(options.skip, 10) || 0;\n\t\t\tconst end = parseInt(options.limit, 10) ? start + parseInt(options.limit, 10) : undefined;\n\t\t\tconst filteredData = data.filter((doc) => matchesQuery(doc, query)).slice(start, end);\n\t\t\treturn filteredData;\n\t\t} catch (error) {\n\t\t\tthrow new lowstorageError(`${MODULE_NAME}: Find operation failed: ${error.message}`, lowstorage_ERROR_CODES.FIND_ERROR);\n\t\t}\n\t}\n\n\t/**\n\t * Find the first document in the collection that matches the query.\n\t * @param {Object} [query={}] - The query to filter documents.\n\t * @returns {Promise<Object|null>} A Promise that resolves to the first matching document or null if no match is found.\n\t * @throws {lowstorageError} If there's an error.\n\t */\n\tasync findOne(query = {}) {\n\t\ttry {\n\t\t\tif (query === null) {\n\t\t\t\tthrow new lowstorageError(`${MODULE_NAME}: Query cannot be null`, lowstorage_ERROR_CODES.INVALID_ARGUMENT);\n\t\t\t}\n\t\t\tconst result = await this.find(query, { limit: 1 });\n\t\t\treturn result[0] || null;\n\t\t} catch (error) {\n\t\t\tif (error instanceof lowstorageError) {\n\t\t\t\tthrow error;\n\t\t\t}\n\t\t\tthrow new lowstorageError(`${MODULE_NAME}: FindOne operation failed: ${error.message}`, lowstorage_ERROR_CODES.FIND_ONE_ERROR);\n\t\t}\n\t}\n\n\t/**\n\t * Update a single document in the collection that matches the query.\n\t * @param {Object} [query={}] - The query to filter the document to update.\n\t * @param {Object} [update={}] - The update operations to apply to the matching document.\n\t * @returns {Promise<number>} A Promise that resolves to number of documents updated.\n\t * @throws {lowstorageError} If the updateOne operation fails.\n\t * @throws {SchemaValidationError} If the schema is not defined for the collection.\n\t * @throws {DocumentValidationError} If the updated document is invalid.\n\t * @throws {S3OperationError} If the S3 operation fails.\n\t */\n\tasync update(query = {}, update = {}, options = {}) {\n\t\ttry {\n\t\t\tif (query === undefined || query === null || update === undefined || update === null) {\n\t\t\t\tthrow new lowstorageError(\n\t\t\t\t\t`${MODULE_NAME}: Query and update values are required for update`,\n\t\t\t\t\tlowstorage_ERROR_CODES.MISSING_ARGUMENT,\n\t\t\t\t);\n\t\t\t}\n\t\t\tif (!this._avroType) {\n\t\t\t\tthrow new SchemaValidationError(\n\t\t\t\t\t`${MODULE_NAME}: Schema is not defined for this collection`,\n\t\t\t\t\tlowstorage_ERROR_CODES.SCHEMA_VALIDATION_ERROR,\n\t\t\t\t);\n\t\t\t}\n\t\t\tconst data = await this._loadData();\n\t\t\tif (data.length === 0) return 0;\n\t\t\tlet updatedCount = 0;\n\t\t\tfor (let i = 0; i < data.length; i++) {\n\t\t\t\tif (matchesQuery(data[i], query)) {\n\t\t\t\t\tconst updatedDoc = { ...data[i], ...update };\n\t\t\t\t\tconst isValid = this._avroType.isValid(updatedDoc, {\n\t\t\t\t\t\terrorHook: errorValidationFn,\n\t\t\t\t\t\tnoUndeclaredFields: true,\n\t\t\t\t\t});\n\t\t\t\t\tif (isValid === true) {\n\t\t\t\t\t\tdata[i] = updatedDoc;\n\t\t\t\t\t\tupdatedCount++;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow new DocumentValidationError(\n\t\t\t\t\t\t\t`${MODULE_NAME}: Invalid document or schema`,\n\t\t\t\t\t\t\tlowstorage_ERROR_CODES.DOCUMENT_VALIDATION_ERROR,\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (updatedCount > 0) {\n\t\t\t\tconst success = await this._saveData(data);\n\t\t\t\tif (!success) {\n\t\t\t\t\tthrow new S3OperationError(`${MODULE_NAME}: Failed to update document`, lowstorage_ERROR_CODES.S3_OPERATION_ERROR);\n\t\t\t\t}\n\t\t\t} else if (options.upsert) {\n\t\t\t\t// If upsert is true, we need to insert the document\n\t\t\t\tconst success = await this.insert(update);\n\t\t\t\tif (!success) {\n\t\t\t\t\tthrow new S3OperationError(`${MODULE_NAME}: Failed to update document`, lowstorage_ERROR_CODES.S3_OPERATION_ERROR);\n\t\t\t\t}\n\t\t\t\tupdatedCount = 1;\n\t\t\t}\n\t\t\treturn updatedCount;\n\t\t} catch (error) {\n\t\t\tif (error instanceof S3OperationError) {\n\t\t\t\tthrow error;\n\t\t\t}\n\t\t\tthrow new lowstorageError(`${MODULE_NAME}: Update operation failed: ${error.message}`, lowstorage_ERROR_CODES.UPDATE_ERROR);\n\t\t}\n\t}\n\n\t/**\n\t * Update a single document in the collection that matches the query.\n\t * @param {Object} [query={}] - The query to filter the document to update.\n\t * @param {Object} [update={}] - The update operations to apply to the matching document.\n\t * @returns {Promise<number>} A Promise that resolves to 1 if a document was updated, 0 otherwise.\n\t * @throws {lowstorageError} If the updateOne operation fails.\n\t * @throws {SchemaValidationError} If the schema is not defined for the collection.\n\t * @throws {DocumentValidationError} If the updated document is invalid.\n\t * @throws {S3OperationError} If the S3 operation fails.\n\t */\n\tasync updateOne(query = {}, update = {}, options = {}) {\n\t\ttry {\n\t\t\tif (query === undefined || query === null || update === undefined || update === null) {\n\t\t\t\tthrow new lowstorageError(`${MODULE_NAME}: Query is required`, lowstorage_ERROR_CODES.MISSING_ARGUMENT);\n\t\t\t}\n\t\t\tif (!this._avroType) {\n\t\t\t\tthrow new SchemaValidationError(\n\t\t\t\t\t`${MODULE_NAME}: Schema is not defined for this collection`,\n\t\t\t\t\tlowstorage_ERROR_CODES.SCHEMA_VALIDATION_ERROR,\n\t\t\t\t);\n\t\t\t}\n\t\t\tconst data = await this._loadData();\n\t\t\tif (data.length === 0) return 0;\n\t\t\tconst docIndex = data.findIndex((doc) => matchesQuery(doc, query));\n\n\t\t\tif (docIndex !== -1) {\n\t\t\t\tconst updatedDoc = { ...data[docIndex], ...update };\n\t\t\t\tconst isValid = this._avroType.isValid(updatedDoc, {\n\t\t\t\t\terrorHook: errorValidationFn,\n\t\t\t\t\tnoUndeclaredFields: true,\n\t\t\t\t});\n\t\t\t\tif (isValid === true) {\n\t\t\t\t\tdata[docIndex] = updatedDoc;\n\t\t\t\t\tconst success = await this._saveData(data);\n\t\t\t\t\tif (!success) {\n\t\t\t\t\t\tthrow new S3OperationError(`${MODULE_NAME}: Failed to update document`, lowstorage_ERROR_CODES.S3_OPERATION_ERROR);\n\t\t\t\t\t}\n\t\t\t\t\treturn 1;\n\t\t\t\t} else {\n\t\t\t\t\tthrow new DocumentValidationError(`${MODULE_NAME}: Invalid document or schema`, lowstorage_ERROR_CODES.DOCUMENT_VALIDATION_ERROR);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (options.upsert) {\n\t\t\t\t// If upsert is true, we need to insert the document\n\t\t\t\tconst success = await this.insert(update);\n\t\t\t\tif (!success) {\n\t\t\t\t\tthrow new S3OperationError(`${MODULE_NAME}: Failed to update document`, lowstorage_ERROR_CODES.S3_OPERATION_ERROR);\n\t\t\t\t}\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\treturn 0;\n\t\t} catch (error) {\n\t\t\tif (error instanceof lowstorageError) {\n\t\t\t\tthrow error;\n\t\t\t}\n\t\t\tthrow new lowstorageError(`${MODULE_NAME}: UpdateOne operation failed: ${error.message}`, lowstorage_ERROR_CODES.UPDATE_ONE_ERROR);\n\t\t}\n\t}\n\n\t/**\n\t * Delete documents from the collection.\n\t * @param {Object} [query={}] - The query to filter documents to delete.\n\t * @returns {Promise<number>} A Promise that resolves to the number of documents deleted.\n\t * @throws {lowstorageError} If the delete operation fails.\n\t * @throws {S3OperationError} If the S3 operation fails.\n\t */\n\tasync delete(query = {}) {\n\t\ttry {\n\t\t\tif (query === undefined || query === null) {\n\t\t\t\tthrow new lowstorageError(`${MODULE_NAME}: Query is required`, lowstorage_ERROR_CODES.MISSING_ARGUMENT);\n\t\t\t}\n\t\t\tconst data = await this._loadData();\n\t\t\tif (data.length === 0) return 0;\n\t\t\tconst initialLength = data.length;\n\n\t\t\tconst newData = data.filter((doc) => !matchesQuery(doc, query));\n\t\t\tconst success = await this._saveData(newData);\n\t\t\tif (!success) {\n\t\t\t\tthrow new S3OperationError(`${MODULE_NAME}: Failed to delete document`, lowstorage_ERROR_CODES.S3_OPERATION_ERROR);\n\t\t\t}\n\t\t\treturn initialLength - newData.length;\n\t\t} catch (error) {\n\t\t\tif (error instanceof S3OperationError) {\n\t\t\t\tthrow error;\n\t\t\t}\n\t\t\tthrow new lowstorageError(`${MODULE_NAME}: Delete operation failed: ${error.message}`, lowstorage_ERROR_CODES.DELETE_ERROR);\n\t\t}\n\t}\n\n\t/**\n\t * Delete all documents from the collection.\n\t * @returns {Promise<number>} A Promise that resolves to the number of documents deleted.\n\t * @throws {lowstorageError} If the delete operation fails.\n\t * @throws {S3OperationError} If the S3 operation fails.\n\t */\n\tasync deleteAll() {\n\t\ttry {\n\t\t\tconst data = await this._loadData();\n\t\t\tconst initialLength = data.length;\n\t\t\tconst success = await this._saveData([]);\n\t\t\tif (!success) {\n\t\t\t\tthrow new S3OperationError(`${MODULE_NAME}: Failed to delete document`, lowstorage_ERROR_CODES.S3_OPERATION_ERROR);\n\t\t\t}\n\t\t\treturn initialLength;\n\t\t} catch (error) {\n\t\t\tif (error instanceof S3OperationError) {\n\t\t\t\tthrow error;\n\t\t\t}\n\t\t\tthrow new lowstorageError(`${MODULE_NAME}: Delete operation failed: ${error.message}`, lowstorage_ERROR_CODES.DELETE_ERROR);\n\t\t}\n\t}\n\n\t/**\n\t * Count the number of documents in the collection.\n\t * @param {Object} [query={}] - The query to filter documents.\n\t * @returns {Promise<number>} A Promise that resolves to the number of documents in the collection.\n\t * @throws {lowstorageError} If the count operation fails.\n\t */\n\tasync count(query = {}) {\n\t\ttry {\n\t\t\tconst data = await this.find(query);\n\t\t\treturn data.length;\n\t\t} catch (error) {\n\t\t\tthrow new lowstorageError(`${MODULE_NAME}: Count operation failed: ${error.message}`, lowstorage_ERROR_CODES.COUNT_ERROR);\n\t\t}\n\t}\n\n\tasync renameCollection(newColName, newSchema = this._schema) {\n\t\ttry {\n\t\t\t_hasColName(newColName);\n\t\t\tconst exists = await this._s3.fileExists(`${this._dirPrefix}${DEFAULT_DELIMITER}${newColName}${COL_SUFFIX}`);\n\t\t\tif (!!exists) {\n\t\t\t\tthrow new lowstorageError(`${MODULE_NAME}: Collection ${newColName} already exists`, lowstorage_ERROR_CODES.COLLECTION_EXISTS);\n\t\t\t}\n\t\t\tconst schema = newSchema || this.getAvroSchema();\n\t\t\tconst data = await this._loadData();\n\t\t\tconst createNew = new Collection(newColName, schema, this._s3, this._dirPrefix);\n\t\t\tawait createNew._saveData(data);\n\t\t\tawait this._s3.delete(`${this._dirPrefix}${DEFAULT_DELIMITER}${this._colName}${COL_SUFFIX}`);\n\t\t\treturn createNew;\n\t\t} catch (error) {\n\t\t\tif (error instanceof lowstorageError) {\n\t\t\t\tthrow error;\n\t\t\t}\n\t\t\tthrow new lowstorageError(\n\t\t\t\t`${MODULE_NAME}: Rename collection failed: ${error.message}`,\n\t\t\t\tlowstorage_ERROR_CODES.RENAME_COLLECTION_ERROR,\n\t\t\t);\n\t\t}\n\t}\n}\n\n// export default lowstorage;\nexport { lowstorage, lowstorageError, lowstorage_ERROR_CODES };\n", "'use strict';\n\nconst lowstorage_ERROR_CODES = {\n\tMISSING_ARGUMENT: 'MISSING_ARGUMENT',\n\tCOLLECTION_EXISTS: 'COLLECTION_EXISTS',\n\tCREATE_COLLECTION_ERROR: 'CREATE_COLLECTION_ERROR',\n\tRENAME_COLLECTION_ERROR: 'RENAME_COLLECTION_ERROR',\n\tREMOVE_COLLECTION_ERROR: 'REMOVE_COLLECTION_ERROR',\n\tUPDATE_COLLECTION_SCHEMA_ERROR: 'UPDATE_COLLECTION_SCHEMA_ERROR',\n\tCOLLECTION_NOT_FOUND: 'COLLECTION_NOT_FOUND',\n\tSCHEMA_VALIDATION_ERROR: 'SCHEMA_VALIDATION_ERROR',\n\tDOCUMENT_VALIDATION_ERROR: 'DOCUMENT_VALIDATION_ERROR',\n\tS3_OPERATION_ERROR: 'S3_OPERATION_ERROR',\n\tFIND_ERROR: 'FIND_ERROR',\n\tFIND_ONE_ERROR: 'FIND_ONE_ERROR',\n\tSAVE_DATA_ERROR: 'SAVE_DATA_ERROR',\n\tINSERT_ERROR: 'INSERT_ERROR',\n\tUPDATE_ERROR: 'UPDATE_ERROR',\n\tUPDATE_ONE_ERROR: 'UPDATE_ONE_ERROR',\n\tDELETE_ERROR: 'DELETE_ERROR',\n\tCOUNT_ERROR: 'COUNT_ERROR',\n\tUNKNOWN_ERROR: 'UNKNOWN_ERROR',\n};\nclass lowstorageError extends Error {\n\tconstructor(message, code = lowstorage_ERROR_CODES.UNKNOWN_ERROR) {\n\t\tsuper(`lowstorageError: ${message} :: code: ${code}`);\n\t\tthis.name = this.constructor.name;\n\t\tthis.code = code;\n\t\tError.captureStackTrace(this, this.constructor);\n\t}\n}\n\nclass CollectionNotFoundError extends lowstorageError {\n\tconstructor(collectionName) {\n\t\tsuper(`Collection ${collectionName} not found`, lowstorage_ERROR_CODES.COLLECTION_NOT_FOUND);\n\t}\n}\n\nclass SchemaValidationError extends lowstorageError {\n\tconstructor(message) {\n\t\tsuper(message, lowstorage_ERROR_CODES.SCHEMA_VALIDATION_ERROR);\n\t}\n}\n\nclass DocumentValidationError extends lowstorageError {\n\tconstructor(message) {\n\t\tsuper(message, lowstorage_ERROR_CODES.DOCUMENT_VALIDATION_ERROR);\n\t}\n}\n\nclass S3OperationError extends lowstorageError {\n\tconstructor(message, operation) {\n\t\tsuper(`S3 ${operation} operation failed: ${message}`, lowstorage_ERROR_CODES.S3_OPERATION_ERROR);\n\t}\n}\n\nexport {\n\tlowstorage_ERROR_CODES,\n\tlowstorageError,\n\tCollectionNotFoundError,\n\tSchemaValidationError,\n\tDocumentValidationError,\n\tS3OperationError,\n};\n", "'use strict';\n\nimport { randomUUID } from 'node:crypto';\n\nconst matchesQuery = (document, query) => {\n\treturn Object.keys(query).every((key) => document[key] === query[key]);\n};\n\nconst generateUUID = async () => {\n\tif (typeof randomUUID !== 'undefined' && typeof randomUUID === 'function') {\n\t\treturn randomUUID();\n\t}\n\tif (typeof crypto !== 'undefined' && typeof crypto === 'object' && typeof crypto.randomUUID === 'function') {\n\t\treturn crypto.randomUUID();\n\t}\n\treturn 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\n\t\tvar r = (Math.random() * 16) | 0,\n\t\t\tv = c === 'x' ? r : (r & 0x3) | 0x8;\n\t\treturn v.toString(16);\n\t});\n};\n\nconst _getAvroType = (value, name = 'SubAutoGenerated') => {\n\tswitch (typeof value) {\n\t\tcase 'string':\n\t\t\tif (_isUUID(value)) {\n\t\t\t\treturn {\n\t\t\t\t\ttype: 'string',\n\t\t\t\t\tname: '_id',\n\t\t\t\t\tsize: 16,\n\t\t\t\t\tlogicalType: 'UUID',\n\t\t\t\t};\n\t\t\t}\n\t\t\treturn 'string';\n\t\tcase 'number':\n\t\t\treturn Number.isInteger(value) ? 'int' : 'float';\n\t\tcase 'boolean':\n\t\t\treturn 'boolean';\n\t\tcase 'object':\n\t\t\tif (value === null) return 'null';\n\t\t\tif (Array.isArray(value)) return { type: 'array', items: _getAvroType(value[0]) };\n\t\t\treturn inferAvroType(value, name);\n\t\tdefault:\n\t\t\treturn 'string'; // Default to string for unknown types\n\t}\n};\n\nconst ensureIdFieldInSchema = (schema) => {\n\tconst idField = {\n\t\tname: '_id',\n\t\ttype: 'string',\n\t\tsize: 16,\n\t\tlogicalType: 'UUID',\n\t};\n\n\tif (schema.type === 'record') {\n\t\tconst hasIdField = schema.fields.some((field) => field.name === '_id');\n\t\tif (!hasIdField) {\n\t\t\tschema.fields.unshift(idField);\n\t\t}\n\t} else if (schema.type === 'array' && schema.items.type === 'record') {\n\t\tconst hasIdField = schema.items.fields.some((field) => field.name === '_id');\n\t\tif (!hasIdField) {\n\t\t\tschema.items.fields.unshift(idField);\n\t\t}\n\t}\n\treturn schema;\n};\n\nconst inferAvroType = (data, typeName = 'AutoGenerated') => {\n\tif (Array.isArray(data)) {\n\t\tdata = data[0];\n\t}\n\tconst fields = Object.entries(data).map(([name, value]) => {\n\t\treturn { name, type: _getAvroType(value, `${typeName}.${name}`) };\n\t});\n\n\tconst schema = {\n\t\ttype: 'record',\n\t\tname: typeName,\n\t\tfields: fields,\n\t};\n\n\t// Ensure the _id field is present in the schema\n\treturn ensureIdFieldInSchema(schema);\n};\n\nconst _isUUID = (str) => {\n\tconst uuidV4Regex = /^[0-9A-F]{8}-[0-9A-F]{4}-4[0-9A-F]{3}-[89AB][0-9A-F]{3}-[0-9A-F]{12}$/i;\n\treturn uuidV4Regex.test(str);\n};\n\nexport { matchesQuery, generateUUID, inferAvroType, ensureIdFieldInSchema };\n"],
  "mappings": "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",
  "names": ["AWS_ALGORITHM", "AWS_REQUEST_TYPE", "S3_SERVICE", "LIST_TYPE", "UNSIGNED_PAYLOAD", "DEFAULT_STREAM_CONTENT_TYPE", "XML_CONTENT_TYPE", "JSON_CONTENT_TYPE", "SENSITIVE_KEYS_REDACTED", "HEADER_AMZ_CONTENT_SHA256", "HEADER_AMZ_DATE", "HEADER_HOST", "HEADER_AUTHORIZATION", "HEADER_CONTENT_TYPE", "HEADER_CONTENT_LENGTH", "HEADER_ETAG", "HEADER_LAST_MODIFIED", "ERROR_PREFIX", "ERROR_ACCESS_KEY_REQUIRED", "ERROR_SECRET_KEY_REQUIRED", "ERROR_ENDPOINT_REQUIRED", "ERROR_BUCKET_NAME_REQUIRED", "ERROR_KEY_REQUIRED", "ERROR_UPLOAD_ID_REQUIRED", "ERROR_PARTS_REQUIRED", "ERROR_INVALID_PART", "ERROR_DATA_BUFFER_REQUIRED", "ERROR_PREFIX_TYPE", "ERROR_MAX_KEYS_TYPE", "ERROR_DELIMITER_REQUIRED", "_createHmac", "_createHash", "expectArray", "encodeAsHex", "c", "uriEscape", "uriStr", "uriResourceEscape", "string", "S3", "accessKeyId", "secretAccessKey", "endpoint", "bucketName", "region", "maxRequestSizeInBytes", "requestAbortTimeout", "logger", "etag", "sanitizeETag", "props", "method", "key", "delimiter", "prefix", "maxKeys", "opts", "level", "message", "additionalData", "sanitize", "obj", "acc", "sanitizedData", "logEntry", "headers", "encodedKey", "url", "signedHeaders", "contentLength", "res", "filteredOpts", "conditionalHeaders", "error", "errorMessage", "keyPath", "query", "body", "datetime", "_hash", "canonicalHeaders", "canonicalRequest", "stringToSign", "signature", "authorizationHeader", "value", "credentialScope", "signingKey", "_hmac", "ifHeaders", "urlWithQuery", "responseBody", "lastModified", "data", "_parseXml", "output", "o", "i", "a", "_a", "_b", "_c", "wholeFile", "rangeFrom", "rangeTo", "fileType", "parsedResponse", "uploadId", "partNumber", "ETag", "parts", "part", "xmlBody", "toleratedStatusCodes", "errorBody", "errorCode", "queryParams", "dateStamp", "kDate", "kRegion", "kService", "content", "hashSum", "encoding", "hmacSum", "replaceChars", "m", "str", "unescapeXml", "json", "re", "match", "fullKey", "parsedValue", "avro", "lowstorage_ERROR_CODES", "lowstorageError", "message", "code", "SchemaValidationError", "lowstorageError", "message", "lowstorage_ERROR_CODES", "DocumentValidationError", "S3OperationError", "operation", "randomUUID", "matchesQuery", "document", "query", "key", "generateUUID", "c", "r", "v", "_getAvroType", "value", "name", "_isUUID", "inferAvroType", "ensureIdFieldInSchema", "schema", "idField", "field", "data", "typeName", "fields", "str", "MODULE_NAME", "DEFAULT_DELIMITER", "PROJECT_DIR_PREFIX", "COL_SUFFIX", "CHUNG_1MB", "CHUNG_5MB", "EMPTY_DATA", "errorValidationFn", "errorCode", "lowstorage_ERROR_CODES", "DocumentValidationError", "_hasColName", "colName", "lowstorageError", "lowstorage", "options", "N", "avro", "args", "requiredFields", "field", "listed", "entry", "error", "S3OperationError", "exists", "schema", "data", "wrapperType", "KEY", "exists2", "autoCreate", "colPath", "colSchema", "Collection", "SchemaValidationError", "_Collection", "s3", "dirPrefix", "safeWrite", "props", "CHUNK_SIZE", "etag", "offset", "bufferArr", "repeat", "nextDataResponse", "nextDataBody", "bufferedData", "dataBuffer", "currentETag", "resp", "newETag", "doc", "items", "schemaWithId", "inferAvroType", "avroType", "item", "generateUUID", "query", "start", "end", "matchesQuery", "update", "updatedCount", "i", "updatedDoc", "docIndex", "initialLength", "newData", "newColName", "newSchema", "createNew"]
}
