{
  "version": 3,
  "sources": ["../node_modules/ultralight-s3/src/index.ts", "../src/lowstorage.js", "../src/helpers.js"],
  "sourcesContent": ["'use strict';\n\nimport { parse } from 'node:path';\n\ninterface S3Config {\n  accessKeyId: string;\n  secretAccessKey: string;\n  endpoint: string;\n  bucketName: string;\n  region?: string;\n  maxRequestSizeInBytes?: number;\n  requestAbortTimeout?: number;\n  logger?: Logger;\n}\n\ndeclare global {\n  interface Crypto {\n    createHmac: (\n      algorithm: string,\n      key: string | Buffer,\n    ) => {\n      update: (data: string | Buffer) => void;\n      digest: (encoding?: 'hex' | 'base64' | 'latin1') => string;\n    };\n    createHash: (algorithm: string) => {\n      update: (data: string | Buffer) => void;\n      digest: (encoding?: 'hex' | 'base64' | 'latin1') => string;\n    };\n  }\n}\n\ninterface Logger {\n  info: (message: string, ...args: any[]) => void;\n  warn: (message: string, ...args: any[]) => void;\n  error: (message: string, ...args: any[]) => void;\n}\n\ninterface UploadPart {\n  partNumber: number;\n  ETag: string;\n}\n\ninterface CompleteMultipartUploadResult {\n  Location: string;\n  Bucket: string;\n  Key: string;\n  ETag: string;\n}\n\ntype HttpMethod = 'POST' | 'GET' | 'HEAD' | 'PUT' | 'DELETE';\n\nlet _createHmac = crypto.createHmac || (await import('node:crypto')).createHmac;\nlet _createHash = crypto.createHash || (await import('node:crypto')).createHash;\n\nif (typeof _createHmac === 'undefined' && typeof _createHash === 'undefined') {\n  console.error(\n    'ultralight-S3 Module: Crypto functions are not available, please report the issue with necessary description: https://github.com/sentienhq/ultralight-s3/issues',\n  );\n}\n\n// Constants\nconst AWS_ALGORITHM = 'AWS4-HMAC-SHA256';\nconst AWS_REQUEST_TYPE = 'aws4_request';\nconst S3_SERVICE = 's3';\nconst LIST_TYPE = '2';\nconst UNSIGNED_PAYLOAD = 'UNSIGNED-PAYLOAD';\nconst DEFAULT_STREAM_CONTENT_TYPE = 'application/octet-stream';\nconst XML_CONTENT_TYPE = 'application/xml';\nconst JSON_CONTENT_TYPE = 'application/json';\n// List of keys that might contain sensitive information\nconst SENSITIVE_KEYS_REDACTED = ['accessKeyId', 'secretAccessKey', 'sessionToken', 'password'];\nconst MIN_MAX_REQUEST_SIZE_IN_BYTES = 5 * 1024 * 1024;\n\n// Headers\nconst HEADER_AMZ_CONTENT_SHA256 = 'x-amz-content-sha256';\nconst HEADER_AMZ_DATE = 'x-amz-date';\nconst HEADER_HOST = 'host';\nconst HEADER_AUTHORIZATION = 'Authorization';\nconst HEADER_CONTENT_TYPE = 'Content-Type';\nconst HEADER_CONTENT_LENGTH = 'Content-Length';\nconst HEADER_ETAG = 'etag';\nconst HEADER_LAST_MODIFIED = 'last-modified';\n\n// Error messages\nconst ERROR_PREFIX = 'ultralight-s3 Module: ';\nconst ERROR_ACCESS_KEY_REQUIRED = `${ERROR_PREFIX}accessKeyId must be a non-empty string`;\nconst ERROR_SECRET_KEY_REQUIRED = `${ERROR_PREFIX}secretAccessKey must be a non-empty string`;\nconst ERROR_ENDPOINT_REQUIRED = `${ERROR_PREFIX}endpoint must be a non-empty string`;\nconst ERROR_BUCKET_NAME_REQUIRED = `${ERROR_PREFIX}bucketName must be a non-empty string`;\nconst ERROR_KEY_REQUIRED = `${ERROR_PREFIX}key must be a non-empty string`;\nconst ERROR_UPLOAD_ID_REQUIRED = `${ERROR_PREFIX}uploadId must be a non-empty string`;\nconst ERROR_PARTS_REQUIRED = `${ERROR_PREFIX}parts must be a non-empty array`;\nconst ERROR_INVALID_PART = `${ERROR_PREFIX}Each part must have a partNumber (number) and ETag (string)`;\nconst ERROR_DATA_BUFFER_REQUIRED = `${ERROR_PREFIX}data must be a Buffer or string`;\nconst ERROR_PATH_REQUIRED = `${ERROR_PREFIX}path must be a string`;\nconst ERROR_PREFIX_TYPE = `${ERROR_PREFIX}prefix must be a string`;\nconst ERROR_MAX_KEYS_TYPE = `${ERROR_PREFIX}maxKeys must be a positive integer`;\n\nconst expectArray: { [key: string]: boolean } = {\n  contents: true,\n};\n\nconst encodeAsHex = (c: string): string => `%${c.charCodeAt(0).toString(16).toUpperCase()}`;\n\nconst uriEscape = (uriStr: string): string => {\n  return encodeURIComponent(uriStr).replace(/[!'()*]/g, encodeAsHex);\n};\n\nconst uriResourceEscape = (string: string): string => {\n  return uriEscape(string).replace(/%2F/g, '/');\n};\n\n/**\n * S3 class for interacting with S3-compatible object storage services.\n * This class provides methods for common S3 operations such as uploading, downloading,\n * and deleting objects, as well as multipart uploads.\n *\n * @class\n * @example\n * const s3 = new S3({\n *   accessKeyId: 'your-access-key',\n *   secretAccessKey: 'your-secret-key',\n *   endpoint: 'https://your-s3-endpoint.com',\n *   bucketName: 'your-bucket-name',\n *   region: 'us-east-1' // by default is auto\n * });\n *\n * // Upload a file\n * await s3.put('example.txt', 'Hello, World!');\n *\n * // Download a file\n * const content = await s3.get('example.txt');\n *\n * // Delete a file\n * await s3.delete('example.txt');\n */\nclass S3 {\n  /**\n   * Creates an instance of the S3 class.\n   *\n   * @constructor\n   * @param {Object} config - Configuration options for the S3 instance.\n   * @param {string} config.accessKeyId - The access key ID for authentication.\n   * @param {string} config.secretAccessKey - The secret access key for authentication.\n   * @param {string} config.endpoint - The endpoint URL of the S3-compatible service.\n   * @param {string} [config.bucketName=''] - The name of the bucket to operate on.\n   * @param {string} [config.region='auto'] - The region of the S3 service.\n   * @param {number} [config.maxRequestSizeInBytes=5242880] - The maximum size of a single request in bytes (minimum for AWS S3 is 5MB).\n   * @param {number} [config.requestAbortTimeout=undefined] - The timeout in milliseconds after which a request should be aborted (careful on streamed requests).\n   * @param {Object} [config.logger=null] - A logger object with methods like info, warn, error.\n   * @throws {TypeError} Will throw an error if required parameters are missing or of incorrect type.\n   */\n  private accessKeyId: string;\n  private secretAccessKey: string;\n  private endpoint: string;\n  private bucketName: string;\n  private region: string;\n  private maxRequestSizeInBytes: number;\n  private requestAbortTimeout?: number;\n  private logger?: Logger;\n\n  constructor({\n    accessKeyId,\n    secretAccessKey,\n    endpoint,\n    bucketName,\n    region = 'auto',\n    maxRequestSizeInBytes = MIN_MAX_REQUEST_SIZE_IN_BYTES,\n    requestAbortTimeout = undefined,\n    logger = undefined,\n  }: S3Config) {\n    this._validateConstructorParams(accessKeyId, secretAccessKey, endpoint, bucketName);\n    this.accessKeyId = accessKeyId;\n    this.secretAccessKey = secretAccessKey;\n    this.endpoint = endpoint;\n    this.bucketName = bucketName;\n    this.region = region;\n    this.maxRequestSizeInBytes = maxRequestSizeInBytes;\n    this.requestAbortTimeout = requestAbortTimeout;\n    this.logger = logger;\n  }\n\n  private _validateConstructorParams(\n    accessKeyId: string,\n    secretAccessKey: string,\n    endpoint: string,\n    bucketName: string,\n  ): void {\n    if (typeof accessKeyId !== 'string' || accessKeyId.trim().length === 0)\n      throw new TypeError(ERROR_ACCESS_KEY_REQUIRED);\n    if (typeof secretAccessKey !== 'string' || secretAccessKey.trim().length === 0)\n      throw new TypeError(ERROR_SECRET_KEY_REQUIRED);\n    if (typeof endpoint !== 'string' || endpoint.trim().length === 0) throw new TypeError(ERROR_ENDPOINT_REQUIRED);\n    if (typeof bucketName !== 'string' || bucketName.trim().length === 0)\n      throw new TypeError(ERROR_BUCKET_NAME_REQUIRED);\n  }\n\n  /**\n   * Internal method to log messages with sanitized sensitive information.\n   * @param {string} level - The log level (e.g., 'info', 'warn', 'error').\n   * @param {string} message - The message to log.\n   * @param {Object} [additionalData={}] - Additional data to include in the log.\n   * @private\n   */\n  private _log(\n    level: 'info' | 'warn' | 'error',\n    message: string,\n    additionalData: Record<string, any> | string = {},\n  ): void {\n    if (this.logger && typeof this.logger[level] === 'function') {\n      // Function to recursively sanitize an object\n      const sanitize = (obj: any): any => {\n        if (typeof obj !== 'object' || obj === null) {\n          return obj;\n        }\n        return Object.keys(obj).reduce(\n          (acc: any, key) => {\n            if (SENSITIVE_KEYS_REDACTED.includes(key.toLowerCase())) {\n              acc[key] = '[REDACTED]';\n            } else if (typeof obj[key] === 'object' && obj[key] !== null) {\n              acc[key] = sanitize(obj[key]);\n            } else {\n              acc[key] = obj[key];\n            }\n            return acc;\n          },\n          Array.isArray(obj) ? [] : {},\n        );\n      };\n\n      // Sanitize the additional data\n      const sanitizedData = sanitize(additionalData);\n      // Prepare the log entry\n      const logEntry = {\n        timestamp: new Date().toISOString(),\n        level,\n        message,\n        ...sanitizedData,\n        // Include some general context, but sanitize sensitive parts\n        context: sanitize({\n          bucketName: this.bucketName,\n          region: this.region,\n          endpoint: this.endpoint,\n          // Only include the first few characters of the access key, if it exists\n          accessKeyId: this.accessKeyId ? `${this.accessKeyId.substring(0, 4)}...` : undefined,\n        }),\n      };\n\n      // Log the sanitized entry\n      this.logger[level](logEntry);\n    }\n  }\n\n  getBucketName = () => this.bucketName;\n  setBucketName = (bucketName: string) => {\n    this.bucketName = bucketName;\n  };\n  getRegion = () => this.region;\n  setRegion = (region: string) => {\n    this.region = region;\n  };\n  getEndpoint = () => this.endpoint;\n  setEndpoint = (endpoint: string) => {\n    this.endpoint = endpoint;\n  };\n  getMaxRequestSizeInBytes = () => this.maxRequestSizeInBytes;\n  setMaxRequestSizeInBytes = (maxRequestSizeInBytes: number) => {\n    this.maxRequestSizeInBytes = maxRequestSizeInBytes;\n  };\n\n  getProps = () => ({\n    accessKeyId: this.accessKeyId,\n    secretAccessKey: this.secretAccessKey,\n    region: this.region,\n    bucket: this.bucketName,\n    endpoint: this.endpoint,\n    maxRequestSizeInBytes: this.maxRequestSizeInBytes,\n    requestAbortTimeout: this.requestAbortTimeout,\n    logger: this.logger,\n  });\n  setProps = (props: S3Config) => {\n    this._validateConstructorParams(props.accessKeyId, props.secretAccessKey, props.bucketName, props.endpoint);\n    this.accessKeyId = props.accessKeyId;\n    this.secretAccessKey = props.secretAccessKey;\n    this.region = props.region || 'auto';\n    this.bucketName = props.bucketName;\n    this.endpoint = props.endpoint;\n    this.maxRequestSizeInBytes = props.maxRequestSizeInBytes || MIN_MAX_REQUEST_SIZE_IN_BYTES;\n    this.requestAbortTimeout = props.requestAbortTimeout;\n    this.logger = props.logger;\n  };\n\n  /**\n   * Get the content length of an object.\n   * @param {string} key - The key of the object.\n   * @returns {Promise<number>} The content length of the object in bytes.\n   * @throws {TypeError} If the key is not a non-empty string.\n   */\n  async getContentLength(key: string): Promise<number> {\n    if (typeof key !== 'string' || key.trim().length === 0) {\n      this._log('error', ERROR_KEY_REQUIRED);\n      throw new TypeError(ERROR_KEY_REQUIRED);\n    }\n    const headers = {\n      [HEADER_AMZ_CONTENT_SHA256]: UNSIGNED_PAYLOAD,\n    };\n    const encodedKey = uriResourceEscape(key);\n    const { url, headers: signedHeaders } = await this._sign('HEAD', encodedKey, {}, headers, '');\n    const res = await this._sendRequest(url, 'HEAD', signedHeaders);\n    const contentLength = res.headers.get(HEADER_CONTENT_LENGTH);\n    return contentLength ? parseInt(contentLength, 10) : 0;\n  }\n\n  /**\n   * Check if a bucket exists.\n   * @returns {Promise<boolean>} True if the bucket exists, false otherwise.\n   */\n  async bucketExists(): Promise<boolean> {\n    const headers = {\n      [HEADER_AMZ_CONTENT_SHA256]: UNSIGNED_PAYLOAD,\n    };\n    const { url, headers: signedHeaders } = await this._sign('HEAD', '', {}, headers, '');\n    const res = await this._sendRequest(url, 'HEAD', signedHeaders);\n    if (res.ok && res.status === 200) {\n      return true;\n    }\n    return false;\n  }\n\n  // TBD\n  // async createBucket(bucketName) {\n  //   const xmlBody = `\n  //   <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n  //     <CreateBucketConfiguration xmlns=\"http://s3.amazonaws.com/doc/2006-03-01/\">\n  //     <LocationConstraint>${this.region}</LocationConstraint>\n  //   </CreateBucketConfiguration>\n  //   `;\n  //   const headers = {\n  //     [HEADER_CONTENT_TYPE]: XML_CONTENT_TYPE,\n  //     [HEADER_CONTENT_LENGTH]: Buffer.byteLength(xmlBody).toString(),\n  //     [HEADER_AMZ_CONTENT_SHA256]: await _hash(xmlBody),\n  //   };\n  //   const encodedKey = encodeURI(bucketName);\n  //   const { url, headers: signedHeaders } = await this._sign('PUT', encodedKey, {}, headers, '');\n  //   const res = await this._sendRequest(url, 'PUT', signedHeaders);\n  //   if (res.ok && res.status === 200) {\n  //     return true;\n  //   }\n  //   return false;\n  // }\n\n  /**\n   * Check if a file exists in the bucket.\n   * @param {string} key - The key of the object.\n   * @returns {Promise<boolean>} True if the file exists, false otherwise.\n   * @throws {TypeError} If the key is not a non-empty string.\n   */\n  async fileExists(key: string): Promise<boolean> {\n    if (typeof key !== 'string' || key.trim().length === 0) {\n      this._log('error', ERROR_KEY_REQUIRED);\n      throw new TypeError(ERROR_KEY_REQUIRED);\n    }\n    const headers = { [HEADER_AMZ_CONTENT_SHA256]: UNSIGNED_PAYLOAD };\n    const encodedKey = uriResourceEscape(key);\n    const { url, headers: signedHeaders } = await this._sign('HEAD', encodedKey, {}, headers, '');\n    try {\n      const res = await fetch(url, {\n        method: 'HEAD',\n        headers: signedHeaders,\n      });\n      if (res.ok && res.status === 200) return true;\n      else if (res.status === 404) return false;\n      else this._handleErrorResponse(res);\n      return false;\n    } catch (error: unknown) {\n      const errorMessage = error instanceof Error ? error.message : String(error);\n      this._log('error', `${ERROR_PREFIX}Failed to check if file exists: ${errorMessage}`);\n      throw new Error(`${ERROR_PREFIX}Failed to check if file exists: ${errorMessage}`);\n    }\n  }\n  async _sign(\n    method: HttpMethod,\n    keyPath: string,\n    query: Object,\n    headers: Record<string, string | number>,\n    body: string | Buffer,\n  ): Promise<{ url: string; headers: Record<string, any> }> {\n    const datetime = new Date().toISOString().replace(/[:-]|\\.\\d{3}/g, '');\n    const url =\n      typeof keyPath === 'string' && keyPath.length > 0 ? new URL(keyPath, this.endpoint) : new URL(this.endpoint);\n    url.pathname = `/${encodeURI(this.bucketName)}${url.pathname}`;\n    headers[HEADER_AMZ_CONTENT_SHA256] = body ? await _hash(body) : UNSIGNED_PAYLOAD;\n    headers[HEADER_AMZ_DATE] = datetime;\n    headers[HEADER_HOST] = url.host;\n    const canonicalHeaders = this._buildCanonicalHeaders(headers);\n    const signedHeaders = Object.keys(headers)\n      .map(key => key.toLowerCase())\n      .sort()\n      .join(';');\n\n    const canonicalRequest = await this._buildCanonicalRequest(\n      method,\n      url,\n      query,\n      canonicalHeaders,\n      signedHeaders,\n      body,\n    );\n    const stringToSign = await this._buildStringToSign(datetime, canonicalRequest);\n    const signature = await this._calculateSignature(datetime, stringToSign);\n    const authorizationHeader = this._buildAuthorizationHeader(datetime, signedHeaders, signature);\n    headers[HEADER_AUTHORIZATION] = authorizationHeader;\n    return { url: url.toString(), headers };\n  }\n\n  _buildCanonicalHeaders(headers: Record<string, string | number>): string {\n    return Object.entries(headers)\n      .map(([key, value]) => `${key.toLowerCase()}:${String(value).trim()}`)\n      .sort()\n      .join('\\n');\n  }\n\n  async _buildCanonicalRequest(\n    method: HttpMethod,\n    url: URL,\n    query: Object,\n    canonicalHeaders: string,\n    signedHeaders: string,\n    body: string | Buffer,\n  ): Promise<string> {\n    return [\n      method,\n      url.pathname,\n      this._buildCanonicalQueryString(query),\n      `${canonicalHeaders}\\n`,\n      signedHeaders,\n      body ? await _hash(body) : UNSIGNED_PAYLOAD,\n    ].join('\\n');\n  }\n\n  async _buildStringToSign(datetime: string, canonicalRequest: string): Promise<string> {\n    const credentialScope = [datetime.slice(0, 8), this.region, S3_SERVICE, AWS_REQUEST_TYPE].join('/');\n    return [AWS_ALGORITHM, datetime, credentialScope, await _hash(canonicalRequest)].join('\\n');\n  }\n\n  async _calculateSignature(datetime: string, stringToSign: string): Promise<string> {\n    const signingKey = await this._getSignatureKey(datetime.slice(0, 8));\n    return _hmac(signingKey, stringToSign, 'hex');\n  }\n\n  _buildAuthorizationHeader(datetime: string, signedHeaders: string, signature: string): string {\n    const credentialScope = [datetime.slice(0, 8), this.region, S3_SERVICE, AWS_REQUEST_TYPE].join('/');\n    return [\n      `${AWS_ALGORITHM} Credential=${this.accessKeyId}/${credentialScope}`,\n      `SignedHeaders=${signedHeaders}`,\n      `Signature=${signature}`,\n    ].join(', ');\n  }\n\n  /**\n   * List objects in the bucket.\n   * @param {string} [path='/'] - The path to list objects from.\n   * @param {string} [prefix=''] - The prefix to filter objects.\n   * @param {number} [maxKeys=1000] - The maximum number of keys to return.\n   * @param {string} [method='GET'] - The HTTP method to use (GET or HEAD).\n   * @param {Object} [opts={}] - Additional options for the list operation.\n   * @returns {Promise<Object|Array>} The list of objects or object metadata.\n   * @throws {TypeError} If any of the parameters are of incorrect type.\n   */\n  async list(\n    path: string = '/',\n    prefix: string = '',\n    maxKeys: number = 1000,\n    method: HttpMethod = 'GET',\n    opts: Object = {},\n  ): Promise<Object | Array<Object>> {\n    if (typeof path !== 'string' || path.trim().length === 0) {\n      this._log('error', ERROR_PATH_REQUIRED);\n      throw new TypeError(ERROR_PATH_REQUIRED);\n    }\n    if (typeof prefix !== 'string') {\n      this._log('error', ERROR_PREFIX_TYPE);\n      throw new TypeError(ERROR_PREFIX_TYPE);\n    }\n    if (!Number.isInteger(maxKeys) || maxKeys <= 0) {\n      this._log('error', ERROR_MAX_KEYS_TYPE);\n      throw new TypeError(ERROR_MAX_KEYS_TYPE);\n    }\n    if (method !== 'GET' && method !== 'HEAD') {\n      this._log('error', `${ERROR_PREFIX}method must be either GET or HEAD`);\n      throw new TypeError(`${ERROR_PREFIX}method must be either GET or HEAD`);\n    }\n    if (typeof opts !== 'object') {\n      this._log('error', `${ERROR_PREFIX}opts must be an object`);\n      throw new TypeError(`${ERROR_PREFIX}opts must be an object`);\n    }\n\n    this._log('info', `Listing objects in ${path}`);\n\n    const query = {\n      'list-type': LIST_TYPE,\n      'max-keys': String(maxKeys),\n      ...opts,\n    } as { [key: string]: any };\n    if (prefix.length > 0) {\n      query['prefix'] = prefix;\n    }\n    const headers = {\n      [HEADER_CONTENT_TYPE]: JSON_CONTENT_TYPE,\n      [HEADER_AMZ_CONTENT_SHA256]: UNSIGNED_PAYLOAD,\n    };\n    const encodedKey = path === '/' ? path : uriEscape(path);\n    const { url, headers: signedHeaders } = await this._sign('GET', encodedKey, query, headers, '');\n    const urlWithQuery = `${url}?${new URLSearchParams(query)}`;\n    const res = await this._sendRequest(urlWithQuery, 'GET', signedHeaders);\n    const responseBody = await res.text();\n\n    if (method === 'HEAD') {\n      const contentLength = res.headers.get(HEADER_CONTENT_LENGTH);\n      const lastModified = res.headers.get(HEADER_LAST_MODIFIED);\n      const etag = res.headers.get(HEADER_ETAG);\n\n      return {\n        size: contentLength ? +contentLength : undefined,\n        mtime: lastModified ? new Date(lastModified) : undefined,\n        ETag: etag || undefined,\n      };\n    }\n\n    const data = _parseXml(responseBody);\n    const output = data.listBucketResult || data.error || data;\n    return output.contents || output;\n  }\n\n  /**\n   * List multipart uploads in the bucket.\n   * @param {string} [path='/'] - The path to list objects from.\n   * @param {string} [prefix=''] - The prefix to filter objects.\n   * @param {string} [method='GET'] - The HTTP method to use (GET or HEAD).\n   * @param {Object} [opts={}] - Additional options for the list operation.\n   * @returns {Promise<Object|Array>} The list of objects or object metadata.\n   * @throws {TypeError} If any of the parameters are of incorrect type.\n   */\n  async listMultiPartUploads(\n    path: string = '/',\n    prefix: string = '',\n    method: HttpMethod = 'GET',\n    opts: Object = {},\n  ): Promise<any> {\n    if (typeof path !== 'string' || path.trim().length === 0) {\n      this._log('error', ERROR_PATH_REQUIRED);\n      throw new TypeError(ERROR_PATH_REQUIRED);\n    }\n    if (typeof prefix !== 'string') {\n      this._log('error', ERROR_PREFIX_TYPE);\n      throw new TypeError(ERROR_PREFIX_TYPE);\n    }\n    if (method !== 'GET' && method !== 'HEAD') {\n      this._log('error', `${ERROR_PREFIX}method must be either GET or HEAD`);\n      throw new TypeError(`${ERROR_PREFIX}method must be either GET or HEAD`);\n    }\n    if (typeof opts !== 'object') {\n      this._log('error', `${ERROR_PREFIX}opts must be an object`);\n      throw new TypeError(`${ERROR_PREFIX}opts must be an object`);\n    }\n\n    this._log('info', `Listing multipart uploads in ${path}`);\n\n    const query = {\n      uploads: '',\n      ...opts,\n    } as Record<string, any>;\n    const headers = {\n      [HEADER_CONTENT_TYPE]: JSON_CONTENT_TYPE,\n      [HEADER_AMZ_CONTENT_SHA256]: UNSIGNED_PAYLOAD,\n    };\n    const encodedKey = path === '/' ? path : uriEscape(path);\n    const { url, headers: signedHeaders } = await this._sign('GET', encodedKey, query, headers, '');\n    const urlWithQuery = `${url}?${new URLSearchParams(query)}`;\n    const res = await this._sendRequest(urlWithQuery, 'GET', signedHeaders);\n    const responseBody = await res.text();\n\n    if (method === 'HEAD') {\n      return {\n        size: +(res.headers.get(HEADER_CONTENT_LENGTH) ?? '0'),\n        mtime: new Date(res.headers.get(HEADER_LAST_MODIFIED) ?? ''),\n        ETag: res.headers.get(HEADER_ETAG) ?? '',\n      };\n    }\n\n    const data = _parseXml(responseBody);\n    const output = data.listMultipartUploadsResult || data.error || data;\n    return output.uploads || output;\n  }\n\n  /**\n   * Get an object from the bucket.\n   * @param {string} key - The key of the object to get.\n   * @param {Object} [opts={}] - Additional options for the get operation.\n   * @returns {Promise<string>} The content of the object.\n   */\n  async get(key: string, opts: Record<string, any> = {}): Promise<string> {\n    if (typeof key !== 'string' || key.trim().length === 0) {\n      this._log('error', ERROR_KEY_REQUIRED);\n      throw new TypeError(ERROR_KEY_REQUIRED);\n    }\n    const headers = {\n      [HEADER_CONTENT_TYPE]: JSON_CONTENT_TYPE,\n      [HEADER_AMZ_CONTENT_SHA256]: UNSIGNED_PAYLOAD,\n    };\n    this._log('info', `Getting object ${key}`);\n    const encodedKey = uriResourceEscape(key);\n    const { url, headers: signedHeaders } = await this._sign('GET', encodedKey, opts, headers, '');\n    const res = await this._sendRequest(url, 'GET', signedHeaders);\n    return res.text();\n  }\n\n  /**\n   * Get a response of an object from the bucket.\n   * @param {string} key - The key of the object to get.\n   * @param {boolean} [wholeFile=true] - Whether to get the whole file or a part.\n   * @param {number} [rangeFrom=0] - The range from to get if not getting the whole file.\n   * @param {number} [rangeTo=this.maxRequestSizeInBytes] - The range to to get if not getting the whole file. Note: rangeTo is inclusive.\n   * @param {Object} [opts={}] - Additional options for the get operation.\n   * @returns {Promise<Response>} Response of the object content. Use readableStream() to get the stream from .body.\n   */\n  async getResponse(\n    key: string,\n    wholeFile: boolean = true,\n    rangeFrom: number = 0,\n    rangeTo: number = this.maxRequestSizeInBytes,\n    opts: Record<string, any> = {},\n  ): Promise<Response> {\n    const query = opts;\n    const headers = {\n      [HEADER_CONTENT_TYPE]: JSON_CONTENT_TYPE,\n      [HEADER_AMZ_CONTENT_SHA256]: UNSIGNED_PAYLOAD,\n      ...(wholeFile ? {} : { range: `bytes=${rangeFrom}-${rangeTo - 1}` }),\n    };\n    const encodedKey = uriResourceEscape(key);\n    const { url, headers: signedHeaders } = await this._sign('GET', encodedKey, query, headers, '');\n    const urlWithQuery = `${url}?${new URLSearchParams(query)}`;\n\n    return this._sendRequest(urlWithQuery, 'GET', signedHeaders);\n  }\n\n  /**\n   * Put an object into the bucket.\n   * @param {string} key - The key of the object to put. To create a folder, include a trailing slash.\n   * @param {Buffer|string} data - The content of the object to put.\n   * @returns {Promise<Object>} The response from the put operation.\n   * @throws {TypeError} If the key is not a non-empty string or data is not a Buffer or string.\n   */\n  async put(key: string, data: string | Buffer): Promise<Object> {\n    if (typeof key !== 'string' || key.trim().length === 0) {\n      this._log('error', ERROR_KEY_REQUIRED);\n      throw new TypeError(ERROR_KEY_REQUIRED);\n    }\n    if (!(data instanceof Buffer || typeof data === 'string')) {\n      this._log('error', ERROR_DATA_BUFFER_REQUIRED);\n      throw new TypeError(ERROR_DATA_BUFFER_REQUIRED);\n    }\n    // const encodedKey = encodeURIComponent(key);\n    this._log('info', `Uploading object ${key}`);\n    const contentLength = typeof data === 'string' ? Buffer.byteLength(data) : data.length;\n    const headers = {\n      [HEADER_CONTENT_LENGTH]: contentLength,\n    };\n    const encodedKey = uriResourceEscape(key);\n    const { url, headers: signedHeaders } = await this._sign('PUT', encodedKey, {}, headers, data);\n    const res = await this._sendRequest(url, 'PUT', signedHeaders, data);\n    return res;\n  }\n\n  /**\n   * Initiate a multipart upload.\n   * @param {string} key - The key of the object to upload.\n   * @param {string} [fileType='application/octet-stream'] - The MIME type of the file.\n   * @returns {Promise<string>} The upload ID for the multipart upload.\n   * @throws {TypeError} If the key is not a non-empty string or fileType is not a string.\n   * @throws {Error} If the multipart upload initiation fails.\n   */\n  async getMultipartUploadId(key: string, fileType: string = DEFAULT_STREAM_CONTENT_TYPE): Promise<string> {\n    if (typeof key !== 'string' || key.trim().length === 0) {\n      this._log('error', ERROR_KEY_REQUIRED);\n      throw new TypeError(ERROR_KEY_REQUIRED);\n    }\n    if (typeof fileType !== 'string') {\n      this._log('error', `${ERROR_PREFIX}fileType must be a string`);\n      throw new TypeError(`${ERROR_PREFIX}fileType must be a string`);\n    }\n    this._log('info', `Initiating multipart upload for object ${key}`);\n    const query = { uploads: '' };\n    const headers = {\n      [HEADER_CONTENT_TYPE]: fileType,\n      [HEADER_AMZ_CONTENT_SHA256]: UNSIGNED_PAYLOAD,\n    };\n\n    const encodedKey = uriResourceEscape(key);\n    const { url, headers: signedHeaders } = await this._sign('POST', encodedKey, query, headers, '');\n    const urlWithQuery = `${url}?${new URLSearchParams(query)}`;\n\n    const res = await this._sendRequest(urlWithQuery, 'POST', signedHeaders);\n    const responseBody = await res.text();\n    const parsedResponse = _parseXml(responseBody);\n\n    if (\n      typeof parsedResponse === 'object' &&\n      parsedResponse !== null &&\n      'error' in parsedResponse &&\n      typeof parsedResponse.error === 'object' &&\n      parsedResponse.error !== null &&\n      'message' in parsedResponse.error\n    ) {\n      const errorMessage = String(parsedResponse.error.message);\n      this._log('error', `${ERROR_PREFIX}Failed to abort multipart upload: ${errorMessage}`);\n      throw new Error(`${ERROR_PREFIX}Failed to abort multipart upload: ${errorMessage}`);\n    }\n\n    if (typeof parsedResponse === 'object' && parsedResponse !== null) {\n      if (!parsedResponse.initiateMultipartUploadResult || !parsedResponse.initiateMultipartUploadResult.uploadId) {\n        this._log('error', `${ERROR_PREFIX}Failed to create multipart upload: no uploadId in response`);\n        throw new Error(`${ERROR_PREFIX}Failed to create multipart upload: Missing upload ID in response`);\n      }\n\n      return parsedResponse.initiateMultipartUploadResult.uploadId;\n    } else {\n      this._log('error', `${ERROR_PREFIX}Failed to create multipart upload: unexpected response format`);\n      throw new Error(`${ERROR_PREFIX}Failed to create multipart upload: Unexpected response format`);\n    }\n  }\n\n  /**\n   * Upload a part in a multipart upload.\n   * @param {string} key - The key of the object being uploaded.\n   * @param {Buffer|string} data - The content of the part.\n   * @param {string} uploadId - The upload ID of the multipart upload.\n   * @param {number} partNumber - The part number.\n   * @param {Object} [opts={}] - Additional options for the upload.\n   * @returns {Promise<Object>} The ETag and part number of the uploaded part.\n   * @throws {TypeError} If any of the parameters are of incorrect type.\n   */\n  async uploadPart(\n    key: string,\n    data: Buffer | string,\n    uploadId: string,\n    partNumber: number,\n    opts: Object = {},\n  ): Promise<UploadPart> {\n    this._validateUploadPartParams(key, data, uploadId, partNumber, opts);\n    const query = { uploadId, partNumber, ...opts } as { [key: string]: any };\n    const headers = {\n      [HEADER_CONTENT_LENGTH]: data.length,\n    } as { [key: string]: any };\n\n    const encodedKey = uriResourceEscape(key);\n    const { url, headers: signedHeaders } = await this._sign('PUT', encodedKey, query, headers, data);\n    const urlWithQuery = `${url}?${new URLSearchParams(query)}`;\n\n    const res = await this._sendRequest(urlWithQuery, 'PUT', signedHeaders, data);\n    const ETag = res.headers.get('etag') || '';\n    return { partNumber, ETag };\n  }\n\n  _validateUploadPartParams(key: string, data: Buffer | string, uploadId: string, partNumber: number, opts: Object) {\n    if (typeof key !== 'string' || key.trim().length === 0) {\n      this._log('error', ERROR_KEY_REQUIRED);\n      throw new TypeError(ERROR_KEY_REQUIRED);\n    }\n    if (!(data instanceof Buffer || typeof data === 'string')) {\n      this._log('error', ERROR_DATA_BUFFER_REQUIRED);\n      throw new TypeError(ERROR_DATA_BUFFER_REQUIRED);\n    }\n    if (typeof uploadId !== 'string' || uploadId.trim().length === 0) {\n      this._log('error', ERROR_UPLOAD_ID_REQUIRED);\n      throw new TypeError(ERROR_UPLOAD_ID_REQUIRED);\n    }\n    if (!Number.isInteger(partNumber) || partNumber <= 0) {\n      this._log('error', `${ERROR_PREFIX}partNumber must be a positive integer`);\n      throw new TypeError(`${ERROR_PREFIX}partNumber must be a positive integer`);\n    }\n    if (typeof opts !== 'object') {\n      this._log('error', `${ERROR_PREFIX}opts must be an object`);\n      throw new TypeError(`${ERROR_PREFIX}opts must be an object`);\n    }\n  }\n\n  /**\n   * Complete a multipart upload.\n   * @param {string} key - The key of the object being uploaded.\n   * @param {string} uploadId - The upload ID of the multipart upload.\n   * @param {Array<Object>} parts - An array of objects containing PartNumber and ETag for each part.\n   * @returns {Promise<Object>} The result of the complete multipart upload operation.\n   * @throws {TypeError} If any of the parameters are of incorrect type.\n   * @throws {Error} If the complete multipart upload operation fails.\n   */\n  async completeMultipartUpload(\n    key: string,\n    uploadId: string,\n    parts: Array<UploadPart>,\n  ): Promise<CompleteMultipartUploadResult> {\n    if (typeof key !== 'string' || key.trim().length === 0) {\n      this._log('error', ERROR_KEY_REQUIRED);\n      throw new TypeError(ERROR_KEY_REQUIRED);\n    }\n    if (typeof uploadId !== 'string' || uploadId.trim().length === 0) {\n      this._log('error', ERROR_UPLOAD_ID_REQUIRED);\n      throw new TypeError(ERROR_UPLOAD_ID_REQUIRED);\n    }\n    if (!Array.isArray(parts) || parts.length === 0) {\n      this._log('error', ERROR_PARTS_REQUIRED);\n      throw new TypeError(ERROR_PARTS_REQUIRED);\n    }\n    if (!parts.every(part => typeof part.partNumber === 'number' && typeof part.ETag === 'string')) {\n      this._log('error', ERROR_INVALID_PART);\n      throw new TypeError(ERROR_INVALID_PART);\n    }\n    this._log('info', `Complete multipart upload ${uploadId} for object ${key}`);\n    const query = { uploadId };\n    const xmlBody = this._buildCompleteMultipartUploadXml(parts);\n    const headers = {\n      [HEADER_CONTENT_TYPE]: XML_CONTENT_TYPE,\n      [HEADER_CONTENT_LENGTH]: Buffer.byteLength(xmlBody).toString(),\n      [HEADER_AMZ_CONTENT_SHA256]: await _hash(xmlBody),\n    };\n    const encodedKey = uriResourceEscape(key);\n    const { url, headers: signedHeaders } = await this._sign('POST', encodedKey, query, headers, xmlBody);\n    const urlWithQuery = `${url}?${new URLSearchParams(query)}`;\n\n    const res = await this._sendRequest(urlWithQuery, 'POST', signedHeaders, xmlBody);\n    const responseBody = await res.text();\n    const parsedResponse = _parseXml(responseBody);\n\n    if (\n      typeof parsedResponse === 'object' &&\n      parsedResponse !== null &&\n      'error' in parsedResponse &&\n      typeof parsedResponse.error === 'object' &&\n      parsedResponse.error !== null &&\n      'message' in parsedResponse.error\n    ) {\n      const errorMessage = String(parsedResponse.error.message);\n      this._log('error', `${ERROR_PREFIX}Failed to abort multipart upload: ${errorMessage}`);\n      throw new Error(`${ERROR_PREFIX}Failed to abort multipart upload: ${errorMessage}`);\n    }\n\n    return parsedResponse.completeMultipartUploadResult;\n  }\n\n  /**\n   * Aborts a multipart upload.\n   * @param {string} key - The key of the object being uploaded.\n   * @param {string} uploadId - The ID of the multipart upload to abort.\n   * @returns {Promise<Object>} - A promise that resolves to the abort response.\n   * @throws {Error} If the abort operation fails.\n   */\n  async abortMultipartUpload(key: string, uploadId: string): Promise<object> {\n    // Input validation\n    if (typeof key !== 'string' || key.trim().length === 0) {\n      this._log('error', ERROR_KEY_REQUIRED);\n      throw new TypeError(ERROR_KEY_REQUIRED);\n    }\n    if (typeof uploadId !== 'string' || uploadId.trim().length === 0) {\n      this._log('error', ERROR_UPLOAD_ID_REQUIRED);\n      throw new TypeError(ERROR_UPLOAD_ID_REQUIRED);\n    }\n\n    this._log('info', `Aborting multipart upload ${uploadId} for object ${key}`);\n\n    // Prepare the request\n    const query = { uploadId };\n    const headers = {\n      [HEADER_CONTENT_TYPE]: XML_CONTENT_TYPE,\n      [HEADER_AMZ_CONTENT_SHA256]: UNSIGNED_PAYLOAD,\n    };\n\n    try {\n      // Sign and send the request\n      const encodedKey = uriResourceEscape(key);\n      const { url, headers: signedHeaders } = await this._sign('DELETE', encodedKey, query, headers, '');\n      const urlWithQuery = `${url}?${new URLSearchParams(query)}`;\n\n      const res = await this._sendRequest(urlWithQuery, 'DELETE', signedHeaders);\n\n      // Check for successful response\n      if (res.ok) {\n        const responseBody = await res.text();\n        const parsedResponse = _parseXml(responseBody);\n\n        if (\n          typeof parsedResponse === 'object' &&\n          parsedResponse !== null &&\n          'error' in parsedResponse &&\n          typeof parsedResponse.error === 'object' &&\n          parsedResponse.error !== null &&\n          'message' in parsedResponse.error\n        ) {\n          const errorMessage = String(parsedResponse.error.message);\n          this._log('error', `${ERROR_PREFIX}Failed to abort multipart upload: ${errorMessage}`);\n          throw new Error(`${ERROR_PREFIX}Failed to abort multipart upload: ${errorMessage}`);\n        }\n\n        return {\n          status: 'Aborted',\n          key,\n          uploadId,\n          response: parsedResponse,\n        };\n      } else {\n        this._log('error', `${ERROR_PREFIX}Abort request failed with status ${res.status}`);\n        throw new Error(`${ERROR_PREFIX}Abort request failed with status ${res.status}`);\n      }\n    } catch (error: unknown) {\n      const errorMessage = error instanceof Error ? error.message : String(error);\n      this._log('error', `${ERROR_PREFIX}Failed to abort multipart upload for key ${key}: ${errorMessage}`);\n      throw new Error(`${ERROR_PREFIX}Failed to abort multipart upload for key ${key}: ${errorMessage}`);\n    }\n  }\n\n  _buildCompleteMultipartUploadXml(parts: Array<UploadPart>): string {\n    return `\n      <CompleteMultipartUpload>\n        ${parts\n          .map(\n            part => `\n          <Part>\n            <PartNumber>${part.partNumber}</PartNumber>\n            <ETag>${part.ETag}</ETag>\n          </Part>\n        `,\n          )\n          .join('')}\n      </CompleteMultipartUpload>\n    `;\n  }\n\n  /**\n   * Delete an object from the bucket.\n   * @param {string} key - The key of the object to delete.\n   * @returns {Promise<string>} The response from the delete operation.\n   */\n  async delete(key: string): Promise<string> {\n    if (typeof key !== 'string' || key.trim().length === 0) {\n      this._log('error', ERROR_KEY_REQUIRED);\n      throw new TypeError(ERROR_KEY_REQUIRED);\n    }\n    this._log('info', `Deleting object ${key}`);\n    const headers = {\n      [HEADER_CONTENT_TYPE]: JSON_CONTENT_TYPE,\n      [HEADER_AMZ_CONTENT_SHA256]: UNSIGNED_PAYLOAD,\n    };\n    const encodedKey = uriResourceEscape(key);\n    const { url, headers: signedHeaders } = await this._sign('DELETE', encodedKey, {}, headers, '');\n    const res = await this._sendRequest(url, 'DELETE', signedHeaders);\n    return res.text();\n  }\n\n  async _sendRequest(\n    url: string,\n    method: HttpMethod,\n    headers: Record<string, string | any>,\n    body?: string | Buffer,\n  ): Promise<Response> {\n    this._log('info', `Sending ${method} request to ${url}, headers: ${JSON.stringify(headers)}`);\n    const res = await fetch(url, {\n      method,\n      headers,\n      body,\n      signal: this.requestAbortTimeout !== undefined ? AbortSignal.timeout(this.requestAbortTimeout) : undefined,\n    });\n\n    if (!res.ok) {\n      await this._handleErrorResponse(res);\n    }\n\n    return res;\n  }\n\n  async _handleErrorResponse(res: Response) {\n    const errorBody = await res.text();\n    const errorCode = res.headers.get('x-amz-error-code') || 'Unknown';\n    const errorMessage = res.headers.get('x-amz-error-message') || res.statusText;\n    this._log(\n      'error',\n      `${ERROR_PREFIX}Request failed with status ${res.status}: ${errorCode} - ${errorMessage},err body: ${errorBody}`,\n    );\n    throw new Error(\n      `${ERROR_PREFIX}Request failed with status ${res.status}: ${errorCode} - ${errorMessage}, err body: ${errorBody}`,\n    );\n  }\n\n  _buildCanonicalQueryString(queryParams: Object): string {\n    if (Object.keys(queryParams).length < 1) {\n      return '';\n    }\n\n    return Object.keys(queryParams)\n      .sort()\n      .map(key => `${encodeURIComponent(key)}=${encodeURIComponent((queryParams as Record<string, any>)[key])}`)\n      .join('&');\n  }\n  async _getSignatureKey(dateStamp: string): Promise<string> {\n    const kDate = await _hmac(`AWS4${this.secretAccessKey}`, dateStamp);\n    const kRegion = await _hmac(kDate, this.region);\n    const kService = await _hmac(kRegion, S3_SERVICE);\n    return _hmac(kService, AWS_REQUEST_TYPE);\n  }\n}\n\nconst _hash = async (content: string | Buffer): Promise<string> => {\n  const hashSum = _createHash('sha256');\n  hashSum.update(content);\n  return hashSum.digest('hex');\n};\n\nconst _hmac = async (key: string | Buffer, content: string, encoding?: 'hex'): Promise<string> => {\n  const hmacSum = _createHmac('sha256', key);\n  hmacSum.update(content);\n  return hmacSum.digest(encoding);\n};\n\nconst _parseXml = (str: string): string | object | any => {\n  const unescapeXml = (value: string): string => {\n    return value\n      .replace(/&quot;/g, '\"')\n      .replace(/&apos;/g, \"'\")\n      .replace(/&lt;/g, '<')\n      .replace(/&gt;/g, '>')\n      .replace(/&amp;/g, '&');\n  };\n\n  const json = {};\n  const re = /<(\\w)([-\\w]+)(?:\\/|[^>]*>((?:(?!<\\1)[\\s\\S])*)<\\/\\1\\2)>/gm;\n  let match;\n\n  while ((match = re.exec(str))) {\n    const [, prefix, key, value] = match;\n    const fullKey = prefix.toLowerCase() + key;\n    const parsedValue = value != null ? _parseXml(value) : true;\n\n    if (typeof parsedValue === 'string') {\n      (json as { [key: string]: any })[fullKey] = unescapeXml(parsedValue);\n    } else if (Array.isArray((json as { [key: string]: any })[fullKey])) {\n      (json as { [key: string]: any })[fullKey].push(parsedValue);\n    } else {\n      (json as { [key: string]: any })[fullKey] =\n        (json as { [key: string]: any })[fullKey] != null\n          ? [(json as { [key: string]: any })[fullKey], parsedValue]\n          : expectArray[fullKey]\n            ? [parsedValue]\n            : parsedValue;\n    }\n  }\n\n  return Object.keys(json).length ? json : unescapeXml(str);\n};\n\nexport { S3 };\nexport default S3;\n", "'use strict';\n\nimport { S3 } from 'ultralight-s3';\nimport avro from 'avro-js'; // eslint-disable-line\nimport { matchesQuery, generateUUID, inferAvroType } from './helpers.js';\n\nconst MODULE_NAME = 'lowstorage';\nconst PROJECT_DIR_PREFIX = 'lowstorage/';\nconst SCHEMA_SUFFIX = '.avro';\nconst CHUNG_1MB = 1024 * 1024;\nconst CHUNG_5MB = 5 * CHUNG_1MB;\n\nclass lowstorage {\n\tconstructor(\n\t\toptions = {\n\t\t\taccessKeyId: undefined,\n\t\t\tsecretAccessKey: undefined,\n\t\t\tendpoint: undefined,\n\t\t\tbucketName: undefined,\n\t\t\tregion: 'auto',\n\t\t\tlogger: null,\n\t\t},\n\t) {\n\t\tthis._checkArgs(options);\n\t\tthis._schemas = new Map();\n\t\tthis._s3 = new S3(options);\n\t\tthis._avro = avro;\n\t}\n\n\t_checkArgs = (args) => {\n\t\tconst requiredFields = ['accessKeyId', 'secretAccessKey', 'endpoint', 'bucketName'];\n\t\tfor (const field of requiredFields) {\n\t\t\tif (!args[field]) {\n\t\t\t\tthrow new Error(`${MODULE_NAME}: ${field} is required`);\n\t\t\t}\n\t\t}\n\t};\n\n\tasync listCollections() {\n\t\tconst listed = await this._s3.list(PROJECT_DIR_PREFIX, '', 1000);\n\t\treturn listed.map((entry) => entry.key.slice(PROJECT_DIR_PREFIX.length, -SCHEMA_SUFFIX.length));\n\t}\n\n\tasync createCollection(colName, schema = undefined) {\n\t\ttry {\n\t\t\tif (colName === undefined || colName.trim() === '' || colName === null) {\n\t\t\t\tthrow new Error(`${MODULE_NAME}: Collection name is required`);\n\t\t\t}\n\t\t\tif (await this.collectionExists(colName)) {\n\t\t\t\tthrow new Error(`${MODULE_NAME}: Collection ${colName} already exists`);\n\t\t\t}\n\t\t\tif (schema) {\n\t\t\t\tconst avroType = this._avro.parse(schema);\n\t\t\t\tthis._schemas.set(colName, avroType);\n\t\t\t}\n\t\t\treturn this.collection(colName, schema);\n\t\t} catch (error) {\n\t\t\tthrow new Error(`${MODULE_NAME}: ${error.message}`);\n\t\t}\n\t}\n\n\tasync removeCollection(colName) {\n\t\ttry {\n\t\t\tconst exists = await this._s3.fileExists(`${PROJECT_DIR_PREFIX}${colName}${SCHEMA_SUFFIX}`);\n\t\t\tif (exists) {\n\t\t\t\tconst resp = await this._s3.delete(`${PROJECT_DIR_PREFIX}${colName}${SCHEMA_SUFFIX}`);\n\t\t\t\tif (resp.status === 200) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn true;\n\t\t} catch (error) {\n\t\t\tthrow new Error(`${MODULE_NAME}: ${error.message}`);\n\t\t}\n\t}\n\n\tasync collectionExists(colName) {\n\t\ttry {\n\t\t\tconst exists = await this._s3.fileExists(`${PROJECT_DIR_PREFIX}${colName}${SCHEMA_SUFFIX}`);\n\t\t\treturn exists;\n\t\t} catch (error) {\n\t\t\tif (error.message.includes('Not Found')) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tthrow new Error(`${MODULE_NAME}: ${error.message}`);\n\t\t}\n\t}\n\n\tasync updateCollectionSchema(colName, schema) {\n\t\ttry {\n\t\t\tif (colName === undefined || colName.trim() === '' || colName === null) {\n\t\t\t\tthrow new Error(`${MODULE_NAME}: Collection name is required`);\n\t\t\t}\n\t\t\t// Check if collection exists\n\t\t\tconst exists = await this.collectionExists(colName);\n\t\t\tif (!exists) {\n\t\t\t\tthrow new Error(`${MODULE_NAME}: Collection ${colName} does not exist`);\n\t\t\t}\n\t\t\tif (schema === undefined || schema === null) {\n\t\t\t\tthrow new Error(`${MODULE_NAME}: Schema is required`);\n\t\t\t}\n\t\t\tconst avroType = this._avro.parse(schema);\n\t\t\tthis._schemas.set(colName, avroType);\n\t\t\tconst resp = await this._s3.put(`${PROJECT_DIR_PREFIX}${colName}${SCHEMA_SUFFIX}`, JSON.stringify(schema));\n\t\t\tif (resp.status === 200) {\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\tthrow new Error(`${MODULE_NAME}: Failed to update schema for collection ${colName}`);\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tthrow new Error(`${MODULE_NAME}: ${error.message}`);\n\t\t}\n\t}\n\n\tasync collection(colName, schema = undefined) {\n\t\ttry {\n\t\t\tif (colName === undefined || colName.trim() === '' || colName === null) {\n\t\t\t\tthrow new Error(`${MODULE_NAME}: Collection name is required`);\n\t\t\t}\n\t\t\tif (typeof schema === 'undefined') {\n\t\t\t\t// Load schema if not in memory\n\t\t\t\tif (this._schemas.has(colName)) {\n\t\t\t\t\treturn new Collection(colName, this._s3, this._schemas.get(colName));\n\t\t\t\t}\n\t\t\t\t// check if schema file exists\n\t\t\t\tconst exists = await this._s3.fileExists(`${PROJECT_DIR_PREFIX}${colName}${SCHEMA_SUFFIX}`);\n\t\t\t\tif (exists) {\n\t\t\t\t\tconst schemaContent = await this._s3.get(`${PROJECT_DIR_PREFIX}${colName}${SCHEMA_SUFFIX}`);\n\n\t\t\t\t\tconst avroType = this._avro.parse(schemaContent);\n\t\t\t\t\tthis._schemas.set(colName, avroType);\n\t\t\t\t\treturn new Collection(colName, this._s3, avroType);\n\t\t\t\t}\n\t\t\t\treturn new Collection(colName, this._s3, undefined);\n\t\t\t}\n\t\t\treturn new Collection(colName, this._s3, this._avro.parse(schema));\n\t\t} catch (error) {\n\t\t\tthrow new Error(`${MODULE_NAME}: ${error.message}`);\n\t\t}\n\t}\n}\n\nclass Collection {\n\tconstructor(colName, s3, avroType = undefined) {\n\t\tthis._colName = colName;\n\t\tthis._s3 = s3;\n\t\tthis._avro = avro;\n\t\tthis._avroType = avroType;\n\t}\n\n\tasync insert(doc, schema = undefined) {\n\t\ttry {\n\t\t\tif (doc === undefined || doc === null) {\n\t\t\t\tthrow new Error(`${MODULE_NAME}: Document is required for insert`);\n\t\t\t}\n\t\t\tif (typeof doc !== 'object' && !Array.isArray(doc)) {\n\t\t\t\tthrow new Error(`${MODULE_NAME}: Document must be an object or an array`);\n\t\t\t}\n\t\t\tconst items = !Array.isArray(doc) ? [doc] : doc;\n\n\t\t\tconst avroType = !!schema ? this._avro.parse(schema) : this._avroType || this._avro.parse(inferAvroType(doc));\n\n\t\t\t// throw new Error('avroType::: ', avroType);\n\t\t\tif (avroType === undefined) {\n\t\t\t\tthrow new Error(`${MODULE_NAME}: Schema is required - Pass a schema to the insert method`);\n\t\t\t}\n\t\t\tthis._avroType = avroType;\n\t\t\tconst wrapperType = this._avro.parse({ type: 'array', items: this._avroType });\n\t\t\tconst bufferData = await this._loadDataBuffer();\n\t\t\tconst data = bufferData.length > 0 ? wrapperType.fromBuffer(bufferData) : [];\n\t\t\tfor (let item of items) {\n\t\t\t\tif (typeof item !== 'object' || item === null) {\n\t\t\t\t\tthrow new Error('Invalid input: input must be an object or an array of objects');\n\t\t\t\t}\n\t\t\t\titem._id = item._id || (await generateUUID());\n\t\t\t\tconst valid = this._avroType.isValid(item);\n\t\t\t\tif (!valid) {\n\t\t\t\t\tthrow new Error(`${MODULE_NAME}: Invalid document or schema`);\n\t\t\t\t}\n\t\t\t\tdata.push(item);\n\t\t\t}\n\t\t\tconst resp = await this._saveDataBuffer(wrapperType.toBuffer(data));\n\t\t\tif (resp) {\n\t\t\t\treturn items;\n\t\t\t} else {\n\t\t\t\tthrow new Error(`${MODULE_NAME}: Failed to insert document`);\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tthrow new Error(`${MODULE_NAME}: ${error.message}`);\n\t\t}\n\t}\n\n\tasync _loadDataBuffer() {\n\t\ttry {\n\t\t\tconst KEY = `${PROJECT_DIR_PREFIX}${this._colName}${SCHEMA_SUFFIX}`;\n\t\t\tconst CHUNK_SIZE = this._s3.getMaxRequestSizeInBytes() || CHUNG_5MB;\n\t\t\tlet firstData = await this._s3.get(KEY);\n\t\t\tif (firstData.length < CHUNK_SIZE) {\n\t\t\t\treturn Buffer.from(firstData, 'utf8');\n\t\t\t}\n\t\t\tlet offset = CHUNK_SIZE;\n\t\t\tlet bufferArr = [Buffer.from(firstData, 'utf8')];\n\t\t\tlet repeat = true;\n\t\t\twhile (repeat) {\n\t\t\t\tconst nextDataResponse = await this._s3.getResponse(KEY, false, offset, offset + CHUNK_SIZE);\n\t\t\t\tconst nextDataBody = await nextDataResponse.text();\n\t\t\t\tbufferArr.push(Buffer.from(nextDataBody, 'utf8'));\n\t\t\t\toffset += CHUNG;\n\t\t\t\tconst contentLength = nextDataResponse.headers.get('content-length') || nextDataBody.length;\n\t\t\t\tif (contentLength < CHUNK_SIZE) {\n\t\t\t\t\trepeat = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn Buffer.concat(bufferArr);\n\t\t} catch (error) {\n\t\t\tif (error.toString().indexOf('status 404: Unknown - Not Found') > -1) {\n\t\t\t\treturn Buffer.from('');\n\t\t\t}\n\t\t\tthrow new Error(`${MODULE_NAME}: ${error.message}`);\n\t\t}\n\t}\n\n\tasync _saveDataBuffer(data) {\n\t\ttry {\n\t\t\tconst KEY = `${PROJECT_DIR_PREFIX}${this._colName}${SCHEMA_SUFFIX}`;\n\t\t\tconst resp = await this._s3.put(KEY, data);\n\t\t\tif (resp.status === 200) {\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\tthrow new Error(`${MODULE_NAME}: Failed to save data`);\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tthrow new Error(`${MODULE_NAME}: ${error.message}`);\n\t\t}\n\t}\n\n\tasync find(query = {}, options = {}) {\n\t\ttry {\n\t\t\tconst bufferData = await this._loadDataBuffer(); // load data from s3\n\t\t\tconst wrapperType = this._avro.parse({ type: 'array', items: this._avroType });\n\t\t\tconst data = bufferData.length > 0 ? wrapperType.fromBuffer(bufferData) : [];\n\t\t\tconst start = parseInt(options.skip, 10) || 0;\n\t\t\tconst end = parseInt(options.limit, 10) ? start + parseInt(options.limit, 10) : undefined;\n\t\t\tconst filteredData = data.filter((doc) => matchesQuery(doc, query)).slice(start, end);\n\t\t\treturn filteredData;\n\t\t} catch (error) {\n\t\t\tthrow new Error(`${MODULE_NAME}: ${error.message}`);\n\t\t}\n\t}\n\n\tasync findOne(query = {}) {\n\t\treturn (await this.find(query))[0] || null;\n\t}\n\n\tasync update(query = {}, update = {}) {\n\t\ttry {\n\t\t\tconst bufferData = await this._loadDataBuffer(); // load data from s3\n\t\t\tconst wrapperType = this._avro.parse({ type: 'array', items: this._avroType });\n\t\t\tconst data = bufferData.length > 0 ? wrapperType.fromBuffer(bufferData) : [];\n\t\t\tlet updatedCount = 0;\n\n\t\t\tfor (let i = 0; i < data.length; i++) {\n\t\t\t\tif (matchesQuery(data[i], query)) {\n\t\t\t\t\tObject.assign(data[i], update);\n\t\t\t\t\tupdatedCount++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (updatedCount > 0) {\n\t\t\t\tconst resp = await this._saveDataBuffer(wrapperType.toBuffer(data));\n\t\t\t\tif (resp) {\n\t\t\t\t\treturn updatedCount;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn 0;\n\t\t} catch (error) {\n\t\t\tthrow new Error(`${MODULE_NAME}: ${error.message}`);\n\t\t}\n\t}\n\n\tasync updateOne(query = {}, update = {}) {\n\t\ttry {\n\t\t\tconst bufferData = await this._loadDataBuffer(); // load data from s3\n\t\t\tconst wrapperType = this._avro.parse({ type: 'array', items: this._avroType });\n\t\t\tconst data = bufferData.length > 0 ? wrapperType.fromBuffer(bufferData) : [];\n\t\t\tconst docIndex = data.findIndex((doc) => matchesQuery(doc, query));\n\n\t\t\tif (docIndex !== -1) {\n\t\t\t\tObject.assign(data[docIndex], update);\n\t\t\t\tconst resp = await this._saveDataBuffer(wrapperType.toBuffer(data));\n\t\t\t\tif (resp) {\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn 0;\n\t\t} catch (error) {\n\t\t\tthrow new Error(`${MODULE_NAME}: ${error.message}`);\n\t\t}\n\t}\n\n\tasync delete(query = {}) {\n\t\ttry {\n\t\t\tconst bufferData = await this._loadDataBuffer(); // load data from s3\n\t\t\tconst wrapperType = this._avro.parse({ type: 'array', items: this._avroType });\n\t\t\tconst data = bufferData.length > 0 ? wrapperType.fromBuffer(bufferData) : [];\n\t\t\tconst initialLength = data.length;\n\t\t\tconst newData = data.filter((doc) => !matchesQuery(doc, query));\n\t\t\tconst resp = await this._saveDataBuffer(wrapperType.toBuffer(newData));\n\t\t\tif (resp) {\n\t\t\t\treturn initialLength - newData.length;\n\t\t\t}\n\t\t\treturn 0;\n\t\t} catch (error) {\n\t\t\tthrow new Error(`${MODULE_NAME}: ${error.message}`);\n\t\t}\n\t}\n\n\tasync count(query = {}) {\n\t\ttry {\n\t\t\tif (query === undefined || query === null) {\n\t\t\t\tthrow new Error(`${MODULE_NAME}: Query is required`);\n\t\t\t}\n\t\t\tif (Object.keys(query).length === 0) {\n\t\t\t\tconst bufferData = await this._loadDataBuffer(); // load data from s3\n\t\t\t\tconst wrapperType = this._avro.parse({ type: 'array', items: this._avroType });\n\t\t\t\tconst data = bufferData.length > 0 ? wrapperType.fromBuffer(bufferData) : [];\n\t\t\t\treturn data.length || null;\n\t\t\t}\n\t\t\treturn (await this.find(query)).length;\n\t\t} catch (error) {\n\t\t\tthrow new Error(`${MODULE_NAME}: ${error.message}`);\n\t\t}\n\t}\n}\n\nexport default lowstorage;\nexport { lowstorage };\n", "'use strict';\n\n// export const avroLoader = async (isAvroLoaded) => {\n// \tconst avro = isAvroLoaded ? isAvroLoaded : await import('avro-js');\n// \treturn avro;\n// };\n\nimport { randomUUID } from 'node:crypto';\n\nexport const matchesQuery = (document, query) => {\n\treturn Object.keys(query).every((key) => document[key] === query[key]);\n};\n\nexport const generateUUID = async () => {\n\tlet _randomUUID = randomUUID || (await import('node:crypto')).randomUUID;\n\tif (typeof _randomUUID !== 'undefined' && typeof _randomUUID === 'function') {\n\t\treturn _randomUUID();\n\t} else {\n\t\t// Fallback for environments without crypto.randomUUID\n\t\treturn 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\n\t\t\tvar r = (Math.random() * 16) | 0,\n\t\t\t\tv = c === 'x' ? r : (r & 0x3) | 0x8;\n\t\t\treturn v.toString(16);\n\t\t});\n\t}\n};\n\nconst _getAvroType = (value, name = 'SubAutoGenerated') => {\n\tswitch (typeof value) {\n\t\tcase 'string':\n\t\t\tif (_isUUID(value)) {\n\t\t\t\treturn {\n\t\t\t\t\ttype: 'string',\n\t\t\t\t\tname: '_id',\n\t\t\t\t\tsize: 16,\n\t\t\t\t\tlogicalType: 'UUID',\n\t\t\t\t};\n\t\t\t}\n\t\t\treturn 'string';\n\t\tcase 'number':\n\t\t\treturn Number.isInteger(value) ? 'int' : 'float';\n\t\tcase 'boolean':\n\t\t\treturn 'boolean';\n\t\tcase 'object':\n\t\t\tif (value === null) return 'null';\n\t\t\tif (Array.isArray(value)) return { type: 'array', items: _getAvroType(value[0]) };\n\t\t\treturn inferAvroType(value, name);\n\t\tdefault:\n\t\t\treturn 'string'; // Default to string for unknown types\n\t}\n};\n\nexport const inferAvroType = (data, typeName = 'AutoGenerated') => {\n\tif (Array.isArray(data)) {\n\t\tdata = data[0];\n\t}\n\tconst fields = Object.entries(data).map(([name, value]) => {\n\t\treturn { name, type: _getAvroType(value, `${typeName}.${name}`) };\n\t});\n\treturn {\n\t\ttype: 'record',\n\t\tname: typeName,\n\t\tfields: fields,\n\t};\n};\n\nconst _isUUID = (str) => {\n\tconst uuidV4Regex = /^[0-9A-F]{8}-[0-9A-F]{4}-4[0-9A-F]{3}-[89AB][0-9A-F]{3}-[0-9A-F]{12}$/i;\n\treturn uuidV4Regex.test(str);\n};\n"],
  "mappings": "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",
  "names": ["_createHmac", "_createHash", "AWS_ALGORITHM", "AWS_REQUEST_TYPE", "S3_SERVICE", "LIST_TYPE", "UNSIGNED_PAYLOAD", "DEFAULT_STREAM_CONTENT_TYPE", "XML_CONTENT_TYPE", "JSON_CONTENT_TYPE", "SENSITIVE_KEYS_REDACTED", "MIN_MAX_REQUEST_SIZE_IN_BYTES", "HEADER_AMZ_CONTENT_SHA256", "HEADER_AMZ_DATE", "HEADER_HOST", "HEADER_AUTHORIZATION", "HEADER_CONTENT_TYPE", "HEADER_CONTENT_LENGTH", "HEADER_ETAG", "HEADER_LAST_MODIFIED", "ERROR_PREFIX", "ERROR_ACCESS_KEY_REQUIRED", "ERROR_SECRET_KEY_REQUIRED", "ERROR_ENDPOINT_REQUIRED", "ERROR_BUCKET_NAME_REQUIRED", "ERROR_KEY_REQUIRED", "ERROR_UPLOAD_ID_REQUIRED", "ERROR_PARTS_REQUIRED", "ERROR_INVALID_PART", "ERROR_DATA_BUFFER_REQUIRED", "ERROR_PATH_REQUIRED", "ERROR_PREFIX_TYPE", "ERROR_MAX_KEYS_TYPE", "expectArray", "encodeAsHex", "c", "uriEscape", "uriStr", "uriResourceEscape", "string", "S3", "accessKeyId", "secretAccessKey", "endpoint", "bucketName", "region", "maxRequestSizeInBytes", "requestAbortTimeout", "logger", "props", "level", "message", "additionalData", "sanitize", "obj", "acc", "key", "sanitizedData", "logEntry", "headers", "encodedKey", "url", "signedHeaders", "contentLength", "res", "error", "errorMessage", "method", "keyPath", "query", "body", "datetime", "_hash", "canonicalHeaders", "canonicalRequest", "stringToSign", "signature", "authorizationHeader", "value", "credentialScope", "signingKey", "_hmac", "path", "prefix", "maxKeys", "opts", "urlWithQuery", "responseBody", "lastModified", "etag", "data", "_parseXml", "output", "_a", "_b", "_c", "wholeFile", "rangeFrom", "rangeTo", "fileType", "parsedResponse", "uploadId", "partNumber", "ETag", "parts", "part", "xmlBody", "errorBody", "errorCode", "queryParams", "dateStamp", "kDate", "kRegion", "kService", "content", "hashSum", "encoding", "hmacSum", "str", "unescapeXml", "json", "re", "match", "fullKey", "parsedValue", "c"]
}
