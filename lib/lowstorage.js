var se=crypto.createHmac||(await import("node:crypto")).createHmac,ie=crypto.createHash||(await import("node:crypto")).createHash;typeof se>"u"&&typeof ie>"u"&&console.error("ultralight-S3 Module: Crypto functions are not available, please report the issue with necessary description: https://github.com/sentienhq/ultralight-s3/issues");var V="AWS4-HMAC-SHA256",F="aws4_request",K="s3",ue="2",R="UNSIGNED-PAYLOAD",de="application/octet-stream",z="application/xml",U="application/json",pe=["accessKeyId","secretAccessKey","sessionToken","password"],X=5*1024*1024,E="x-amz-content-sha256",fe="x-amz-date",_e="host",ge="Authorization",T="Content-Type",b="Content-Length",Q="etag",W="last-modified",u="ultralight-s3 Module: ",Re=`${u}accessKeyId must be a non-empty string`,Ee=`${u}secretAccessKey must be a non-empty string`,ye=`${u}endpoint must be a non-empty string`,we=`${u}bucketName must be a non-empty string`,Y=`${u}key must be a non-empty string`,x=`${u}uploadId must be a non-empty string`,J=`${u}parts must be a non-empty array`,Z=`${u}Each part must have a partNumber (number) and ETag (string)`,k=`${u}data must be a Buffer or string`,ee=`${u}prefix must be a string`,te=`${u}maxKeys must be a positive integer`,re=`${u}delimiter must be a string`,me={contents:!0},Oe=r=>`%${r.charCodeAt(0).toString(16).toUpperCase()}`,j=r=>encodeURIComponent(r).replace(/[!'()*]/g,Oe),$=r=>j(r).replace(/%2F/g,"/"),ae=class{constructor({accessKeyId:r,secretAccessKey:e,endpoint:t,bucketName:s,region:i="auto",maxRequestSizeInBytes:a=X,requestAbortTimeout:n=void 0,logger:h=void 0}){this.getBucketName=()=>this.bucketName,this.setBucketName=o=>{this.bucketName=o},this.getRegion=()=>this.region,this.setRegion=o=>{this.region=o},this.getEndpoint=()=>this.endpoint,this.setEndpoint=o=>{this.endpoint=o},this.getMaxRequestSizeInBytes=()=>this.maxRequestSizeInBytes,this.setMaxRequestSizeInBytes=o=>{this.maxRequestSizeInBytes=o},this.getProps=()=>({accessKeyId:this.accessKeyId,secretAccessKey:this.secretAccessKey,region:this.region,bucket:this.bucketName,endpoint:this.endpoint,maxRequestSizeInBytes:this.maxRequestSizeInBytes,requestAbortTimeout:this.requestAbortTimeout,logger:this.logger}),this.setProps=o=>{this._validateConstructorParams(o.accessKeyId,o.secretAccessKey,o.bucketName,o.endpoint),this.accessKeyId=o.accessKeyId,this.secretAccessKey=o.secretAccessKey,this.region=o.region||"auto",this.bucketName=o.bucketName,this.endpoint=o.endpoint,this.maxRequestSizeInBytes=o.maxRequestSizeInBytes||X,this.requestAbortTimeout=o.requestAbortTimeout,this.logger=o.logger},this._validateConstructorParams(r,e,t,s),this.accessKeyId=r,this.secretAccessKey=e,this.endpoint=t,this.bucketName=s,this.region=i,this.maxRequestSizeInBytes=a,this.requestAbortTimeout=n,this.logger=h}_validateConstructorParams(r,e,t,s){if(typeof r!="string"||r.trim().length===0)throw new TypeError(Re);if(typeof e!="string"||e.trim().length===0)throw new TypeError(Ee);if(typeof t!="string"||t.trim().length===0)throw new TypeError(ye);if(typeof s!="string"||s.trim().length===0)throw new TypeError(we)}_checkMethodHeadnGet(r){if(r!=="GET"&&r!=="HEAD")throw this._log("error",`${u}method must be either GET or HEAD`),new Error("method must be either GET or HEAD")}_checkKey(r){if(typeof r!="string"||r.trim().length===0)throw this._log("error",Y),new TypeError(Y)}_checkDelimiter(r){if(typeof r!="string"||r.trim().length===0)throw this._log("error",re),new TypeError(re)}_checkPrefix(r){if(typeof r!="string")throw this._log("error",ee),new TypeError(ee)}_checkMaxKeys(r){if(typeof r!="number"||r<=0)throw this._log("error",te),new TypeError(te)}_checkOpts(r){if(typeof r!="object")throw this._log("error",`${u}opts must be an object`),new TypeError(`${u}opts must be an object`)}_log(r,e,t={}){if(this.logger&&typeof this.logger[r]=="function"){let s=n=>typeof n!="object"||n===null?n:Object.keys(n).reduce((h,o)=>(pe.includes(o.toLowerCase())?h[o]="[REDACTED]":typeof n[o]=="object"&&n[o]!==null?h[o]=s(n[o]):h[o]=n[o],h),Array.isArray(n)?[]:{}),i=s(t),a={timestamp:new Date().toISOString(),level:r,message:e,...i,context:s({bucketName:this.bucketName,region:this.region,endpoint:this.endpoint,accessKeyId:this.accessKeyId?`${this.accessKeyId.substring(0,4)}...`:void 0})};this.logger[r](a)}}async getContentLength(r){this._checkKey(r);let e={[E]:R},t=$(r),{url:s,headers:i}=await this._sign("HEAD",t,{},e,""),a=(await this._sendRequest(s,"HEAD",i)).headers.get(b);return a?parseInt(a,10):0}async bucketExists(){let r={[E]:R},{url:e,headers:t}=await this._sign("HEAD","",{},r,""),s=await this._sendRequest(e,"HEAD",t);return!!(s.ok&&s.status===200)}async fileExists(r){this._checkKey(r);let e={[E]:R},t=$(r),{url:s,headers:i}=await this._sign("HEAD",t,{},e,"");try{let a=await fetch(s,{method:"HEAD",headers:i});return a.ok&&a.status===200?!0:(a.status===404||this._handleErrorResponse(a),!1)}catch(a){let n=a instanceof Error?a.message:String(a);throw this._log("error",`${u}Failed to check if file exists: ${n}`),new Error(`${u}Failed to check if file exists: ${n}`)}}async _sign(r,e,t,s,i){let a=new Date().toISOString().replace(/[:-]|\.\d{3}/g,""),n=typeof e=="string"&&e.length>0?new URL(e,this.endpoint):new URL(this.endpoint);n.pathname=`/${encodeURI(this.bucketName)}${n.pathname}`,s[E]=i?await M(i):R,s[fe]=a,s[_e]=n.host;let h=this._buildCanonicalHeaders(s),o=Object.keys(s).map(O=>O.toLowerCase()).sort().join(";"),c=await this._buildCanonicalRequest(r,n,t,h,o,i),f=await this._buildStringToSign(a,c),_=await this._calculateSignature(a,f),y=this._buildAuthorizationHeader(a,o,_);return s[ge]=y,{url:n.toString(),headers:s}}_buildCanonicalHeaders(r){return Object.entries(r).map(([e,t])=>`${e.toLowerCase()}:${String(t).trim()}`).sort().join(`
`)}async _buildCanonicalRequest(r,e,t,s,i,a){return[r,e.pathname,this._buildCanonicalQueryString(t),`${s}
`,i,a?await M(a):R].join(`
`)}async _buildStringToSign(r,e){let t=[r.slice(0,8),this.region,K,F].join("/");return[V,r,t,await M(e)].join(`
`)}async _calculateSignature(r,e){let t=await this._getSignatureKey(r.slice(0,8));return L(t,e,"hex")}_buildAuthorizationHeader(r,e,t){let s=[r.slice(0,8),this.region,K,F].join("/");return[`${V} Credential=${this.accessKeyId}/${s}`,`SignedHeaders=${e}`,`Signature=${t}`].join(", ")}async list(r="/",e="",t=1e3,s="GET",i={}){this._checkDelimiter(r),this._checkPrefix(e),this._checkMaxKeys(t),this._checkMethodHeadnGet(s),this._checkOpts(i),this._log("info",`Listing objects in ${e}`);let a={"list-type":ue,"max-keys":String(t),...i};e.length>0&&(a.prefix=e);let n={[T]:U,[E]:R},h=r==="/"?r:j(r),{url:o,headers:c}=await this._sign("GET",h,a,n,""),f=`${o}?${new URLSearchParams(a)}`,_=await this._sendRequest(f,"GET",c),y=await _.text();if(s==="HEAD"){let A=_.headers.get(b),S=_.headers.get(W),le=_.headers.get(Q);return{size:A?+A:void 0,mtime:S?new Date(S):void 0,ETag:le||void 0}}let O=N(y),P=O.listBucketResult||O.error||O;return P.contents||P}async listMultiPartUploads(r="/",e="",t="GET",s={}){var i,a,n;this._checkDelimiter(r),this._checkPrefix(e),this._checkMethodHeadnGet(t),this._checkOpts(s),this._log("info",`Listing multipart uploads in ${e}`);let h={uploads:"",...s},o={[T]:U,[E]:R},c=r==="/"?r:j(r),{url:f,headers:_}=await this._sign("GET",c,h,o,""),y=`${f}?${new URLSearchParams(h)}`,O=await this._sendRequest(y,"GET",_),P=await O.text();if(t==="HEAD")return{size:+((i=O.headers.get(b))!==null&&i!==void 0?i:"0"),mtime:new Date((a=O.headers.get(W))!==null&&a!==void 0?a:""),ETag:(n=O.headers.get(Q))!==null&&n!==void 0?n:""};let A=N(P),S=A.listMultipartUploadsResult||A.error||A;return S.uploads||S}async get(r,e={}){this._checkKey(r),this._log("info",`Getting object ${r}`);let t={[T]:U,[E]:R},s=$(r),{url:i,headers:a}=await this._sign("GET",s,e,t,"");return(await this._sendRequest(i,"GET",a)).text()}async getResponse(r,e=!0,t=0,s=this.maxRequestSizeInBytes,i={}){this._checkKey(r);let a=i,n={[T]:U,[E]:R,...e?{}:{range:`bytes=${t}-${s-1}`}},h=$(r),{url:o,headers:c}=await this._sign("GET",h,a,n,""),f=`${o}?${new URLSearchParams(a)}`;return this._sendRequest(f,"GET",c)}async put(r,e){if(this._checkKey(r),!(e instanceof Buffer||typeof e=="string"))throw this._log("error",k),new TypeError(k);this._log("info",`Uploading object ${r}`);let t=typeof e=="string"?Buffer.byteLength(e):e.length,s={[b]:t},i=$(r),{url:a,headers:n}=await this._sign("PUT",i,{},s,e);return await this._sendRequest(a,"PUT",n,e)}async getMultipartUploadId(r,e=de){if(this._checkKey(r),typeof e!="string")throw this._log("error",`${u}fileType must be a string`),new TypeError(`${u}fileType must be a string`);this._log("info",`Initiating multipart upload for object ${r}`);let t={uploads:""},s={[T]:e,[E]:R},i=$(r),{url:a,headers:n}=await this._sign("POST",i,t,s,""),h=`${a}?${new URLSearchParams(t)}`,o=await(await this._sendRequest(h,"POST",n)).text(),c=N(o);if(typeof c=="object"&&c!==null&&"error"in c&&typeof c.error=="object"&&c.error!==null&&"message"in c.error){let f=String(c.error.message);throw this._log("error",`${u}Failed to abort multipart upload: ${f}`),new Error(`${u}Failed to abort multipart upload: ${f}`)}if(typeof c=="object"&&c!==null){if(!c.initiateMultipartUploadResult||!c.initiateMultipartUploadResult.uploadId)throw this._log("error",`${u}Failed to create multipart upload: no uploadId in response`),new Error(`${u}Failed to create multipart upload: Missing upload ID in response`);return c.initiateMultipartUploadResult.uploadId}else throw this._log("error",`${u}Failed to create multipart upload: unexpected response format`),new Error(`${u}Failed to create multipart upload: Unexpected response format`)}async uploadPart(r,e,t,s,i={}){this._validateUploadPartParams(r,e,t,s,i);let a={uploadId:t,partNumber:s,...i},n={[b]:e.length},h=$(r),{url:o,headers:c}=await this._sign("PUT",h,a,n,e),f=`${o}?${new URLSearchParams(a)}`,_=(await this._sendRequest(f,"PUT",c,e)).headers.get("etag")||"";return{partNumber:s,ETag:_}}_validateUploadPartParams(r,e,t,s,i){if(this._checkKey(r),!(e instanceof Buffer||typeof e=="string"))throw this._log("error",k),new TypeError(k);if(typeof t!="string"||t.trim().length===0)throw this._log("error",x),new TypeError(x);if(!Number.isInteger(s)||s<=0)throw this._log("error",`${u}partNumber must be a positive integer`),new TypeError(`${u}partNumber must be a positive integer`);this._checkOpts(i)}async completeMultipartUpload(r,e,t){if(this._checkKey(r),typeof e!="string"||e.trim().length===0)throw this._log("error",x),new TypeError(x);if(!Array.isArray(t)||t.length===0)throw this._log("error",J),new TypeError(J);if(!t.every(y=>typeof y.partNumber=="number"&&typeof y.ETag=="string"))throw this._log("error",Z),new TypeError(Z);this._log("info",`Complete multipart upload ${e} for object ${r}`);let s={uploadId:e},i=this._buildCompleteMultipartUploadXml(t),a={[T]:z,[b]:Buffer.byteLength(i).toString(),[E]:await M(i)},n=$(r),{url:h,headers:o}=await this._sign("POST",n,s,a,i),c=`${h}?${new URLSearchParams(s)}`,f=await(await this._sendRequest(c,"POST",o,i)).text(),_=N(f);if(typeof _=="object"&&_!==null&&"error"in _&&typeof _.error=="object"&&_.error!==null&&"message"in _.error){let y=String(_.error.message);throw this._log("error",`${u}Failed to abort multipart upload: ${y}`),new Error(`${u}Failed to abort multipart upload: ${y}`)}return _.completeMultipartUploadResult}async abortMultipartUpload(r,e){if(this._checkKey(r),typeof e!="string"||e.trim().length===0)throw this._log("error",x),new TypeError(x);this._log("info",`Aborting multipart upload ${e} for object ${r}`);let t={uploadId:e},s={[T]:z,[E]:R};try{let i=$(r),{url:a,headers:n}=await this._sign("DELETE",i,t,s,""),h=`${a}?${new URLSearchParams(t)}`,o=await this._sendRequest(h,"DELETE",n);if(o.ok){let c=await o.text(),f=N(c);if(typeof f=="object"&&f!==null&&"error"in f&&typeof f.error=="object"&&f.error!==null&&"message"in f.error){let _=String(f.error.message);throw this._log("error",`${u}Failed to abort multipart upload: ${_}`),new Error(`${u}Failed to abort multipart upload: ${_}`)}return{status:"Aborted",key:r,uploadId:e,response:f}}else throw this._log("error",`${u}Abort request failed with status ${o.status}`),new Error(`${u}Abort request failed with status ${o.status}`)}catch(i){let a=i instanceof Error?i.message:String(i);throw this._log("error",`${u}Failed to abort multipart upload for key ${r}: ${a}`),new Error(`${u}Failed to abort multipart upload for key ${r}: ${a}`)}}_buildCompleteMultipartUploadXml(r){return`
      <CompleteMultipartUpload>
        ${r.map(e=>`
          <Part>
            <PartNumber>${e.partNumber}</PartNumber>
            <ETag>${e.ETag}</ETag>
          </Part>
        `).join("")}
      </CompleteMultipartUpload>
    `}async delete(r){this._checkKey(r),this._log("info",`Deleting object ${r}`);let e={[T]:U,[E]:R},t=$(r),{url:s,headers:i}=await this._sign("DELETE",t,{},e,"");return(await this._sendRequest(s,"DELETE",i)).text()}async _sendRequest(r,e,t,s){this._log("info",`Sending ${e} request to ${r}, headers: ${JSON.stringify(t)}`);let i=await fetch(r,{method:e,headers:t,body:s,signal:this.requestAbortTimeout!==void 0?AbortSignal.timeout(this.requestAbortTimeout):void 0});return i.ok||await this._handleErrorResponse(i),i}async _handleErrorResponse(r){let e=await r.text(),t=r.headers.get("x-amz-error-code")||"Unknown",s=r.headers.get("x-amz-error-message")||r.statusText;throw this._log("error",`${u}Request failed with status ${r.status}: ${t} - ${s},err body: ${e}`),new Error(`${u}Request failed with status ${r.status}: ${t} - ${s}, err body: ${e}`)}_buildCanonicalQueryString(r){return Object.keys(r).length<1?"":Object.keys(r).sort().map(e=>`${encodeURIComponent(e)}=${encodeURIComponent(r[e])}`).join("&")}async _getSignatureKey(r){let e=await L(`AWS4${this.secretAccessKey}`,r),t=await L(e,this.region),s=await L(t,K);return L(s,F)}},M=async r=>{let e=ie("sha256");return e.update(r),e.digest("hex")},L=async(r,e,t)=>{let s=se("sha256",r);return s.update(e),s.digest(t)},N=r=>{let e=a=>a.replace(/&quot;/g,'"').replace(/&apos;/g,"'").replace(/&lt;/g,"<").replace(/&gt;/g,">").replace(/&amp;/g,"&"),t={},s=/<(\w)([-\w]+)(?:\/|[^>]*>((?:(?!<\1)[\s\S])*)<\/\1\2)>/gm,i;for(;i=s.exec(r);){let[,a,n,h]=i,o=a.toLowerCase()+n,c=h!=null?N(h):!0;typeof c=="string"?t[o]=e(c):Array.isArray(t[o])?t[o].push(c):t[o]=t[o]!=null?[t[o],c]:me[o]?[c]:c}return Object.keys(t).length?t:e(r)};import ce from"avro-js";var l={MISSING_ARGUMENT:"MISSING_ARGUMENT",COLLECTION_EXISTS:"COLLECTION_EXISTS",CREATE_COLLECTION_ERROR:"CREATE_COLLECTION_ERROR",RENAME_COLLECTION_ERROR:"RENAME_COLLECTION_ERROR",REMOVE_COLLECTION_ERROR:"REMOVE_COLLECTION_ERROR",UPDATE_COLLECTION_SCHEMA_ERROR:"UPDATE_COLLECTION_SCHEMA_ERROR",COLLECTION_NOT_FOUND:"COLLECTION_NOT_FOUND",SCHEMA_VALIDATION_ERROR:"SCHEMA_VALIDATION_ERROR",DOCUMENT_VALIDATION_ERROR:"DOCUMENT_VALIDATION_ERROR",S3_OPERATION_ERROR:"S3_OPERATION_ERROR",FIND_ERROR:"FIND_ERROR",FIND_ONE_ERROR:"FIND_ONE_ERROR",SAVE_DATA_ERROR:"SAVE_DATA_ERROR",INSERT_ERROR:"INSERT_ERROR",UPDATE_ERROR:"UPDATE_ERROR",UPDATE_ONE_ERROR:"UPDATE_ONE_ERROR",DELETE_ERROR:"DELETE_ERROR",COUNT_ERROR:"COUNT_ERROR",UNKNOWN_ERROR:"UNKNOWN_ERROR"},p=class extends Error{constructor(e,t=l.UNKNOWN_ERROR){super(`lowstorageError: ${e} :: code: ${t}`),this.name=this.constructor.name,this.code=t,Error.captureStackTrace(this,this.constructor)}},B=class extends p{constructor(e){super(`Collection ${e} not found`,l.COLLECTION_NOT_FOUND)}},D=class extends p{constructor(e){super(e,l.SCHEMA_VALIDATION_ERROR)}},I=class extends p{constructor(e){super(e,l.DOCUMENT_VALIDATION_ERROR)}},g=class extends p{constructor(e,t){super(`S3 ${t} operation failed: ${e}`,l.S3_OPERATION_ERROR)}};import{randomUUID as q}from"node:crypto";var v=(r,e)=>Object.keys(e).every(t=>r[t]===e[t]),oe=async()=>typeof q<"u"&&typeof q=="function"?q():typeof crypto<"u"&&typeof crypto=="object"&&typeof crypto.randomUUID=="function"?crypto.randomUUID():"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g,function(r){var e=Math.random()*16|0,t=r==="x"?e:e&3|8;return t.toString(16)}),ne=(r,e="SubAutoGenerated")=>{switch(typeof r){case"string":return $e(r)?{type:"string",name:"_id",size:16,logicalType:"UUID"}:"string";case"number":return Number.isInteger(r)?"int":"float";case"boolean":return"boolean";case"object":return r===null?"null":Array.isArray(r)?{type:"array",items:ne(r[0])}:H(r,e);default:return"string"}},H=(r,e="AutoGenerated")=>{Array.isArray(r)&&(r=r[0]);let t=Object.entries(r).map(([s,i])=>({name:s,type:ne(i,`${e}.${s}`)}));return{type:"record",name:e,fields:t}},$e=r=>/^[0-9A-F]{8}-[0-9A-F]{4}-4[0-9A-F]{3}-[89AB][0-9A-F]{3}-[0-9A-F]{12}$/i.test(r);var d="lowstorage",w="/",G="lowstorage",m=".avro",Te=1024*1024,Ie=5*Te,he=class{constructor(e={accessKeyId:void 0,secretAccessKey:void 0,endpoint:void 0,bucketName:void 0,region:"auto",logger:null,dirPrefix:G}){this._checkArgs(e),this._schemas=new Map,this._s3=new ae(e),this._dirPrefix=e.dirPrefix||G,this._avro=ce}_checkArgs=e=>{let t=["accessKeyId","secretAccessKey","endpoint","bucketName"];for(let s of t)if(!e[s])throw new p(`${d}: ${s} is required`,l.MISSING_ARGUMENT)};_hasColName=e=>{if(e.trim()===""||e===null||typeof e>"u")throw new p(`${d}: Collection name is required`,l.MISSING_ARGUMENT)};async listCollections(){try{let e=await this._s3.list(w,this._dirPrefix);return typeof e=="object"&&e!==null&&e.keyCount==="0"?[]:e.map(t=>t.key.slice(this._dirPrefix.length+1,-m.length))}catch(e){throw new g(`${d}: ${e.message}`,l.S3_OPERATION_ERROR)}}async collectionExists(e){try{return this._hasColName(e),await this._s3.fileExists(`${this._dirPrefix}${w}${e}${m}`)}catch(t){if(t.message.includes("Not Found"))return!1;throw new p(`${d}: ${t.message}`,l.COLLECTION_NOT_FOUND)}}async createCollection(e,t,s=[]){try{if(this._hasColName(e),!await this.collectionExists(e))return await this._s3.put(`${this._dirPrefix}${w}${e}${m}`,s.length>0?s:""),this.collection(e,t);throw new p(`${d}: Collection ${e} already exists`,l.COLLECTION_EXISTS)}catch(i){throw i instanceof p?i:new p(`${d}: ${i.message}`,l.CREATE_COLLECTION_ERROR)}}async removeCollection(e){try{this._hasColName(e);let t=`${this._dirPrefix}${w}${e}${m}`;if(await this.collectionExists(e)){await this._s3.delete(t);let i=await this.collectionExists(e);if(typeof i=="boolean")return!i;throw new g(`${d}: Failed to delete collection ${e}`,l.S3_OPERATION_ERROR)}throw new p(`${d}: Collection ${e} does not exist`,l.REMOVE_COLLECTION_ERROR)}catch(t){throw t instanceof g?t:new p(`${d}: Failed to remove collection: ${t.message}`,l.REMOVE_COLLECTION_ERROR)}}async renameCollection(e,t){try{if(this._hasColName(e),this._hasColName(t),!await this.collectionExists(e))throw new B(`${d}: Collection ${e} does not exist`,l.COLLECTION_NOT_FOUND);let i=this.collection(e),a=await i._loadDataBuffer();if(!await this.removeCollection(e))throw new p(`${d}: Failed to rename collection`,l.RENAME_COLLECTION_ERROR);return await this.createCollection(t,i._avroType,a)}catch(s){throw s instanceof p?s:new p(`${d}: Rename collection failed: ${s.message}`,l.RENAME_COLLECTION_ERROR)}}async collection(e,t,s=!0){try{if(this._hasColName(e),typeof t>"u"){if(this._schemas.has(e))return new C(e,this._s3,this._schemas.get(e),this._dirPrefix);if(await this._s3.fileExists(`${this._dirPrefix}${w}${e}${m}`)){let a=await this._s3.get(`${this._dirPrefix}${w}${e}${m}`),n=this._avro.parse(a);return this._schemas.set(e,n),new C(e,this._s3,n,this._dirPrefix)}return s&&this._s3.put(`${this._dirPrefix}${w}${e}${m}`,""),new C(e,this._s3,void 0,this._dirPrefix)}return s&&(await this._s3.fileExists(`${this._dirPrefix}${w}${e}${m}`)||await this._s3.put(`${this._dirPrefix}${w}${e}${m}`,"")),new C(e,this._s3,this._avro.parse(t),this._dirPrefix)}catch(i){throw new p(`${d}: ${i.message}`,l.COLLECTION_NOT_FOUND)}}s3=()=>this._s3},C=class{constructor(e,t,s=void 0,i=G){this._colName=e,this._s3=t,this._avro=ce,this._avroType=s,this._dirPrefix=i}async insert(e,t=void 0){try{if(e==null)throw new p(`${d}: Document is required for insert`,l.MISSING_ARGUMENT);if(typeof e!="object"&&!Array.isArray(e))throw new I(`${d}: Document must be an object or an array`,l.DOCUMENT_VALIDATION_ERROR);let s=Array.isArray(e)?e:[e],i=t?this._avro.parse(t):this._avroType||this._avro.parse(H(e));if(!i)throw new D(`${d}: Schema is required - Pass a schema to the insert method`,l.SCHEMA_VALIDATION_ERROR);this._avroType=i;let a=this._avro.parse({type:"array",items:this._avroType}),n=await this._loadDataBuffer(),h=n.length>0?a.fromBuffer(n):[];for(let c of s){if(typeof c!="object"||c===null)throw new I(`${d}: Invalid input: input must be an object or an array of objects`,l.DOCUMENT_VALIDATION_ERROR);if(c._id=c._id||await oe(),!this._avroType.isValid(c))throw new I(`${d}: Invalid document or schema`,l.DOCUMENT_VALIDATION_ERROR);h.push(c)}if(!await this._saveDataBuffer(a.toBuffer(h)))throw new g(`${d}: Failed to insert document`,l.S3_OPERATION_ERROR);return s}catch(s){throw s instanceof p?s:new p(`${d} Insert operation failed: ${s.message}`,l.INSERT_ERROR)}}async _loadDataBuffer(){try{let e=`${this._dirPrefix}${w}${this._colName}${m}`,t=this._s3.getMaxRequestSizeInBytes()||Ie,s=await this._s3.get(e);if(s.length<t)return Buffer.from(s,"utf8");let i=t,a=[Buffer.from(s,"utf8")],n=!0;for(;n;){let h=await this._s3.getResponse(e,!1,i,i+t),o=await h.text();a.push(Buffer.from(o,"utf8")),i+=t,(h.headers.get("content-length")||o.length)<t&&(n=!1)}return Buffer.concat(a)}catch(e){if(e.toString().indexOf("status 404: Unknown - Not Found")>-1)return Buffer.from("");throw new g(`${d}: Failed to load data buffer: ${e.message}`,l.S3_OPERATION_ERROR)}}async _saveDataBuffer(e){try{let t=`${this._dirPrefix}${w}${this._colName}${m}`;if((await this._s3.put(t,e)).status!==200)throw new g(`${d}: Failed to save data`,l.S3_OPERATION_ERROR);return!0}catch(t){throw t instanceof g?t:new p(`${d}: ${t.message}`,l.SAVE_DATA_ERROR)}}async find(e={},t={}){try{let s=await this._loadDataBuffer();if(s.length===0)return[];let i=this._avro.parse({type:"array",items:this._avroType}),a=s.length>0?i.fromBuffer(s):[],n=parseInt(t.skip,10)||0,h=parseInt(t.limit,10)?n+parseInt(t.limit,10):void 0;return a.filter(c=>v(c,e)).slice(n,h)}catch(s){throw new p(`${d}: Find operation failed: ${s.message}`,l.FIND_ERROR)}}async findOne(e={}){try{return(await this.find(e))[0]||[]}catch(t){throw new p(`${d}: FindOne operation failed: ${t.message}`,l.FIND_ONE_ERROR)}}async update(e={},t={}){try{if(!this._avroType)throw new D(`${d}: Schema is not defined for this collection`,l.SCHEMA_VALIDATION_ERROR);let s=await this._loadDataBuffer();if(s.length===0)return 0;let i=this._avro.parse({type:"array",items:this._avroType}),a=s.length>0?i.fromBuffer(s):[],n=0;for(let h=0;h<a.length;h++)if(v(a[h],e)){let o={...a[h],...t};if(!this._avroType.isValid(o))throw new I(`${d}: Invalid document or schema`,l.DOCUMENT_VALIDATION_ERROR);a[h]=o,n++}if(n>0&&!await this._saveDataBuffer(i.toBuffer(a)))throw new g(`${d}: Failed to update document`,l.S3_OPERATION_ERROR);return n}catch(s){throw s instanceof g?s:new p(`${d}: Update operation failed: ${s.message}`,l.UPDATE_ERROR)}}async updateOne(e={},t={}){try{if(!this._avroType)throw new D(`${d}: Schema is not defined for this collection`,l.SCHEMA_VALIDATION_ERROR);let s=await this._loadDataBuffer();if(s.length===0)return 0;let i=this._avro.parse({type:"array",items:this._avroType}),a=s.length>0?i.fromBuffer(s):[],n=a.findIndex(h=>v(h,e));if(n!==-1){let h={...a[n],...t};if(!this._avroType.isValid(h))throw new I(`${d}: Invalid document or schema`,l.DOCUMENT_VALIDATION_ERROR);if(a[n]=h,!await this._saveDataBuffer(i.toBuffer(a)))throw new g(`${d}: Failed to update document`,l.S3_OPERATION_ERROR);return 1}return 0}catch(s){throw s instanceof p?s:new p(`${d}: UpdateOne operation failed: ${s.message}`,l.UPDATE_ONE_ERROR)}}async delete(e={}){try{let t=await this._loadDataBuffer();if(t.length===0)return 0;let s=this._avro.parse({type:"array",items:this._avroType}),i=t.length>0?s.fromBuffer(t):[],a=i.length,n=i.filter(o=>!v(o,e));if(!await this._saveDataBuffer(s.toBuffer(n)))throw new g(`${d}: Failed to delete document`,l.S3_OPERATION_ERROR);return a-n.length}catch(t){throw t instanceof g?t:new p(`${d}: Delete operation failed: ${t.message}`,l.DELETE_ERROR)}}async count(e={}){try{if(e==null)throw new p(`${d}: Query is required`,l.MISSING_ARGUMENT);if(Object.keys(e).length===0){let t=await this._loadDataBuffer();if(t.length===0)return 0;let s=this._avro.parse({type:"array",items:this._avroType});return(t.length>0?s.fromBuffer(t):[]).length||null}return(await this.find(e)).length}catch(t){throw new p(`${d}: Count operation failed: ${t.message}`,l.COUNT_ERROR)}}};export{he as lowstorage,p as lowstorageError,l as lowstorage_ERROR_CODES};
//# sourceMappingURL=lowstorage.js.map
