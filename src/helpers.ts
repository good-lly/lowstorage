'use strict';

import { randomUUID } from 'node:crypto';

const matchesQuery = (document: Record<string, any>, query: Record<string, any>): boolean => {
	return Object.keys(query).every((key) => document[key] === query[key]);
};

const generateUUID = async (): Promise<string> => {
	if (typeof randomUUID !== 'undefined' && typeof randomUUID === 'function') {
		return randomUUID();
	}
	if (typeof crypto !== 'undefined' && typeof crypto === 'object' && typeof crypto.randomUUID === 'function') {
		return crypto.randomUUID();
	}
	return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
		var r = (Math.random() * 16) | 0,
			v = c === 'x' ? r : (r & 0x3) | 0x8;
		return v.toString(16);
	});
};

const _getAvroSchema = (value: any, name = 'SubAutoGenerated'): any => {
	switch (typeof value) {
		case 'string':
			if (_isUUID(value)) {
				return {
					type: 'string',
					name: '_id',
					size: 16,
					logicalType: 'UUID',
				};
			}
			return 'string';
		case 'number':
			return Number.isInteger(value) ? 'int' : 'float';
		case 'boolean':
			return 'boolean';
		case 'object':
			if (value === null) return 'null';
			if (Array.isArray(value)) return { type: 'array', items: _getAvroSchema(value[0]) };
			return inferAvroSchema(value, name);
		default:
			return 'string'; // Default to string for unknown types
	}
};

const ensureIdFieldInSchema = (schema: Object): Object => {
	const idField = {
		name: '_id',
		type: 'string',
		size: 16,
		logicalType: 'UUID',
	};
	if (typeof schema === 'undefined' || schema === null) {
		return schema;
	}

	if ('type' in schema && schema.type === 'record' && 'fields' in schema && Array.isArray(schema.fields)) {
		const hasIdField = schema.fields.some((field) => field.name === '_id');
		if (!hasIdField) {
			schema.fields.unshift(idField);
		}
	} else if (
		'type' in schema &&
		schema.type === 'array' &&
		'items' in schema &&
		schema.items !== null &&
		typeof schema.items === 'object' &&
		'type' in schema.items &&
		schema.items.type === 'record' &&
		'fields' in schema.items &&
		Array.isArray(schema.items.fields)
	) {
		const hasIdField = schema.items.fields.some((field) => field.name === '_id');
		if (!hasIdField) {
			schema.items.fields.unshift(idField);
		}
	}
	return schema;
};

const inferAvroSchema = (data: any[] | { [s: string]: unknown } | ArrayLike<unknown>, typeName = 'AutoGenerated') => {
	if (Array.isArray(data)) {
		data = data[0];
	}
	const fields = Object.entries(data).map(([name, value]) => {
		return { name, type: _getAvroSchema(value, `${typeName}.${name}`) };
	});

	const schema = {
		type: 'record',
		name: typeName,
		fields: fields,
	};

	// Ensure the _id field is present in the schema
	return ensureIdFieldInSchema(schema);
};

const _isUUID = (str: string): boolean => {
	const uuidV4Regex = /^[0-9A-F]{8}-[0-9A-F]{4}-4[0-9A-F]{3}-[89AB][0-9A-F]{3}-[0-9A-F]{12}$/i;
	return uuidV4Regex.test(str);
};

export { matchesQuery, generateUUID, inferAvroSchema, ensureIdFieldInSchema };
